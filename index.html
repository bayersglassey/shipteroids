<html>
<head>
<title>Shipteroids!</title>
<style>
body {
    color: #fff;
    background-color: #000;
}
.canvas {
    border: solid 1px #0f0;
    display: inline;
}
.canvas-container {
    width: 100%;
    text-align: center;
}
</style>
</head>
<body>
<div class="canvas-container">
    <canvas id="canvas" class="canvas" width=600 height=600 tabindex=-1></canvas>
</div>
<script>

'use strict';


var TIMING = false;
var VELMUL = .7;
var ROTVELMUL = .7;
var RADIUSMUL = 2;


function linear(x0, x1, n) {
    /* Assumes: 0 <= n <= 1 */
    return x0 + (x1 - x0) * n;
}

function modulo(x, n) {
    /* Returns the modulus of x / n.
    Expects n > 0.

    Example:

         x | n | modulo(x, n)
        ---+---+--------------
         -3| 3 | 0
         -2| 3 | 1
         -1| 3 | 2
          0| 3 | 0
          1| 3 | 1
          2| 3 | 2
          3| 3 | 0
    */
    return ((x % n) + n) % n;
}

function moduloDiff(x0, x1, w) {
    /* Difference between two numbers on the "wrapped" interval between
    0 and w. */
    x0 = modulo(x0, w);
    x1 = modulo(x1, w);
    var diff = x1 - x0;

    if(diff < -w/2)return diff + w;
    else if(diff > w/2)return diff - w;
    else return diff;
}

class Random {
    /* Utility functions for producing random values */

    static randNumber(a, b) {
        if(b === undefined) {
            b = a;
            a = 0;
        }
        return a + Math.random() * (b - a);
    }
    static randInt(a, b) {
        return Math.floor(this.randNumber(a, b));
    }
    static randIntInclusive(a, b) {
        return this.randInt(a, b + 1);
    }
    static choice(choices) {
        return choices[this.randInt(choices.length)];
    }
    static randRotation() {
        return this.randNumber(Math.PI * 2);
    }
}

class Point {
    /* A 2-dimensional point.
    Can also be used to represent the width+height of a rectangle,
    and/or represent the rectangle between (0,0) and (this.x,this.y). */

    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    clone() {
        return new Point(this.x, this.y);
    }
    set(x, y) {
        this.x = x || 0;
        this.y = y || 0;
        return this;
    }
    dist(other, modulo) {
        var dx = Math.abs(this.x - other.x);
        var dy = Math.abs(this.y - other.y);
        if(modulo) {
            // If modulo is provided, it should be a Point representing
            // a rectangle representing a torus within which this and other
            // are contained.
            if(dx > modulo.x / 2) dx = modulo.x - dx;
            if(dy > modulo.y / 2) dy = modulo.y - dy;
        }
        return Math.sqrt(dx * dx + dy * dy);
    }
    copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }
    setMidpoint(other) {
        /* Sets this to the midpoint of the a rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = other.x / 2;
        this.y = other.y / 2;
        return this;
    }
    setRandomWithin(other) {
        /* Sets this to a random point within the rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = Random.randNumber(other.x);
        this.y = Random.randNumber(other.y);
        return this;
    }
    addxy(x, y) {
        this.x += x;
        this.y += y;
        return this;
    }
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    addMul(other, mul) {
        this.x += other.x * mul;
        this.y += other.y * mul;
        return this;
    }
    mul(n) {
        this.x *= n;
        this.y *= n;
        return this;
    }
    modulo(other) {
        /* Returns this Point modulo the rectangle between (0,0) and
        (other.x, other.y).
        You can think of this as constraining this Point within the
        torus defined by the rectangle defined by other.
        If you're into that kind of thing. O_o */
        this.x = modulo(this.x, other.x);
        this.y = modulo(this.y, other.y);
        return this;
    }
    rotate(rot) {
        /*
            for(var i = 0; i < 4; i++) {
                var p = new Point(1).rotate(Math.PI * i / 2); 
                console.log(p);
            }
            // {x:  1, y:  0}
            // {x:  0, y: -1}
            // {x: -1, y:  0}
            // {x:  0, y:  1}
        */
        var sin = Math.sin(rot);
        var cos = Math.cos(rot);
        var x =  this.x;
        var y = -this.y;
        this.x =  (x * cos - y * sin);
        this.y = -(x * sin + y * cos);
        return this;
    }
    setSpeed(speed, rot) {
        return this.set(speed).rotate(rot);
    }
    addSpeed(speed, rot) {
        var x = this.x;
        var y = this.y;
        this.setSpeed(speed, rot);
        this.x += x;
        this.y += y;
        return this;
    }
}


class Field {
    /* Think of "field" in the sense of "playing field".
    It's basically a rectangle within which sprites can fly around.
    The edges of the rectangle "wrap around" (or you can say it's a
    "torus" if you prefer). */

    DEFAULT_WIDTH = 1000;
    DEFAULT_HEIGHT = 1000;

    constructor(size) {
        size = size? size.copy(): new Point(
            this.DEFAULT_WIDTH,
            this.DEFAULT_HEIGHT,
        );

        this.stars = [];
        this.ships = [];
        this.shots = [];
        this.effects = [];
        this.rocks = [];
        this.size = size;

        /* Create a canvas for rendering this Field.
        This canvas is never attached to a parent element, we only
        use it for drawing, then copy its image onto another canvas. */
        this.innerCanvas = document.createElement('canvas');
        this.innerCanvas.width = size.x;
        this.innerCanvas.height = size.y;

        /* Add some random stars */
        var n_stars = size.x * size.y / 3000;
        var star_vel_rot = Random.randRotation();
        for(var i = 0; i < n_stars; i++) {
            var star = new Star(this);
            this.stars.push(star);

            star.pos.setRandomWithin(this.size);

            /* Each star has a random "distance", as in, how far away it
            is.
            Distance is a number between 0 and 1, with higher numbers
            meaning "further away".
            Stars which are "further away" are darker and move slower,
            to give a bit of parallax-ish effect. */
            var distance = Random.randNumber(0.25, 0.75);
            var color_component = Math.floor(255 * distance);
            star.trailStrokeStyle = 'rgb('
                + color_component + ','
                + color_component + ','
                + color_component + ')';
            var star_speed = 2 * distance;
            star.vel.setSpeed(star_speed, star_vel_rot);
            star.distance = distance;
        }

        /* Sort this.stars by "distance" so that when we iterate over
        it in render(), more distant stars are rendered first, and
        therefore "painted over" by closer stars. */
        this.stars.sort((s1, s2) => Math.sign(s2.distance - s1.distance));

        var n_rocks = size.x * size.y / 100000;
        for(var i = 0; i < n_rocks; i++) {
            var rock = this.addRock();
        }
    }
    addShip(cls) {
        cls = cls || Ship;
        var entity = new cls(this);
        this.ships.push(entity);
        return entity;
    }
    addShot(cls) {
        cls = cls || Shot;
        var entity = new cls(this);
        this.shots.push(entity);
        return entity;
    }
    addEffect(cls) {
        cls = cls || Effect;
        var entity = new cls(this);
        this.effects.push(entity);
        return entity;
    }
    addRock(cls) {
        cls = cls || Rock;
        var entity = new cls(this);
        this.rocks.push(entity);
        return entity;
    }
    step() {
        for(var star of this.stars) star.step();
        for(var entity of this.ships) entity.step();
        for(var entity of this.shots) entity.step();
        for(var entity of this.effects) entity.step();
        for(var entity of this.rocks) entity.step();

        for(var shot of this.shots) {
            for(var ship of this.ships) {
                if(shot.colliding(ship)) {
                    shot.hit(ship);
                }
            }
            for(var rock of this.rocks) {
                if(shot.colliding(rock)) {
                    shot.hit(rock);
                }
            }
        }

        for(var rock of this.rocks) {
            for(var other of this.rocks) {
                if(rock === other) continue;
                if(rock.colliding(other)) {
                    rock.handleCollision(other);
                }
            }
            for(var ship of this.ships) {
                if(rock.colliding(ship)) {
                    rock.handleCollision(ship);
                }
            }
        }

        this.removeEntities(this.ships);
        this.removeEntities(this.shots);
        this.removeEntities(this.effects);
        this.removeEntities(this.rocks);
    }
    removeEntities(entities) {
        for(var i = 0; i < entities.length; i++) {
            var entity = entities[i];
            if(entity.pleaseRemove) {
                entities.splice(i, 1);
                i--;
            }
            /* TODO: figure out what to do about other possible references
            to entity, e.g. camera.target */
        }
    }
    innerRender(camera) {
        var canvas = this.innerCanvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        /* Draw a box around the field */
        var w = this.size.x;
        var h = this.size.y;
        ctx.strokeStyle = '#800';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, 0);
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        ctx.stroke();

        for(var star of this.stars) star.render(canvas, camera);
        for(var entity of this.ships) entity.render(canvas, camera);
        for(var entity of this.shots) entity.render(canvas, camera);
        for(var entity of this.effects) entity.render(canvas, camera);
        for(var entity of this.rocks) entity.render(canvas, camera);
    }
    render(canvas, camera) {
        this.innerRender(camera);
        var innerCanvas = this.innerCanvas;

        var ctx = canvas.getContext('2d');
        var x0 = canvas.width  / 2 - camera.pos.x;
        var y0 = canvas.height / 2 - camera.pos.y;

        x0 = modulo(x0, innerCanvas.width);
        if(x0 > 0) x0 -= innerCanvas.width;
        y0 = modulo(y0, innerCanvas.height);
        if(y0 > 0) y0 -= innerCanvas.height;

        for(var x = x0; x < canvas.width; x += innerCanvas.width) {
            for(var y = y0; y < canvas.height; y += innerCanvas.height) {
                ctx.drawImage(this.innerCanvas, x, y);
            }
        }
    }
}

class Particle {
    /* Represents a thing with position and velocity.
    It lives on a Field. */

    constructor(field) {
        this.field = field;
        this.pos = new Point();
        this.vel = new Point();
    }
    step() {
        this.pos.addMul(this.vel, VELMUL).modulo(this.field.size);
    }
}

class Shape {
    /* Specifies a polygon to draw on a canvas.
    Each Picture can have multiple Shapes. */

    stroke = true;
    fill = true;
    close = true;

    constructor(points, props) {
        this.points = points || [];
        if(props) Object.assign(this, props);
    }
}

class Picture {
    radiusmul = 1;

    constructor(shapes, props) {
        this.shapes = shapes || [];
        if(props) Object.assign(this, props);
    }
    render(entity, canvas, camera, addx, addy) {
        var x0 = entity.pos.x + addx;
        var y0 = entity.pos.y + addy;
        var rot = entity.rot;
        var radius = entity.radius * this.radiusmul;

        // Point used for calculations
        var p = new Point();

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = entity.circleStrokeStyle;
        ctx.lineWidth = entity.circleLineWidth;
        ctx.fillStyle = entity.circleFillStyle;

        for(var shape of this.shapes) {
            var firstPoint = true;
            ctx.beginPath();
            for(var point of shape.points) {
                p.copy(point).mul(radius).rotate(rot).addxy(x0, y0);
                if(firstPoint) {
                    ctx.moveTo(p.x, p.y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            if(shape.close) ctx.closePath();
            if(shape.stroke) ctx.stroke();
            if(shape.fill) ctx.fill();
        }

    }
}

class Sprite extends Particle {
    /* Represents a Particle which can be drawn onto a <canvas>. */

    radius = 10 * RADIUSMUL;

    shouldRenderCircle = false;
    circleStrokeStyle = 'rgb(0,200,0)';
    circleFillStyle   = 'rgba(255,255,255,.15)';
    circleLineWidth = 2;

    shouldRenderTrail = false;
    trailStart = 0;
    trailEnd   = 1;
    trailCamVel = 0;
    trailStrokeStyle = 'rgba(255,150,0,25)';
    trailLineWidth = 2;

    picture = null; /* instanceof Picture */

    render(canvas, camera) {
        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var addx0 = this.pos.x < fieldx / 2? 0: -fieldx;
        var addy0 = this.pos.y < fieldy / 2? 0: -fieldy;

        for(var addx = addx0; addx <= addx0 + fieldx; addx += fieldx) {
            for(var addy = addy0; addy <= addy0 + fieldy; addy += fieldy) {
                if(this.shouldRenderTrail) this.renderTrail(
                    canvas, camera, addx, addy);
                if(this.shouldRenderCircle) this.renderCircle(
                    canvas, camera, addx, addy);
                if(this.picture) this.picture.render(
                    this, canvas, camera, addx, addy);
            }
        }
    }
    renderTrail(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var x1 = x0 - this.vel.x - camera.vel.x * this.trailCamVel;
        var y1 = y0 - this.vel.y - camera.vel.y * this.trailCamVel;
        var trail_x0 = linear(x0, x1, this.trailStart);
        var trail_y0 = linear(y0, y1, this.trailStart);
        var trail_x1 = linear(x0, x1, this.trailEnd);
        var trail_y1 = linear(y0, y1, this.trailEnd);

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.trailStrokeStyle;
        ctx.lineWidth = this.trailLineWidth;
        ctx.beginPath();
        ctx.moveTo(trail_x0, trail_y0);
        ctx.lineTo(trail_x1, trail_y1);
        ctx.stroke();
    }
    renderCircle(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.fillStyle = this.circleFillStyle;
        ctx.beginPath();
        ctx.arc(x0, y0, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fill();
    }
}

class Star extends Sprite {
    shouldRenderTrail = true;
    trailLineWidth = 1;
    trailCamVel = 1;
}

class Key {
    /* Represents the state of a key on the keyboard */

    static KEYNAMES = 'udlrxy';

    constructor() {
        this.isDown = false;
        this.wasDown = false;
    }
    static createKeys() {
        var keys = {};
        for(var keyname of this.KEYNAMES) {
            keys[keyname] = new this();
        }
        return keys;
    }
    copy(other) {
        this.isDown = other.isDown;
        this.wasDown = other.wasDown;
    }
    down() {
        this.isDown = this.wasDown = true;
    }
    up() {
        this.isDown = false;
    }
    step() {
        this.wasDown = this.isDown;
    }
}

class Entity extends Sprite {
    /* An Entity is a sprite with "volition" -- it has virtual keys which
    can be pressed, and based on their state, it can move itself. */

    thrustSpeed = 2;
    reverseSpeed = .75;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .5;
    maxAge = -1;

    SHOT_KEYNAMES = 'xy';
    shotClass = {
        x: Shot,
        y: null,
    };

    thrustEffectClass = ThrustEffect;
    thrustEffectSpeedMul = 2;
    thrustEffectEvery = 3;
    thrustEffectCooldown = 0;

    constructor(field) {
        super(field);

        this.rot = 0;
        this.rot_vel = 0;

        this.shotprops = {};
        for(var keyname of this.SHOT_KEYNAMES) {
            this.shotprops[keyname] = {
                cooldown: 0,
                n_shots: 0,
            };
        };

        this.keys = Key.createKeys();

        this.age = 0;
        this.pleaseRemove = false;
    }
    step() {
        this.vel.mul(this.velmul);
        this.rot_vel *= this.rotmul;

        for(var keyname of this.SHOT_KEYNAMES) {
            var shotprops = this.shotprops[keyname];
            if(shotprops.cooldown > 0) shotprops.cooldown--;
        }
        if(this.thrustEffectCooldown > 0) this.thrustEffectCooldown--;

        this.handleKeys();
        for(var keyname of Key.KEYNAMES) {
            this.keys[keyname].step();
        }

        super.step();
        this.rot += this.rot_vel * ROTVELMUL;

        this.age++;
        if(this.maxAge >= 0 && this.age >= this.maxAge) {
            this.pleaseRemove = true;
        }
    }
    handleKeys() {
        if(this.keys.u.wasDown) {
            this.thrust(this.thrustSpeed, this.rot);
        }
        if(this.keys.d.wasDown) {
            this.thrust(this.reverseSpeed, this.rot + Math.PI);
        }
        if(this.keys.l.wasDown) {
            this.rot_vel += this.rotspeed;
        }
        if(this.keys.r.wasDown) {
            this.rot_vel -= this.rotspeed;
        }
        for(var keyname of this.SHOT_KEYNAMES) {
            var shotprops = this.shotprops[keyname];
            if(this.keys[keyname].wasDown && shotprops.cooldown === 0) {
                this.fire(keyname);
            }
        }
    }
    thrust(speed, rot) {
        this.vel.addSpeed(this.thrustSpeed, rot);
        if(this.thrustEffectCooldown === 0) {
            this.addThrustEffect(
                speed * this.thrustEffectSpeedMul,
                rot + Math.PI);
            this.thrustEffectCooldown += this.thrustEffectEvery;
        }
    }
    addThrustEffect(speed, rot) {
        var effect = this.field.addEffect(this.thrustEffectClass);
        effect.pos.copy(this.pos).addSpeed(this.radius, rot);
        effect.vel.copy(this.vel).addSpeed(speed, rot);
        effect.rot = rot;
    }
    fire(keyname) {
        var shotprops = this.shotprops[keyname];
        var cls = this.shotClass[keyname];
        if(!cls) return;

        var serial_i = shotprops.n_shots % cls.serialShots;
        for(var i = 0; i < cls.initialShots; i++) {
            var shot = this.shoot(cls, i, serial_i);
        }

        shotprops.cooldown += cls.cooldown;
        shotprops.n_shots++;
    }
    shoot(cls, shot_i, serial_shot_i) {
        // shot_i: index of this shot. E.g. if 3 are being fired at once,
        // this one might be 0, 1, or 2.

        var shot = this.field.addShot(cls);
        shot.ship = this;

        var rot = this.rot;
        if(cls.initialShots > 1) {
            // rotVariance: number between -.5 and .5
            var rotVariance = shot_i / (cls.initialShots - 1) - .5;
            rot += rotVariance * cls.initialRotVariance;
        }
        if(cls.serialShots > 1) {
            // rotVariance: number between -.5 and .5
            var rotVariance = serial_shot_i / (cls.serialShots - 1) - .5;
            rot += rotVariance * cls.serialRotVariance;
        }

        shot.pos.copy(this.pos)
            .addSpeed(cls.initialSpeed, rot);
        shot.vel.copy(this.vel)
            .mul(cls.initialVelMul)
            .addSpeed(cls.initialSpeed, rot);
        return shot;
    }
    colliding(other) {
        var d = this.pos.dist(other.pos, this.field.size);
        return d < this.radius + other.radius;
    }
    handleCollision(other) {
        /* We collided with another Entity!
        We are both pushed away, and take on some of each others
        velocity. */

        /* Store the two entities' velocities before we make any
        changes to them. */
        var vx0 = this.vel.x;
        var vy0 = this.vel.y;
        var vx1 = other.vel.x;
        var vy1 = other.vel.y;

        /* r0: number between 0 and 1.
        The closer it is to 1, the larger this.radius is than other.radius.
        If .5, they are equal. */
        var r0 = this.radius / (this.radius + other.radius);
        var r1 = 1 - r0;

        /* Distance between this and other */
        var dist = this.pos.dist(other.pos, this.field.size);

        /* Target distance: this and other are just barely touching */
        var tdist = this.radius + other.radius;

        /* dx, dy: shortest vector from this to other, on the torus
        represented by this.field.size */
        var dx = other.pos.x - this.pos.x;
        var dy = other.pos.y - this.pos.y;
        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        if(dx < -fieldx / 2) dx += fieldx;
        if(dx >  fieldx / 2) dx -= fieldx;
        if(dy < -fieldy / 2) dy += fieldy;
        if(dy >  fieldy / 2) dy -= fieldy;

        /* mx, my: vector which would move this away from other, to where
        they are just barely touching */
        var mx = dx / dist * (dist - tdist);
        var my = dy / dist * (dist - tdist);

        var posmul = .25;
        this.pos.x  += mx * r1 * posmul;
        this.pos.y  += my * r1 * posmul;
        other.pos.x -= mx * r0 * posmul;
        other.pos.y -= my * r0 * posmul;

        var velmul = .35;
        this.vel.x  += mx * r1 * velmul;
        this.vel.y  += my * r1 * velmul;
        other.vel.x -= mx * r0 * velmul;
        other.vel.y -= my * r0 * velmul;
    }
    render(canvas, camera) {
        var fade = 1;
        if(this.maxAge >= 0) {
            // maxFade: don't set fade lower than 1 - maxFade, that
            // would be too close to 0, so we wouldn't be able to see
            // the Entity
            var maxFade = .85;
            fade = 1 - (this.age / this.maxAge) * maxFade;
        }

        var ctx = canvas.getContext('2d');
        ctx.globalAlpha = fade;
        super.render(canvas, camera);
        ctx.globalAlpha = 1;
    }
    renderCircle(canvas, camera, addx, addy) {
        super.renderCircle(canvas, camera, addx, addy);

        /* Render a little line indicating this.rot */
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var p = new Point(this.radius).rotate(this.rot);
        var x1 = x0 + p.x;
        var y1 = y0 + p.y;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
    }
}

class Camera extends Particle {
    velmul = .7;
    springmul = .1;

    constructor(field) {
        super(field);
        this.target = null;
    }
    setTarget(target) {
        this.target = target;
    }
    step() {
        this.vel.mul(this.velmul);

        if(this.target) {
            var x0 = this.pos.x;
            var y0 = this.pos.y;
            var x1 = this.target.pos.x;
            var y1 = this.target.pos.y;
            this.vel.x += moduloDiff(x0, x1, this.field.size.x)
                * this.springmul;
            this.vel.y += moduloDiff(y0, y1, this.field.size.y)
                * this.springmul;
        }

        super.step();
    }
}

class Player {
    constructor(entity) {
        this.entity = entity;
        this.keys = Key.createKeys();
    }
    step() {
        for(var keyname of Key.KEYNAMES) {
            var key = this.keys[keyname];
            this.entity.keys[keyname].copy(key);
            key.step();
        }
    }
}

class Game {
    constructor(canvas, fieldSize) {
        this.canvas = canvas;
        this.field = new Field(fieldSize);
        this.camera = new Camera(this.field);
        this.players = [];
        this.intervalId = 0;

        canvas.addEventListener('keydown', this.onKeyDown.bind(this));
        canvas.addEventListener('keyup', this.onKeyUp.bind(this));

        /* Hashmap from keyCode values to Key instances belonging to
        Player instances in this.players */
        this.keysByCode = {};
    }
    onKeyDown(event) {
        this.keyDown(event.keyCode);
        event.preventDefault();
    }
    onKeyUp(event) {
        this.keyUp(event.keyCode);
        event.preventDefault();
    }
    mapKey(key, keyCode) {
        this.keysByCode[keyCode] = key;
    }
    keyDown(keyCode) {
        var key = this.keysByCode[keyCode];
        if(key) key.down();
    }
    keyUp(keyCode) {
        var key = this.keysByCode[keyCode];
        if(key) key.up();
    }
    addShip(cls) {
        return this.field.addShip(cls);
    }
    addPlayer(entity) {
        var player = new Player(entity);
        this.players.push(player);
        return player;
    }
    step() {
        for(var player of this.players) player.step();
        this.field.step();
        this.camera.step();
    }
    render() {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.field.render(canvas, this.camera);
    }
    intervalCallback() {
        /* Callback for use with setInterval */
        if(TIMING) var t0 = new Date();
        try {
            this.step();
            this.render();
        } catch(ex) {
            // Stop the same error from throwing repeatedly.
            // Don't set this.intervalId to 0 though, for debugging
            // purposes.
            clearInterval(this.intervalId);

            throw ex;
        }
        if(TIMING) {
            var t1 = new Date();
            console.log('TIMING: ' + String(t1 - t0));
        }
    }
    play(millis) {
        millis = millis || 30;
        if(this.intervalId) clearInterval(this.intervalId);
        var callback = this.intervalCallback.bind(this);
        this.intervalId = setInterval(callback, millis);
    }
    pause() {
        if(!this.intervalId) return;
        clearInterval(this.intervalId);
        this.intervalId = 0;
    }
}

class Effect extends Entity {
}

class ThrustEffect extends Effect {
    shouldRenderTrail = true;
    trailStart = .7;
    trailStrokeStyle = 'rgba(0,255,255,.5)';
    trailLineWidth = 3;
    maxAge = 20;
}

class SparkEffect extends Entity {
    shouldRenderTrail = true;
    trailStart = .7;
    trailStrokeStyle = 'rgba(255,255,0,.5)';
    velmul = .95;
    maxAge = 20;
}

class Ship extends Entity {
}

class FighterShip extends Ship {
    radius = 6 * RADIUSMUL;
    picture = new Picture([
        new Shape([
            new Point(-1.2,  .95),
            new Point( 1  ,    0),
            new Point(-1.2, -.95),
        ], {stroke: false}),
        new Shape([
            new Point(-1.2,  .95),
            new Point( 1  ,    0),
            new Point(-1.2, -.95),
        ], {fill: false, close: false}),
    ], {radiusmul: 1.2});
}

class Shot extends Entity {

    static initialSpeed = 20;
    static initialVelMul = 1;
    static initialShots = 1;
    static serialShots = 2;
    // "rot variance": difference in radians between the rot of first
    // and last Shot instance produced by firing this Shot type
    static initialRotVariance = 0;
    static serialRotVariance = Math.PI / 18;
    static cooldown = 4;

    maxAge = 40;
    velmul = .95;
    radius = .25 * RADIUSMUL;
    shouldRenderTrail = true;

    // How hard we move things we hit
    hitVelMul = .1;

    constructor(field) {
        super(field);

        // The Ship who shot us out
        this.ship = null;
    }
    hit(other) {
        if(other === this.ship) return;
        other.vel.addMul(this.vel, this.hitVelMul);

        for(var i = 0; i < 2; i++) {
            var spark = this.field.addEffect(SparkEffect);
            spark.pos.copy(this.pos);
            var speed = Random.randNumber(2, 4);
            spark.vel.copy(this.vel).mul(.75)
                .addSpeed(speed, Random.randRotation());
        }

        this.pleaseRemove = true;
    }
}

class Rock extends Entity {

    circleStrokeStyle = '#987';
    velmul = 1;
    rotmul = 1;

    constructor(field) {
        super(field);

        var points = [];
        var n_points = Random.randIntInclusive(5, 10);
        for(var i = 0; i < n_points; i++) {
            var point_rot = (Math.PI * 2)
                * (i + Random.randNumber(-.25, .25)) / n_points;
            var point = new Point(Random.randNumber(1, 1.1))
                .rotate(point_rot);
            points.push(point);
        }
        this.picture = new Picture([new Shape(points)]);

        this.pos.setRandomWithin(field.size);
        this.radius = Random.randNumber(7, 25) * RADIUSMUL;

        var speed = Random.randNumber(3.5);
        this.vel.setSpeed(speed, Random.randRotation());

        var MAX_ROT_VEL = Math.PI / 20;
        this.rot_vel = Random.randNumber(-MAX_ROT_VEL, MAX_ROT_VEL);
    }
}


var canvas = document.getElementById('canvas');
var game = new Game(canvas);

var KEY_U = 38;
var KEY_D = 40;
var KEY_L = 37;
var KEY_R = 39;
var KEY_SPACE = 32;

var ship = game.addShip(FighterShip);
ship.pos.setMidpoint(game.field.size);
game.camera.setTarget(ship);
var player = game.addPlayer(ship);
game.mapKey(player.keys.u, KEY_U);
game.mapKey(player.keys.d, KEY_D);
game.mapKey(player.keys.l, KEY_L);
game.mapKey(player.keys.r, KEY_R);
game.mapKey(player.keys.x, KEY_SPACE);

game.play();
canvas.style.border = 'none';
canvas.focus();


</script>
</body>
</html>