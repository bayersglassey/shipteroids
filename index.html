<html>
<head>
<title>Shipteroids!</title>
<style>
body {
    color: #fff;
    background-color: #000;
}
.canvas {
    border: solid 1px #0f0;
    display: inline;
}
.canvas-container {
    width: 100%;
    text-align: center;
}
</style>
</head>
<body>
<div class="canvas-container">
    <canvas id="canvas" class="canvas" width=600 height=600 tabindex=-1></canvas>
</div>
<script>

'use strict';


// debug stuff
var TIMING = false;
var RENDER_CIRCLES = false;
var RENDER_BOUNDARY = false;

// physics tweaking stuff
var VELMUL = .7;
var ROTVELMUL = .7;
var RADIUSMUL = 2;
var DAMAGEMUL = 1.5;

// keyCode values
var KEY_U = 38;
var KEY_D = 40;
var KEY_L = 37;
var KEY_R = 39;
var KEY_ENTER = 13;
var KEY_SPACE = 32;
var KEY_SECONDARY = 90; // 'z'
var KEY_ESCAPE = 27;


function linear(x0, x1, n) {
    /* Assumes: 0 <= n <= 1 */
    return x0 + (x1 - x0) * n;
}

function modulo(x, n) {
    /* Returns the modulus of x / n.
    Expects n > 0.

    Example:

         x | n | modulo(x, n)
        ---+---+--------------
         -3| 3 | 0
         -2| 3 | 1
         -1| 3 | 2
          0| 3 | 0
          1| 3 | 1
          2| 3 | 2
          3| 3 | 0
    */
    return ((x % n) + n) % n;
}

function getRotVariance(i, n) {
    // rotVariance: number between -.5 and .5
    if(n <= 1) return 0;
    return i / (n - 1) - .5;
}

function moduloDiff(x0, x1, w) {
    /* Difference between two numbers on the "wrapped" interval between
    0 and w.
    (Distance from x0 to x1.) */
    x0 = modulo(x0, w);
    x1 = modulo(x1, w);
    var diff = x1 - x0;

    if(diff < -w/2)return diff + w;
    else if(diff > w/2)return diff - w;
    else return diff;
}

class Random {
    /* Utility functions for producing random values */

    static randNumber(a, b) {
        if(b === undefined) {
            b = a;
            a = 0;
        }
        return a + Math.random() * (b - a);
    }
    static randInt(a, b) {
        return Math.floor(this.randNumber(a, b));
    }
    static randIntInclusive(a, b) {
        return this.randInt(a, b + 1);
    }
    static choice(choices) {
        return choices[this.randInt(choices.length)];
    }
    static randRotation() {
        return this.randNumber(Math.PI * 2);
    }
}

class Point {
    /* A 2-dimensional point.
    Can also be used to represent the width+height of a rectangle,
    and/or represent the rectangle between (0,0) and (this.x,this.y). */

    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    clone() {
        return new Point(this.x, this.y);
    }
    set(x, y) {
        this.x = x || 0;
        this.y = y || 0;
        return this;
    }
    dist(other, modulo) {
        var x0 = this.x;
        var y0 = this.y;
        var x1 = other? other.x: 0;
        var y1 = other? other.y: 0;

        var dx = Math.abs(x1 - x0);
        var dy = Math.abs(y1 - y0);
        if(modulo) {
            // If modulo is provided, it should be a Point representing
            // a rectangle representing a torus within which this and other
            // are contained.
            if(dx > modulo.x / 2) dx = modulo.x - dx;
            if(dy > modulo.y / 2) dy = modulo.y - dy;
        }
        return Math.sqrt(dx * dx + dy * dy);
    }
    angle() {
        return Math.atan2(-this.y, this.x);
    }
    copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }
    setMidpoint(other) {
        /* Sets this to the midpoint of the a rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = other.x / 2;
        this.y = other.y / 2;
        return this;
    }
    setRandomWithin(other) {
        /* Sets this to a random point within the rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = Random.randNumber(other.x);
        this.y = Random.randNumber(other.y);
        return this;
    }
    addxy(x, y) {
        this.x += x;
        this.y += y;
        return this;
    }
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    addMul(other, mul) {
        this.x += other.x * mul;
        this.y += other.y * mul;
        return this;
    }
    mul(n) {
        this.x *= n;
        this.y *= n;
        return this;
    }
    modulo(other) {
        /* Returns this Point modulo the rectangle between (0,0) and
        (other.x, other.y).
        You can think of this as constraining this Point within the
        torus defined by the rectangle defined by other.
        If you're into that kind of thing. O_o */
        this.x = modulo(this.x, other.x);
        this.y = modulo(this.y, other.y);
        return this;
    }
    rotate(rot) {
        /*
            for(var i = 0; i < 4; i++) {
                var p = new Point(1).rotate(Math.PI * i / 2); 
                console.log(p);
            }
            // {x:  1, y:  0}
            // {x:  0, y: -1}
            // {x: -1, y:  0}
            // {x:  0, y:  1}
        */
        var sin = Math.sin(rot);
        var cos = Math.cos(rot);
        var x =  this.x;
        var y = -this.y;
        this.x =  (x * cos - y * sin);
        this.y = -(x * sin + y * cos);
        return this;
    }
    setSpeed(speed, rot) {
        return this.set(speed).rotate(rot);
    }
    addSpeed(speed, rot) {
        var x = this.x;
        var y = this.y;
        this.setSpeed(speed, rot);
        this.x += x;
        this.y += y;
        return this;
    }
}


class Field {
    /* Think of "field" in the sense of "playing field".
    It's basically a rectangle within which sprites can fly around.
    The edges of the rectangle "wrap around" (or you can say it's a
    "torus" if you prefer). */

    DEFAULT_WIDTH = 1000;
    DEFAULT_HEIGHT = 1000;

    constructor(game, size) {
        size = size? size.clone(): new Point(
            this.DEFAULT_WIDTH,
            this.DEFAULT_HEIGHT,
        );

        this.game = game;
        this.size = size;

        this.stars = [];

        this.entityArrays = [];
        this.ships = this.addEntityArray();
        this.shots = this.addEntityArray();
        this.effects = this.addEntityArray();
        this.rocks = this.addEntityArray();

        /* Create a canvas for rendering this Field.
        This canvas is never attached to a parent element, we only
        use it for drawing, then copy its image onto another canvas. */
        this.innerCanvas = document.createElement('canvas');
        this.innerCanvas.width = size.x;
        this.innerCanvas.height = size.y;

        /* Add some random stars */
        var n_stars = size.x * size.y / 3000;
        var star_vel_rot = Random.randRotation();
        for(var i = 0; i < n_stars; i++) {
            var star = new Star(this);
            this.stars.push(star);

            star.pos.setRandomWithin(this.size);

            /* Each star has a random "distance", as in, how far away it
            is.
            Distance is a number between 0 and 1, with higher numbers
            meaning "further away".
            Stars which are "further away" are darker and move slower,
            to give a bit of parallax-ish effect. */
            var distance = Random.randNumber(0.25, 0.75);
            var color_component = Math.floor(255 * distance);
            star.trailStrokeStyle = 'rgb('
                + color_component + ','
                + color_component + ','
                + color_component + ')';
            var star_speed = 2 * distance;
            star.vel.setSpeed(star_speed, star_vel_rot);
            star.distance = distance;
        }

        /* Sort this.stars by "distance" so that when we iterate over
        it in render(), more distant stars are rendered first, and
        therefore "painted over" by closer stars. */
        this.stars.sort((s1, s2) => Math.sign(s2.distance - s1.distance));

        var n_rocks = size.x * size.y / 100000;
        for(var i = 0; i < n_rocks; i++) {
            var rock = this.addRock(Rock);
        }
    }
    addEntityArray() {
        // Create an Array used to store Entity instances
        // (E.g. Game.ships, Game.rocks, etc)
        var entityArray = [];

        // Add a pending Array of things to be added to the Array at the
        // start of next Field.step
        entityArray.pending = [];

        this.entityArrays.push(entityArray);
        return entityArray;
    }
    cleanup() {
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.cleanup();
        }
    }
    addShip(cls) {
        var entity = new cls(this);
        this.ships.pending.push(entity);
        return entity;
    }
    addShot(cls) {
        var entity = new cls(this);
        this.shots.pending.push(entity);
        return entity;
    }
    addEffect(cls) {
        var entity = new cls(this);
        this.effects.pending.push(entity);
        return entity;
    }
    addRock(cls, radius) {
        radius = radius || Random.randNumber(7, 25) * RADIUSMUL;
        var entity = new cls(this, radius);
        this.rocks.pending.push(entity);
        return entity;
    }
    addPendingEntities(entityArray) {
        for(var entity of entityArray.pending) entityArray.push(entity);
        entityArray.pending.length = 0;
    }
    step() {
        for(var entityArray of this.entityArrays) {
            this.addPendingEntities(entityArray);
        }

        for(var star of this.stars) star.step();
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.step();
        }

        for(var shot of this.shots) {
            for(var ship of this.ships) {
                if(ship === shot.ship) continue;

                // Bit of a hack, making sure turrets can't damage
                // their FlagShip.
                // TODO: handle this with teams?..
                if(shot.ship === ship.turret) continue;

                if(shot.colliding(ship)) shot.hit(ship);
            }
            for(var rock of this.rocks) {
                if(shot.colliding(rock)) shot.hit(rock);
            }
        }

        for(var rock of this.rocks) {
            for(var other of this.rocks) {
                if(rock === other) continue;
                if(rock.colliding(other)) {
                    rock.handleCollision(other);
                }
            }
            for(var ship of this.ships) {
                if(rock.colliding(ship)) {
                    rock.handleCollision(ship);
                }
            }
        }

        for(var ship of this.ships) {
            for(var other of this.ships) {
                if(ship === other) continue;
                if(ship.colliding(other)) {
                    ship.handleCollision(other);
                }
            }
        }

        for(var entityArray of this.entityArrays) {
            this.removeEntities(entityArray);
        }
    }
    removeEntities(entityArray) {
        for(var i = 0; i < entityArray.length; i++) {
            var entity = entityArray[i];
            if(entity._shouldRemove) {
                entity.cleanup();
                entityArray.splice(i, 1);
                i--;
            }
        }
    }
    innerRender(camera) {
        var canvas = this.innerCanvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if(RENDER_BOUNDARY) this.renderBoundary(canvas);

        for(var star of this.stars) star.render(canvas, camera);
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.render(canvas, camera);
        }
    }
    renderBoundary(canvas) {
        /* Draw a box around the field */
        var ctx = canvas.getContext('2d');
        var w = this.size.x;
        var h = this.size.y;
        ctx.strokeStyle = '#800';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, 0);
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        ctx.stroke();
    }
    render(canvas, camera) {
        this.innerRender(camera);
        var innerCanvas = this.innerCanvas;

        var ctx = canvas.getContext('2d');
        var x0 = canvas.width  / 2 - camera.pos.x;
        var y0 = canvas.height / 2 - camera.pos.y;

        x0 = modulo(x0, innerCanvas.width);
        if(x0 > 0) x0 -= innerCanvas.width;
        y0 = modulo(y0, innerCanvas.height);
        if(y0 > 0) y0 -= innerCanvas.height;

        for(var x = x0; x < canvas.width; x += innerCanvas.width) {
            for(var y = y0; y < canvas.height; y += innerCanvas.height) {
                ctx.drawImage(this.innerCanvas, x, y);
            }
        }
    }
}

class Particle {
    /* Represents a thing with position and velocity.
    It lives on a Field. */

    maxvel = 100;

    constructor(field) {
        this.field = field;
        this.pos = new Point();
        this.vel = new Point();
    }
    step() {
        // Make sure velocity stays within this.maxvel
        var veldist = this.vel.dist();
        if(veldist > this.maxvel) this.vel.mul(this.maxvel / veldist);

        this.pos.addMul(this.vel, VELMUL).modulo(this.field.size);
    }
}

class Shape {
    /* Specifies a polygon to draw on a canvas.
    Each Picture can have multiple Shapes. */

    stroke = true;
    fill = true;
    close = true;

    constructor(points, props) {
        this.points = points || [];
        if(props) Object.assign(this, props);
    }
    static newPolygon(n_points, opts, props) {
        opts = opts || {};
        var rotVariance = opts.rotVariance || 0;
        var radiusVariance = opts.radiusVariance || 0;
        var rot = opts.rot || 0;

        var points = [];
        for(var i = 0; i < n_points; i++) {
            var i_varied = i + Random.randNumber(-rotVariance, rotVariance);
            var point_rot = (Math.PI * 2) * i_varied / n_points + rot;
            var radius = 1 + Random.randNumber(-.5, .5) * radiusVariance;
            var point = new Point().addSpeed(radius, point_rot);
            points.push(point);
        }
        return new this(points, props);
    }
}

class Picture {
    radiusmul = 1;

    constructor(shapes, props) {
        this.shapes = shapes || [];
        if(props) Object.assign(this, props);
    }
    static newPolygon(n_points, opts, props) {
        var shape = Shape.newPolygon(n_points, opts);
        return new this([shape], props);
    }
    render(entity, canvas, camera, addx, addy) {
        var x0 = entity.pos.x + addx;
        var y0 = entity.pos.y + addy;
        var rot = entity.rot;
        var radius = entity.radius * this.radiusmul;

        // Point used for calculations
        var p = new Point();

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = entity.circleStrokeStyle;
        ctx.lineWidth = entity.circleLineWidth;
        ctx.fillStyle = entity.circleFillStyle;

        for(var shape of this.shapes) {
            var firstPoint = true;
            ctx.beginPath();
            for(var point of shape.points) {
                p.copy(point).mul(radius).rotate(rot).addxy(x0, y0);
                if(firstPoint) {
                    ctx.moveTo(p.x, p.y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            if(shape.close) ctx.closePath();
            if(shape.stroke) ctx.stroke();
            if(shape.fill) ctx.fill();
        }

    }
}

class Sprite extends Particle {
    /* Represents a Particle which can be drawn onto a <canvas>. */

    radius = 10 * RADIUSMUL;

    shouldRenderCircle = false;
    shouldRenderCircleLine = true;
    circleStrokeStyle = 'rgb(0,200,0)';
    circleFillStyle   = 'rgba(255,255,255,.15)';
    circleLineWidth = 2;

    shouldRenderTrail = false;
    trailStart = 0;
    trailEnd   = 1;
    trailCamVel = 0;
    trailStrokeStyle = 'rgba(255,150,0,25)';
    trailLineWidth = 2;

    picture = null; /* instanceof Picture */

    render(canvas, camera) {
        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var addx0 = this.pos.x < fieldx / 2? 0: -fieldx;
        var addy0 = this.pos.y < fieldy / 2? 0: -fieldy;

        for(var addx = addx0; addx <= addx0 + fieldx; addx += fieldx) {
            for(var addy = addy0; addy <= addy0 + fieldy; addy += fieldy) {
                if(this.shouldRenderTrail) {
                    this.renderTrail(canvas, camera, addx, addy);
                }
                if(this.shouldRenderCircle || RENDER_CIRCLES) {
                    this.renderCircle(canvas, camera, addx, addy);
                }
                if(this.picture) {
                    this.renderPicture(canvas, camera, addx, addy);
                }
            }
        }
    }
    renderPicture(canvas, camera, addx, addy) {
        this.picture.render(this, canvas, camera, addx, addy);
    }
    renderTrail(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var x1 = x0 - this.vel.x - camera.vel.x * this.trailCamVel;
        var y1 = y0 - this.vel.y - camera.vel.y * this.trailCamVel;
        var trail_x0 = linear(x0, x1, this.trailStart);
        var trail_y0 = linear(y0, y1, this.trailStart);
        var trail_x1 = linear(x0, x1, this.trailEnd);
        var trail_y1 = linear(y0, y1, this.trailEnd);

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.trailStrokeStyle;
        ctx.lineWidth = this.trailLineWidth;
        ctx.beginPath();
        ctx.moveTo(trail_x0, trail_y0);
        ctx.lineTo(trail_x1, trail_y1);
        ctx.stroke();
    }
    renderCircle(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.fillStyle = this.circleFillStyle;
        ctx.beginPath();
        ctx.arc(x0, y0, this.radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fill();
    }
}

class Star extends Sprite {
    shouldRenderTrail = true;
    trailLineWidth = 1;
    trailCamVel = 1;
}

class Key {
    /* Represents the state of a key on the keyboard */

    static KEYNAMES = 'udlrxy';

    constructor() {
        this.isDown = false;
        this.wasDown = false;
    }
    static createKeys() {
        var keys = {};
        for(var keyname of this.KEYNAMES) {
            keys[keyname] = new this();
        }
        return keys;
    }
    copy(other) {
        this.isDown = other.isDown;
        this.wasDown = other.wasDown;
    }
    down() {
        this.isDown = this.wasDown = true;
    }
    up() {
        this.isDown = false;
    }
    step() {
        this.wasDown = this.isDown;
    }
}

class Entity extends Sprite {
    /* An Entity is a sprite with "volition" -- it has virtual keys which
    can be pressed, and based on their state, it can move itself. */

    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .5;

    maxAge = -1;
    fadeWithAge = false;

    SHOT_KEYNAMES = 'xy';
    shotClass = {
        x: null,
        y: null,
    };

    thrustEffectClass = ThrustEffect;
    thrustEffectSpeedMul = 2;
    thrustEffectEvery = 3;
    thrustEffectCooldown = 0;

    static maxhp = -1;

    constructor(field) {
        super(field);

        this.hp = this.constructor.maxhp;

        this.rot = 0;
        this.rot_vel = 0;

        this.shotprops = {};
        for(var keyname of this.SHOT_KEYNAMES) {
            this.shotprops[keyname] = {
                cooldown: 0,
                n_shots: 0,
            };
        };

        this.keys = Key.createKeys();

        this.age = 0;
        this._shouldRemove = false;
    }
    damage(hp) {
        if(this.hp < 0) return;
        if((this.hp -= hp) < 0) this.hp = 0;
        if(!this.hp) {
            this.die();
        }
    }
    die() {
        this.remove();
    }
    remove() {
        this._shouldRemove = true;
    }
    cleanup() {
        var game = this.field.game;

        for(var player of game.players) {
            if(player.entity !== this) continue;
            player.unsetEntity();
        }

        var camera = game.camera;
        if(camera.target === this) {
            camera.unsetTarget();
        }
    }
    step() {
        this.vel.mul(this.velmul);
        this.rot_vel *= this.rotmul;

        for(var keyname of this.SHOT_KEYNAMES) {
            var shotprops = this.shotprops[keyname];
            if(shotprops.cooldown > 0) shotprops.cooldown--;
        }
        if(this.thrustEffectCooldown > 0) this.thrustEffectCooldown--;

        this.handleKeys();
        for(var keyname of Key.KEYNAMES) {
            this.keys[keyname].step();
        }

        super.step();
        this.rot += this.rot_vel * ROTVELMUL;

        this.age++;
        if(this.maxAge >= 0 && this.age >= this.maxAge) {
            this.die();
        }
    }
    handleKeys() {
        if(this.keys.u.wasDown) {
            this.thrust(this.thrustSpeed, this.rot);
        }
        if(this.keys.d.wasDown) {
            this.thrust(this.reverseSpeed, this.rot + Math.PI);
        }
        if(this.keys.l.wasDown) {
            this.rot_vel += this.rotspeed;
        }
        if(this.keys.r.wasDown) {
            this.rot_vel -= this.rotspeed;
        }
        for(var keyname of this.SHOT_KEYNAMES) {
            var shotprops = this.shotprops[keyname];
            if(this.keys[keyname].wasDown && shotprops.cooldown === 0) {
                this.fire(keyname);
            }
        }
    }
    thrust(speed, rot) {
        this.vel.addSpeed(speed, rot);
        if(this.thrustEffectCooldown === 0) {
            this.addThrustEffect(
                speed * this.thrustEffectSpeedMul,
                rot + Math.PI);
            this.thrustEffectCooldown += this.thrustEffectEvery;
        }
    }
    addThrustEffect(speed, rot) {
        var effect = this.field.addEffect(this.thrustEffectClass);
        effect.pos.copy(this.pos).addSpeed(this.radius, rot);
        effect.vel.copy(this.vel).addSpeed(speed, rot);
        effect.rot = rot;
    }
    emitEffects(cls, n_effects, opts) {
        var speed_min = opts.speed_min || 0;
        var speed_max = opts.speed_max || 0;
        var velmul = opts.velmul || 0;

        var effects = [];
        for(var i = 0; i < n_effects; i++) {
            var effect = this.field.addEffect(cls);
            effect.rot = this.rot;
            effect.pos.copy(this.pos);
            var speed = Random.randNumber(speed_min, speed_max);
            effect.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, Random.randRotation());
            effects.push(effect);
        }
        return effects;
    }
    emitShots(cls, n_shots, opts) {
        var rot_variance = opts.rot_variance || 0;
        var rand_rot_variance = opts.rand_rot_variance || 0;
        var speed_min = opts.speed_min || 0;
        var speed_max = opts.speed_max || 0;

        var speed = Random.randNumber(speed_min, speed_max);
        var velmul = .8;
        var shots = [];
        for(var i = 0; i < n_shots; i++) {
            var shot = this.field.addShot(cls);
            shot.ship = this.ship;
            shot.pos.copy(this.pos);
            shot.rot = this.rot
                + getRotVariance(i, n_shots) * rot_variance
                + Random.randNumber(-.5, .5) * rand_rot_variance;
            shot.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, shot.rot);
            shot.afterShotBy(this);
            shots.push(shot);
        }
        return shots;
    }
    fire(keyname) {
        var shotprops = this.shotprops[keyname];
        var cls = this.shotClass[keyname];
        if(!cls) return;

        var serial_i = shotprops.n_shots % cls.serialShots;
        for(var i = 0; i < cls.initialShots; i++) {
            var shot = this.shoot(cls, i, serial_i);
            shot.afterShotBy(this);
        }

        shotprops.cooldown += cls.cooldown;
        shotprops.n_shots++;
    }
    shoot(cls, shot_i, serial_shot_i) {
        // shot_i: index of this shot. E.g. if 3 are being fired at once,
        // this one might be 0, 1, or 2.

        var shot = this.field.addShot(cls);
        shot.ship = this;

        shot.rot = this.rot
            + getRotVariance(shot_i, cls.initialShots)
                * cls.initialRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * cls.serialRotVariance
            + Random.randNumber(-.5, .5)
                * cls.randomRotVariance;

        var posrot = 0
            + getRotVariance(shot_i, cls.initialShots)
                * cls.initialPosRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * cls.serialPosRotVariance
            + Random.randNumber(-.5, .5)
                * cls.randomPosRotVariance;

        var speed = cls.initialSpeed
            + Random.randNumber(-.5, 5)
                * cls.randomSpeedVariance;

        shot.pos.copy(this.pos)
            .addSpeed(this.radius, shot.rot + posrot);
        shot.vel.copy(this.vel)
            .mul(cls.initialVelMul)
            .addSpeed(speed, shot.rot);
        return shot;
    }
    colliding(other) {
        var d = this.pos.dist(other.pos, this.field.size);
        return d < this.radius + other.radius;
    }
    handleCollision(other) {
        /* We collided with another Entity!
        We are both pushed away, and take on some of each others
        velocity. */

        /* Store the two entities' velocities before we make any
        changes to them. */
        var vx0 = this.vel.x;
        var vy0 = this.vel.y;
        var vx1 = other.vel.x;
        var vy1 = other.vel.y;

        /* r0: number between 0 and 1.
        The closer it is to 1, the larger this.radius is than other.radius.
        If .5, they are equal. */
        var r0 = this.radius / (this.radius + other.radius);
        var r1 = 1 - r0;

        /* Distance between this and other */
        var dist = this.pos.dist(other.pos, this.field.size);

        /* Avoid div by zero, eh */
        if(dist < .1) dist = .1;

        /* Target distance: this and other are just barely touching */
        var tdist = this.radius + other.radius;

        /* dx, dy: shortest vector from this to other, on the torus
        represented by this.field.size */
        var dx = moduloDiff(this.pos.x, other.pos.x, this.field.size.x);
        var dy = moduloDiff(this.pos.y, other.pos.y, this.field.size.y);

        /* mx, my: vector which would move this away from other, to where
        they are just barely touching */
        var mx = dx / dist * (dist - tdist);
        var my = dy / dist * (dist - tdist);

        var posmul = .25;
        this.pos.x  += mx * r1 * posmul;
        this.pos.y  += my * r1 * posmul;
        other.pos.x -= mx * r0 * posmul;
        other.pos.y -= my * r0 * posmul;

        var velmul = .35;
        this.vel.x  += mx * r1 * velmul;
        this.vel.y  += my * r1 * velmul;
        other.vel.x -= mx * r0 * velmul;
        other.vel.y -= my * r0 * velmul;
    }
    render(canvas, camera) {
        var fade = 1;
        if(this.fadeWithAge && this.maxAge >= 0) {
            // maxFade: don't set fade lower than 1 - maxFade, that
            // would be too close to 0, so we wouldn't be able to see
            // the Entity
            var maxFade = .85;
            fade = 1 - (this.age / this.maxAge) * maxFade;
        }

        var ctx = canvas.getContext('2d');
        ctx.globalAlpha = fade;
        super.render(canvas, camera);
        ctx.globalAlpha = 1;
    }
    renderCircle(canvas, camera, addx, addy) {
        super.renderCircle(canvas, camera, addx, addy);
        if(this.shouldRenderCircleLine) {
            this.renderCircleLine(canvas, camera, addx, addy);
        }
    }
    renderCircleLine(canvas, camera, addx, addy) {
        /* Render a little line indicating this.rot */
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var p = new Point(this.radius).rotate(this.rot);
        var x1 = x0 + p.x;
        var y1 = y0 + p.y;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
    }
}

class Camera extends Particle {
    velmul = .7;
    springmul = .1;

    constructor(field) {
        super(field);
        this.target = null;
        this.pos.setMidpoint(field.size);
    }
    setTarget(target) {
        this.unsetTarget();
        this.target = target;
    }
    unsetTarget() {
        if(!this.target) return;
        this.target = null;
    }
    step() {
        this.vel.mul(this.velmul);

        if(this.target) {
            var x0 = this.pos.x;
            var y0 = this.pos.y;
            var x1 = this.target.pos.x;
            var y1 = this.target.pos.y;
            this.vel.x += moduloDiff(x0, x1, this.field.size.x)
                * this.springmul;
            this.vel.y += moduloDiff(y0, y1, this.field.size.y)
                * this.springmul;
        }

        super.step();
    }
}

class Player {
    constructor() {
        this.entity = null;
        this.keys = Key.createKeys();
    }
    setEntity(entity) {
        this.unsetEntity();
        this.entity = entity;
    }
    unsetEntity() {
        if(!this.entity) return;
        this.entity = null;
    }
    step() {
        if(!this.entity) return;
        for(var keyname of Key.KEYNAMES) {
            var key = this.keys[keyname];
            this.entity.keys[keyname].copy(key);
            key.step();
        }
    }
}

class Game {
    constructor(canvas, fieldSize, n_ships) {
        canvas.addEventListener('keydown', this.onKeyDown.bind(this));
        canvas.addEventListener('keyup', this.onKeyUp.bind(this));

        this.canvas = canvas;
        this.intervalId = 0;
        this.players = [];
        this.menu = null;
        this.shouldRenderControls = true;

        /* Hashmap from keyCode values to Key instances belonging to
        Player instances in this.players */
        this.keysByCode = {};

        this._newGame(fieldSize, n_ships);
    }
    _newGame(fieldSize, n_ships) {
        n_ships = n_ships || 0;

        this.field = new Field(this, fieldSize);
        this.camera = new Camera(this.field);
        this.n_ships = n_ships;

        for(var i = 0; i < n_ships; i++) {
            var cls = Random.choice(SHIP_CLASSES);
            var ship = this.addShip(cls);
            ship.pos.setRandomWithin(this.field.size);
            ship.rot = Random.randRotation();
        }
    }
    newGame(fieldSize, n_ships) {
        this.cleanup();
        this._newGame(fieldSize, n_ships);
    }
    reset() {
        this.newGame(this.field.size, this.n_ships);
    }
    cleanup() {
        this.field.cleanup();
    }
    onKeyDown(event) {
        this.keyDown(event.keyCode);
        event.preventDefault();
    }
    onKeyUp(event) {
        this.keyUp(event.keyCode);
        event.preventDefault();
    }
    mapKey(key, keyCode) {
        this.keysByCode[keyCode] = key;
    }
    keyDown(keyCode) {
        if(this.menu) {
            this.menu.keyDown(keyCode);
        } else if(keyCode === KEY_ESCAPE) {
            this.setTitleMenu();
        } else if(keyCode === KEY_ENTER) {
            this.shouldRenderControls = !this.shouldRenderControls;
        } else {
            var key = this.keysByCode[keyCode];
            if(key) key.down();
        }
    }
    keyUp(keyCode) {
        if(this.menu) {
            this.menu.keyUp(keyCode);
        } else {
            var key = this.keysByCode[keyCode];
            if(key) key.up();
        }
    }
    setMenu(cls) {
        this.unsetMenu();
        return this.menu = new cls(this);
    }
    unsetMenu() {
        if(!this.menu) return;
        this.menu.cleanup();
        this.menu = null;
    }
    setTitleMenu() {
        var menu = this.setMenu(TitleMenu);
        if(this.players.length > 0) {
            // Hack: choose first player
            var player = this.players[0];
            menu.setPlayer(player);
        }
    }
    addShip(cls) {
        return this.field.addShip(cls);
    }
    addPlayer() {
        var player = new Player();
        this.players.push(player);
        return player;
    }
    step() {
        for(var player of this.players) player.step();
        this.field.step();
        this.camera.step();
    }
    render() {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.field.render(canvas, this.camera);
        if(this.menu) {
            this.menu.render();
        } else if(this.shouldRenderControls) {
            this.renderControls();
        }
    }
    renderControls() {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';

        var x = 16;
        var y = 20;

        ctx.font = 'normal bold 24px sans-serif';
        ctx.fillText('Controls:', x, y);
        y += 26;

        ctx.font = 'normal 18px monospace';
        var lines = [
            'Left/right: turn left/right',
            'Up/down   : thrust/reverse',
            'Spacebar  : space gun #1',
            'Z         : space gun #2',
            'Escape    : return to menu',
            'Enter     : show/hide controls',
        ];
        for(var line of lines) {
            ctx.fillText(line, x, y);
            y += 18;
        }
    }
    renderTitle(title, subtitles) {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';

        var x = canvas.width / 2;
        var y = canvas.height / 4;

        ctx.font = 'normal bold 40px sans-serif';
        ctx.fillText(title, x, y);
        y += 40;

        if(subtitles) for(var subtitle of subtitles) {
            ctx.font = 'normal bold 20px sans-serif';
            ctx.fillText(subtitle, x, y);
            y += 20;
        }
    }
    intervalCallback() {
        /* Callback for use with setInterval */
        if(TIMING) var t0 = new Date();
        try {
            this.step();
            this.render();
        } catch(ex) {
            // Stop the same error from throwing repeatedly.
            // Don't set this.intervalId to 0 though, for debugging
            // purposes.
            clearInterval(this.intervalId);

            throw ex;
        }
        if(TIMING) {
            var t1 = new Date();
            console.log('TIMING: ' + String(t1 - t0));
        }
    }
    play(millis) {
        millis = millis || 30;
        if(this.intervalId) clearInterval(this.intervalId);
        var callback = this.intervalCallback.bind(this);
        this.intervalId = setInterval(callback, millis);
    }
    pause() {
        if(!this.intervalId) return;
        clearInterval(this.intervalId);
        this.intervalId = 0;
    }
}

class Menu {
    constructor(game) {
        this.game = game;
    }
    cleanup() {
    }
    render() {
    }
    keyDown(keyCode) {
    }
    keyUp(keyCode) {
    }
}

class TitleMenu extends Menu {
    player = null;
    ship_class_i = 0;

    static ACTIONS = [
        {
            name: 'choose ship',
            subtitles: [
                'Choose your ship',
                '(Left/right arrow keys + Enter)',
            ],
        },
        {
            name: 'reset',
            subtitles: [
                'Reset game?',
                '(Press Enter)',
            ],
        },
    ];

    constructor(game) {
        super(game);
        this.action_i = 0;
    }
    setPlayer(player) {
        this.player = player;

        var ship = player.entity;
        if(ship) {
            this.ship_class_i = SHIP_CLASSES.indexOf(ship.constructor);
        }

        this.updateShipClass();
    }
    render() {
        var action = this.constructor.ACTIONS[this.action_i];
        this.game.renderTitle('Shipteroids', action.subtitles);
    }
    keyDown(keyCode) {
        if(!this.player) return;
        var action = this.constructor.ACTIONS[this.action_i];
        if(keyCode === KEY_U) {
            this.action_i = modulo(this.action_i - 1,
                this.constructor.ACTIONS.length);
        } else if(keyCode === KEY_D) {
            this.action_i = modulo(this.action_i + 1,
                this.constructor.ACTIONS.length);
        } else if(keyCode === KEY_L) {
            if(action.name === 'choose ship') {
                this.ship_class_i = modulo(this.ship_class_i - 1,
                    SHIP_CLASSES.length);
                this.updateShipClass();
            }
        } else if(keyCode === KEY_R) {
            if(action.name === 'choose ship') {
                this.ship_class_i = modulo(this.ship_class_i + 1,
                    SHIP_CLASSES.length);
                this.updateShipClass();
            }
        } else if(keyCode === KEY_ENTER) {
            if(action.name === 'reset') {
                this.resetGame();
            } else {
                this.game.unsetMenu();
            }
        }
    }
    resetGame() {
        this.game.reset();
        this.updateShipClass();
    }
    updateShipClass() {
        var cls = SHIP_CLASSES[this.ship_class_i];
        var ship = this.game.addShip(cls);

        var old_ship = this.player.entity;
        if(old_ship) {
            ship.pos.copy(old_ship.pos);
            ship.vel.copy(old_ship.vel);
            ship.rot = old_ship.rot;

            old_ship.remove();
            // HACK: old_ship has only been marked for removal, we now
            // manually call the function which truly removes it.
            // We do this because otherwise, the old and new ships
            // coexist for one frame, which is enough time for them
            // to collide with each other...
            this.game.field.removeEntities(this.game.field.ships);
        } else {
            ship.pos.setMidpoint(this.game.field.size);
        }

        this.game.camera.setTarget(ship);
        this.player.setEntity(ship);
    }
}

class Effect extends Entity {
    fadeWithAge = true;
}

class SmokeEffect extends Effect {
    radius = 7 * RADIUSMUL;
    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgba(200,200,200,.2)';
    velmul = 1;
    maxAge = 20;
}

class FlameSmokeEffect extends SmokeEffect {
    radius = 5 * RADIUSMUL;
    circleFillStyle = 'rgba(200,150,100,.2)';
}

class ThrustEffect extends Effect {
    radius = 5 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(0,255,255,.5)';
    trailLineWidth = 3;
    maxAge = 20;
}

class SparkEffect extends Effect {
    radius = 3 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(255,255,0,.5)';
    velmul = .95;
    maxAge = 20;
}

class Ship extends Entity {
    static maxhp = 100;

    die() {
        this.emitEffects(SmokeEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class FighterShip extends Ship {
    radius = 7 * RADIUSMUL;
    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .5;

    shotClass = {
        x: DoubleShot,
        y: DoubleMissileShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {stroke: false}),
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {fill: false, close: false}),
    ]);
}

class ScoutShip extends Ship {
    radius = 6 * RADIUSMUL;

    static maxhp = 65;
    wingsOut = true;

    shotClassWingsOut = {
        x: QuadrupleShot,
        y: null,
    };

    shotClassWingsIn = {
        x: RapidSingleShot,
        y: null,
    };

    pictureWingsOut = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point( -.2,   -1.8),
            new Point( -.1,   -.75),
            new Point( 1.2,    0),
            new Point( -.1,    .75),
            new Point( -.2,    1.8),
        ]),
    ]);

    pictureWingsIn = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point(- .7,   -.75),
            new Point( 1.2,    0),
            new Point(- .7,    .75),
        ]),
    ]);

    constructor(field) {
        super(field);
        this._updateStats();
    }
    _updateStats() {
        if(this.wingsOut) {
            this.thrustSpeed = 2.25;
            this.reverseSpeed = 1.5;
            this.velmul = .85;
            this.rotspeed = Math.PI / 25;
            this.rotmul = .6;
            this.picture = this.pictureWingsOut;
            this.shotClass = this.shotClassWingsOut;
        } else {
            this.thrustSpeed = 2.75;
            this.reverseSpeed = 1.75;
            this.velmul = .95;
            this.rotspeed = Math.PI / 30;
            this.rotmul = .4;
            this.picture = this.pictureWingsIn;
            this.shotClass = this.shotClassWingsIn;
        }
    }
    fire(keyname) {
        if(keyname === 'y') {
            this.wingsOut = !this.wingsOut;
            this._updateStats();

            var shotprops = this.shotprops[keyname];
            shotprops.cooldown += 6;
            shotprops.n_shots++;
        } else {
            super.fire(keyname);
        }
    }
}

class AssaultShip extends Ship {
    radius = 9 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = .5;
    velmul = .95;
    rotspeed = Math.PI / 34;
    rotmul = .65;

    static maxhp = 175;

    shotClass = {
        x: TripleShot,
        y: BlasterShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-.9,    0),
            new Point(-.4, -.95),
            new Point( .9,    0),
            new Point(-.4,  .95),
        ]),
    ]);
}

class TorchShip extends Ship {
    radius = 6 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = 1;
    velmul = .95;
    rotspeed = Math.PI / 40;
    rotmul = .7;

    static maxhp = 90;

    shotClass = {
        x: FlameShot,
        y: MineShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-1.3,    0),
            new Point( 0  ,   -1),
            new Point( 1  ,    0),
            new Point( 0  ,    1),
        ]),
    ]);
}

class TurretShip extends Ship {
    radius = 6 * RADIUSMUL;
    thrustSpeed = .65;
    reverseSpeed = .45;
    velmul = .95;
    rotspeed = Math.PI / 40;
    rotmul = .7;

    static maxhp = 60;

    shotClass = {
        x: QuadrupleShot,
        y: QuadrupleMissileShot,
    };

    picture = new Picture([
        Shape.newPolygon(6),
        new Shape([
            new Point(0  , 0),
            new Point(1.2, 0),
        ], {fill: false, close: false}),
    ]);
}

class FlagShip extends Ship {
    radius = 10.5 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = 1.25;
    velmul = .9;
    rotspeed = Math.PI / 34;
    rotmul = .5;

    static maxhp = 150;

    static max_turret_cooldown = 20;

    picture = new Picture([
        new Shape([
            new Point(-.9, -.3),
            new Point(-.7, -.5),
            new Point( .9, -.5),
            new Point( .9,  .5),
            new Point(-.7,  .5),
            new Point(-.9,  .3),
        ]),
    ], {radiusmul: 1.2});

    constructor(field) {
        super(field);

        this.turret = null;
        this.turret_cooldown = this.constructor.max_turret_cooldown;
    }
    remove() {
        if(this.turret) this.turret.die();
        super.remove();
    }
    addTurret() {
        if(this.turret) return;
        var turret = this.field.addShip(TurretShip);
        turret.pos.copy(this.pos)
            .addSpeed(this.radius + turret.radius, this.rot);
        turret.vel.copy(this.vel);
        this.turret = turret;
        this.turret_cooldown = this.constructor.max_turret_cooldown;
    }
    step() {
        super.step();
        if(this.turret) {
            for(var keyname of 'xy') {
                var key = this.keys[keyname];
                this.turret.keys[keyname].copy(key);
            }

            // Keep turret pointed away from us (so we can aim it
            // by positioning ourselves)
            var dx = this.pos.x - this.turret.pos.x;
            var dy = this.pos.y - this.turret.pos.y;
            if(dx && dy) {
                var angle = Math.atan2(-dy, dx);
                var anglediff = moduloDiff(
                    this.turret.rot, angle + Math.PI, Math.PI * 2);
                this.turret.rot_vel += anglediff * .2;
            }

            var dist = this.pos.dist(this.turret.pos);
            var tdist = 30 * RADIUSMUL;
            // TODO: spring physics between turret and us

        } else {
            if(this.turret_cooldown) {
                this.turret_cooldown--;
            } else {
                this.addTurret();
            }
        }
    }
}

class Shot extends Entity {

    static initialShots = 1;
    static serialShots = 1;
    // "rot variance": difference in radians between the rot of first
    // and last Shot instance produced by firing this Shot type
    static initialRotVariance = 0;
    static serialRotVariance = 0;
    static randomRotVariance = 0;
    static initialPosRotVariance = 0;
    static serialPosRotVariance = 0;
    static randomPosRotVariance = 0;

    static initialSpeed = 20;
    static initialVelMul = 1;
    static randomSpeedVariance = 0;

    // How hard we move things we hit
    hitVelMul = .1;

    // How much damage we do
    hitDamage = 10 * DAMAGEMUL;

    // If < 1, the amount of damage we do goes down over time
    hitDamageAgeMul = 1;

    hitEffectClass = SparkEffect;

    static cooldown = 4;

    constructor(field) {
        super(field);

        // The Ship who shot us out
        this.ship = null;
    }
    afterShotBy(entity) {
        // Bit of a hack, called by Entity.shoot, Entity.emitShots, etc.
        // Just lets subclasses of Shot customize themselves a bit based
        // on the entity which shot them.
    }
    step() {
        super.step();
        this.hitDamage *= this.hitDamageAgeMul;
    }
    hit(other) {
        other.vel.addMul(this.vel, this.hitVelMul);
        other.damage(this.hitDamage);
        this.emitEffects(this.hitEffectClass, 2, {
            speed_min: 2,
            speed_max: 4,
            velmul: .75,
        });
        this.die();
    }
}

class SingleShot extends Shot {
    radius = .25 * RADIUSMUL;
    velmul = .95;
    hitDamageAgeMul = .95;
    shouldRenderTrail = true;
    maxAge = 40;
    fadeWithAge = true;
}

class RapidSingleShot extends SingleShot {
    hitDamage = 6;
    static cooldown = 2;
    hitVelMul = .05;
    trailStrokeStyle = '#aaa';
    trailEnd = .3;
}

class DoubleShot extends SingleShot {
    static serialShots = 2;
    static serialRotVariance = Math.PI / 18;
}

class TripleShot extends SingleShot {
    static initialShots = 3;
    static serialShots = 1;
    static initialRotVariance = Math.PI / 13;
    static serialRotVariance = 0;
    static cooldown = 8;
}

class QuadrupleShot extends SingleShot {
    static serialShots = 4;
    static serialRotVariance = Math.PI / 20;
    static serialPosRotVariance = Math.PI;
    static cooldown = 2;
}

class BlasterShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 12;
    velmul = 1;

    hitVelMul = .5;
    hitDamage = 20 * DAMAGEMUL;

    maxAge = 14;
    static cooldown = 32;

    picture = Picture.newPolygon(6);

    die() {
        this.emitShots(SingleShot, 5, {
            rot_variance: Math.PI / 4,
            speed_min: 10,
            speed_max: 10,
        });
        super.die();
    }
}

class MissileShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 8;
    static initialVelMul = .2;
    velmul = .9;

    thrustSpeed = 3;

    hitVelMul = .45;
    hitDamage = 10 * DAMAGEMUL;

    maxAge = 30;
    fadeWithAge = false;
    static cooldown = 24;

    shouldRenderTrail = true;

    picture = new Picture([
        new Shape([
            new Point(-1.2, -.3),
            new Point( 1.2, -.3),
            new Point( 1.2,  .3),
            new Point(-1.2,  .3),
        ]),
    ]);

    step() {
        if(this.age < this.maxAge / 2) {
            this.vel.addSpeed(this.thrustSpeed, this.rot);
        } else {
            this.shouldRenderTrail = false;
        }
        super.step();
    }
    afterShotBy(entity) {
        super.afterShotBy(entity);
        this.rot_vel = moduloDiff(this.rot, entity.rot, Math.PI * 2) * 2;
    }
    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class DoubleMissileShot extends MissileShot {
    static initialShots = 2;
    static initialRotVariance = Math.PI / 9;
    static initialPosRotVariance = Math.PI / 3;
}

class QuadrupleMissileShot extends MissileShot {
    static serialShots = 4;
    static serialRotVariance = Math.PI / 4;
    static serialPosRotVariance = Math.PI;
    static cooldown = 8;
}

class FlameShot extends Shot {
    static randomRotVariance = Math.PI / 15;
    static randomPosRotVariance = Math.PI / 3;
    static randomSpeedVariance = 1.5;

    static initialSpeed = 6;
    static initialVelMul = .8;

    hitVelMul = 0;
    hitDamage = 4 * DAMAGEMUL;
    hitDamageAgeMul = .9;
    hitEffectClass = FlameSmokeEffect;

    static cooldown = 1;

    radius = 5 * RADIUSMUL;
    velmul = .95;
    maxAge = 25;
    fadeWithAge = true;

    picture = new Picture([
        Shape.newPolygon(3, null, {stroke: false}),
        Shape.newPolygon(3, {rot: Math.PI * 2 / 6}, {stroke: false}),
    ]);
    circleFillStyle = 'rgba(255,180,0,.25)';

    constructor(field) {
        super(field);
        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
}

class MineShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 0;
    velmul = .9;

    hitDamage = 20 * DAMAGEMUL;

    maxAge = 300;
    static cooldown = 32;

    picture = Picture.newPolygon(6);
    circleFillStyle = 'rgba(255,180,0,.4)';

    die() {
        var shots = this.emitShots(FlameShot, 5, {
            rot_variance: Math.PI * 2,
            rand_rot_variance: Math.PI / 3,
            speed_min: 3,
            speed_max: 6,
        });

        // The flames emitted by a mine damage the ship who laid the mine!
        for(var shot of shots) shot.ship = null;

        super.die();
    }
}

class Rock extends Entity {

    circleStrokeStyle = '#987';
    velmul = 1;
    rotmul = 1;

    constructor(field, radius) {
        super(field);

        var default_radius = 10 * RADIUSMUL;

        radius = radius || default_radius;
        this.radius = radius;

        var default_hp = 50;
        this.hp = default_hp * radius / default_radius;

        var n_points = Random.randIntInclusive(5, 10);
        this.picture = Picture.newPolygon(n_points,
            {rotVariance: .5, radiusVariance: .1});

        this.pos.setRandomWithin(field.size);

        var speed = Random.randNumber(3.5);
        this.vel.setSpeed(speed, Random.randRotation());

        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    die() {
        var min_radius = 9 * RADIUSMUL;
        if(this.radius >= min_radius) {
            var velmul = .75;
            var n_rocks = 2;
            var addposrot = Random.randRotation();
            for(var i = 0; i < n_rocks; i++) {
                var rock = this.field.addRock(
                    this.constructor, this.radius * .65);
                var posrot = (i / n_rocks) * Math.PI * 2 + addposrot;
                rock.pos.copy(this.pos)
                    .addSpeed(this.radius, addposrot);
                rock.vel.addMul(this.vel, velmul);
            }
        }
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}


var SHIP_CLASSES = [
    FighterShip,
    ScoutShip,
    AssaultShip,
    TorchShip,
    TurretShip,
    FlagShip,
];


var canvas = document.getElementById('canvas');

var game = new Game(canvas, null, 4);
var params = new URLSearchParams(window.location.search);
game.shouldRenderControls = !Boolean(params.get('nocontrols'));

var player = game.addPlayer();
game.mapKey(player.keys.u, KEY_U);
game.mapKey(player.keys.d, KEY_D);
game.mapKey(player.keys.l, KEY_L);
game.mapKey(player.keys.r, KEY_R);
game.mapKey(player.keys.x, KEY_SPACE);
game.mapKey(player.keys.y, KEY_SECONDARY);

game.setTitleMenu();

game.play();
canvas.style.border = 'none';
canvas.focus();


</script>
</body>
</html>