<html>
<head>
<title>Shipteroids!</title>
<style>
body {
    color: #fff;
    background-color: #000;
}
.canvas {
    border: solid 1px #0f0;
    display: inline;
}
.canvas-container {
    width: 100%;
    text-align: center;
}
</style>
</head>
<body>
<div class="canvas-container">
    <canvas id="canvas" class="canvas" width=700 height=700 tabindex=-1></canvas>
</div>
<script>

'use strict';


/******************************
* IDEAS:
*
* Rammer ship
* Really big ship (MotherShip) with "gravity" using Entity.magneticField
* Hunter ship?.. BlasterShot + "wormhole" ability?..
*
* TODO:
*
* When a player loses their ship, reset players' keys (otherwise e.g. they can
* still be holding Up while you're in the menu choosing ships)
*
* Maybe... MapProgress.edge is never null?..
* So the current thing where you are "at" a node would just be when edgeDist
* is 0.
* THIS IS IMPORTANT because otherwise we need to have something which
* represents "the edge which will become progress.edge next time you
* warp", which is vaguely obnoxious.
*
******************************/


// an empty Object (do not modify!!)
var EMPTY = {};


// query params
var PARAMS = new URLSearchParams(window.location.search);
function getParam(name, default_value) {
    var value = PARAMS.get(name);
    return value === null? default_value: value;
}
function getBoolParam(name) {
    return Boolean(getParam(name, false));
}

// debug stuff
var TIMING = getBoolParam('timing');
var RENDER_CIRCLES = getBoolParam('render_circles');
var RENDER_BOUNDARY = getBoolParam('render_boundary');
var HIDE_TEXT = getBoolParam('hide_text');
var NODAMAGE = getBoolParam('nodamage');
var MAGNETIC_FIELD = getBoolParam('magnetic_field');

// physics tweaking stuff
var VELMUL = .7;
var ROTVELMUL = .5;
var RADIUSMUL = 2;
var DAMAGEMUL = 1;
var DEFAULT_ROCK_RADIUS = 10 * RADIUSMUL;
var WARP_RADIUS = 10 * RADIUSMUL;
var WARP_AFTER_STEPS = 30;
var WARP_RADIUS = 10;
var MAX_WARP_ADDRADIUS = 16;

// Game/field default options
var DEFAULT_FIELD_WIDTH  = 1000;
var DEFAULT_FIELD_HEIGHT = 1000;
var DEFAULT_STARS_PER    = 1 /    5000;
var DEFAULT_ROCKS_PER    = 1 /  300000;
var DEFAULT_PLANETS_PER  = 1 / 1000000;
var DEFAULT_SHIPS_PER    = 1 /  500000;
var DEFAULT_STAR_SPEED_MIN = 1.5;
var DEFAULT_STAR_SPEED_MAX = 4.5;

// keyCode values
var KEY_U = 38;
var KEY_D = 40;
var KEY_L = 37;
var KEY_R = 39;
var KEY_ENTER = 13;
var KEY_SPACE = 32;
var KEY_SHIFT = 16;
var KEY_ESCAPE = 27;
var KEY_WARP = 87; // 'W'
var KEY_TAB = 9;

var TEAMS = [
    {
        strokeStyle: '#0f0',
    },
    {
        strokeStyle: '#00f',
    },
    {
        strokeStyle: '#f00',
    },
    {
        strokeStyle: '#ff0',
    },
];


function linear(x0, x1, n) {
    /* Assumes: 0 <= n <= 1 */
    return x0 + (x1 - x0) * n;
}

function getDefault(value, default_value) {
    return value === undefined? default_value: value;
}

function modulo(x, n) {
    /* Returns the modulus of x / n.
    Expects n > 0.

    Example:

         x | n | modulo(x, n)
        ---+---+--------------
         -3| 3 | 0
         -2| 3 | 1
         -1| 3 | 2
          0| 3 | 0
          1| 3 | 1
          2| 3 | 2
          3| 3 | 0
    */
    return ((x % n) + n) % n;
}

function getRotVariance(i, n) {
    // rotVariance: number between -.5 and .5
    if(n <= 1) return 0;
    return i / (n - 1) - .5;
}

function moduloDiff(x0, x1, w) {
    /* Difference between two numbers on the "wrapped" interval between
    0 and w.
    (Distance from x0 to x1.) */
    x0 = modulo(x0, w);
    x1 = modulo(x1, w);
    var diff = x1 - x0;

    if(diff < -w/2)return diff + w;
    else if(diff > w/2)return diff - w;
    else return diff;
}

function rotDiff(r0, r1) {
    return moduloDiff(r0, r1, Math.PI * 2);
}

function renderCircle(ctx, x0, y0, rot, radius, opts) {
    opts = opts || EMPTY;
    var scale = getDefault(opts.scale, 1);
    var scalex = getDefault(opts.scalex, scale);
    var scaley = getDefault(opts.scaley, scale);
    ctx.save();
    {
        ctx.translate(x0, y0);
        ctx.scale(scalex, scaley);
        ctx.rotate(rot);
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fill();
    }
    ctx.restore();
}

class Text {
    /* Text which can be rendered onto a canvas. */

    constructor(title, lines) {
        this.title = title;
        this.lines = lines;
    }
    render(canvas) {
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';

        var x = 16;
        var y = 20;

        ctx.font = 'normal bold 24px sans-serif';
        ctx.fillText(this.title, x, y);
        y += 26;

        ctx.font = 'normal 18px monospace';
        for(var line of this.lines) {
            ctx.fillText(line, x, y);
            y += 18;
        }
    }
}

class Random {
    /* Utility functions for producing random values */

    static randNumber(a, b) {
        if(b === undefined) {
            b = a;
            a = 0;
        }
        return a + Math.random() * (b - a);
    }
    static randInt(a, b) {
        return Math.floor(this.randNumber(a, b));
    }
    static randIntInclusive(a, b) {
        return this.randInt(a, b + 1);
    }
    static choice(choices) {
        return choices[this.randInt(choices.length)];
    }
    static randRotation() {
        return this.randNumber(Math.PI * 2);
    }
    static randColor(min, max) {
        if(max === undefined) {
            max = min;
            min = 0;
        }
        if(max === undefined) max = 256;

        var r = this.randInt(min, max);
        var g = this.randInt(min, max);
        var b = this.randInt(min, max);
        return Color.rgb(r, g, b);
    }
}

class Color {
    /* Helper functions for creating CSS colours */
    static rgb(r, g, b, a) {
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }
}

class Point {
    /* A 2-dimensional point.
    Can also be used to represent the width+height of a rectangle,
    and/or represent the rectangle between (0,0) and (this.x,this.y). */

    constructor(x, y) {
        this.x = getDefault(x, 0);
        this.y = getDefault(y, 0);
    }
    clone() {
        return new Point(this.x, this.y);
    }
    set(x, y) {
        this.x = getDefault(x, 0);
        this.y = getDefault(y, 0);
        return this;
    }
    area() {
        return this.x * this.y;
    }
    dist(other, modulo) {
        var x0 = this.x;
        var y0 = this.y;
        var x1 = other? other.x: 0;
        var y1 = other? other.y: 0;

        var dx = Math.abs(x1 - x0);
        var dy = Math.abs(y1 - y0);
        if(modulo) {
            // If modulo is provided, it should be a Point representing
            // a rectangle representing a torus within which this and other
            // are contained.
            if(dx > modulo.x / 2) dx = modulo.x - dx;
            if(dy > modulo.y / 2) dy = modulo.y - dy;
        }
        return Math.sqrt(dx * dx + dy * dy);
    }
    angle(other, modulo) {
        var dx, dy;
        if(other) {
            if(modulo) {
                dx = moduloDiff(other.x, this.x, modulo.x);
                dy = moduloDiff(other.y, this.y, modulo.y);
            } else {
                dx = other.x - this.x;
                dy = other.y - this.y;
            }
        } else {
            dx = this.x;
            dy = this.y;
        }
        if(!dx || !dy) return undefined;
        return Math.atan2(-dy, dx);
    }
    copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }
    setMidpoint(other) {
        /* Sets this to the midpoint of the a rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = other.x / 2;
        this.y = other.y / 2;
        return this;
    }
    setRandomWithin(other) {
        /* Sets this to a random point within the rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = Random.randNumber(other.x);
        this.y = Random.randNumber(other.y);
        return this;
    }
    addxy(x, y) {
        this.x += x;
        this.y += y;
        return this;
    }
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    addMul(other, mul) {
        this.x += other.x * mul;
        this.y += other.y * mul;
        return this;
    }
    mul(n) {
        this.x *= n;
        this.y *= n;
        return this;
    }
    modulo(other) {
        /* Returns this Point modulo the rectangle between (0,0) and
        (other.x, other.y).
        You can think of this as constraining this Point within the
        torus defined by the rectangle defined by other.
        If you're into that kind of thing. O_o */
        this.x = modulo(this.x, other.x);
        this.y = modulo(this.y, other.y);
        return this;
    }
    rotate(rot) {
        /*
            for(var i = 0; i < 4; i++) {
                var p = new Point(1).rotate(Math.PI * i / 2); 
                console.log(p);
            }
            // {x:  1, y:  0}
            // {x:  0, y: -1}
            // {x: -1, y:  0}
            // {x:  0, y:  1}
        */
        var sin = Math.sin(rot);
        var cos = Math.cos(rot);
        var x =  this.x;
        var y = -this.y;
        this.x =  (x * cos - y * sin);
        this.y = -(x * sin + y * cos);
        return this;
    }
    setSpeed(speed, rot) {
        return this.set(speed).rotate(rot);
    }
    addSpeed(speed, rot) {
        var x = this.x;
        var y = this.y;
        this.setSpeed(speed, rot);
        this.x += x;
        this.y += y;
        return this;
    }
}

class FieldTemplate {
    /* Blueprint for creating a Field and populating it with entities (stars,
    rocks, ships, etc). */

    width_min = DEFAULT_FIELD_WIDTH;
    width_max = DEFAULT_FIELD_WIDTH;
    height_min = DEFAULT_FIELD_HEIGHT;
    height_max = DEFAULT_FIELD_HEIGHT;

    stars_per = DEFAULT_STARS_PER;
    rocks_per = DEFAULT_ROCKS_PER;
    planets_per = DEFAULT_PLANETS_PER;
    ships_per = DEFAULT_SHIPS_PER;

    star_speed_min = DEFAULT_STAR_SPEED_MIN;
    star_speed_max = DEFAULT_STAR_SPEED_MAX;

    ship_classes = SHIP_CLASSES;

    teams = TEAMS;

    constructor(props) {
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    getWidth() {
        return Random.randNumber(this.width_min, this.width_max);
    }
    getHeight() {
        return Random.randNumber(this.height_min, this.height_max);
    }
    getSize() {
        return new Point(this.getWidth(), this.getHeight());
    }
    getShipClass() {
        return Random.choice(this.ship_classes);
    }
    getStarSpeed() {
        return Random.randNumber(this.star_speed_min, this.star_speed_max);
    }
}

class MapDestination {
    /* Somewhere you can be on a Map.
    To be more precise, every MapProgress has an associated MapDestination,
    which is either a MapNode or a MapEdge. */

    constructor(map, template) {
        this.map = map;
        this.template = template;
    }
}

class MapNode extends MapDestination {
    /* A node of the graph represented by class Map. */

    constructor(map, template, text) {
        super(map, template);
        this.text = text || null;
        this.edges = [];
        this.backedges = [];

        // radius, pos, vel: don't affect anything, only used for rendering the
        // Map and its nodes/edges as a graph with "springy physics"
        // (also apparently known as a "force-directed graph")
        var speed = Random.randNumber(250);
        var rot = Random.randRotation();
        this.pos = new Point().addSpeed(speed, rot);
        this.vel = new Point();
        this.radius = 12;

        this.strokeStyle = 'rgba(20,100,200,.75)';
        this.fillStyle = 'rgba(255,255,255,.25)';
    }
    addEdge(other, len, template) {
        template = template || this.template;
        var edge = new MapEdge(this.map, template, this, other, len);
        this.edges.push(edge);
        other.backedges.push(edge);
        return edge;
    }
    step() {
        this.pos.add(this.vel);
    }
}

class MapEdge extends MapDestination {
    /* Connects one MapNode (this.node0) to another (this.node1).
    Has a length (this.len), an integer representing the number of
    warps you need to make in order to travel between this.node0 and
    this.node1. */

    constructor(map, template, node0, node1, len) {
        super(map, template);
        this.node0 = node0;
        this.node1 = node1;
        this.len = getDefault(len, 0);

        this.forwardEdge = new DirectedMapEdge(this, false);
        this.backEdge = new DirectedMapEdge(this, true);

        this.strokeStyle = 'rgba(20,100,200,.75)';
    }
}

class DirectedMapEdge {
    /* Wraps a MapEdge, representing an arrow pointing along it in either
    direction (that is, either from node0 to node1, or vice versa). */

    constructor(edge, isBackEdge) {
        this.edge = edge;
        this.isBackEdge = isBackEdge;
    }
    getReversed() {
        return this.isBackEdge? this.edge.forwardEdge: this.edge.backEdge;
    }
    getLen() {
        return this.edge.len;
    }
    getNode0() {
        return this.isBackEdge? this.edge.node1: this.edge.node0;
    }
    getNode1() {
        return this.isBackEdge? this.edge.node0: this.edge.node1;
    }
}

class Map {
    /* A directed graph of MapNodes and MapEdges, each of which have an
    associated FieldTemplate. */

    constructor() {
        this.nodes = [];
        this.startNode = null;
        this.startEdge = null; // DirectedMapEdge
    }
    addNode(template, text) {
        var node = new MapNode(this, template, text);
        this.nodes.push(node);
        return node;
    }
    step() {
        for(var node of this.nodes) node.step();
    }
}

class MapProgress {
    /* Represents players' "progress" across a Map.
    For instance, the MapNode at which they are currently located, and
    the MapEdge along which they are travelling (if applicable). */

    constructor(map) {
        if(!map.nodes.length) throw new Error('Map has no nodes');
        this.map = map;

        // node is never null
        this.node = null;

        // edge: a DirectedMapEdge
        // edge is null if we're at a node; edge is not null when we're
        // travelling from this.node to this.edge.getNode1()
        this.edge = null;

        // edgeDist: how far we've travelled along this.edge (if it's not
        // null).
        // Once this.edgeDist reaches this.edge.getLen(), this.node is set
        // to this.edge.getNode1(), and this.edgeDist is set to 0.
        this.edgeDist = 0;

        this.setNode(map.startNode || map.nodes[0]);

        if(map.startEdge) this.setEdge(map.startEdge);
    }
    getDestination() {
        return this.edge? this.edge.edge: this.node;
    }
    getText() {
        if(this.edge) return null;
        return this.node.text;
    }
    setNode(node) {
        if(this.edge) throw new Error('Busy travelling along an edge');
        this.node = node;
    }
    unsetEdge() {
        if(!this.edge) throw new Error('Edge not yet set');
        this.edge = null;
        this.edgeDist = 0;
    }
    setEdge(edge) {
        if(this.edge) throw new Error('Edge already set');
        if(edge.len === 0) {
            this.setNode(edge.node1);
            return;
        }
        this.edge = edge;
        this.edgeDist = 0;
    }
    proceed() {
        if(!this.edge) return;
        this.edgeDist++;
        if(this.edgeDist >= this.edge.len) {
            this.setNode(this.edge.node1);
            this.unsetEdge();
        }
    }
}

class Field {
    /* Think of "field" in the sense of "playing field".
    It's basically a rectangle within which sprites can fly around.
    The edges of the rectangle "wrap around" (or you can say it's a
    "torus" if you prefer). */

    constructor(game, size) {
        this.game = game;
        this.size = size;

        this.stars = [];

        this.entityArrays = [];
        this.planets = this.addEntityArray();
        this.ships = this.addEntityArray();
        this.shots = this.addEntityArray();
        this.effects = this.addEntityArray();
        this.rocks = this.addEntityArray();

        /* Create a canvas for rendering this Field.
        This canvas is never attached to a parent element, we only
        use it for drawing, then copy its image onto another canvas. */
        this.innerCanvas = document.createElement('canvas');
        this.innerCanvas.width = this.size.x;
        this.innerCanvas.height = this.size.y;
    }
    populate(template) {
        var area = this.size.area();
        var n_stars = area * template.stars_per;
        var n_rocks = area * template.rocks_per;
        var n_planets = area * template.planets_per;
        var n_ships = area * template.ships_per;

        /* Add some random stars */
        var star_vel_rot = Random.randRotation();
        var star_speed = template.getStarSpeed();
        for(var i = 0; i < n_stars; i++) {
            var star = new Star(this);
            this.stars.push(star);

            star.pos.setRandomWithin(this.size);

            /* Each star has a random "distance", as in, how far away it
            is.
            Distance is a number between 0 and 1, with higher numbers
            meaning "further away".
            Stars which are "further away" are darker and move slower,
            to give a bit of parallax-ish effect. */
            var distance = Random.randNumber(0.25, 0.75);
            var color_component = Math.floor(255 * distance);
            star.trailStrokeStyle = 'rgb('
                + color_component + ','
                + color_component + ','
                + color_component + ')';
            star.vel.setSpeed(star_speed * distance, star_vel_rot);
            star.distance = distance;
        }

        /* Sort this.stars by "distance" so that when we iterate over
        it in render(), more distant stars are rendered first, and
        therefore "painted over" by closer stars. */
        this.stars.sort((s1, s2) => Math.sign(s2.distance - s1.distance));

        // Add rocks
        for(var i = 0; i < n_rocks; i++) {
            var rock = this.addRock(Rock);
        }

        // Add planets
        for(var i = 0; i < n_planets; i++) {
            var planet = this.addPlanet(Planet);
        }

        // Add ships
        for(var i = 0; i < n_ships; i++) {
            var player = this.game.addCPUPlayer();
            player.setTeam(Random.choice(template.teams));
            player.createShip(Random.choice(template.ship_classes));
        }
    }
    addEntityArray() {
        // Create an Array used to store Entity instances
        // (E.g. Game.ships, Game.rocks, etc)
        var entityArray = [];

        // Add a pending Array of things to be added to the Array at the
        // start of next Field.step
        entityArray.pending = [];

        this.entityArrays.push(entityArray);
        return entityArray;
    }
    cleanup() {
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.cleanup();
        }
    }
    addShip(cls) {
        var entity = new cls(this);
        this.ships.pending.push(entity);
        return entity;
    }
    addShot(cls) {
        var entity = new cls(this);
        this.shots.pending.push(entity);
        return entity;
    }
    addEffect(cls) {
        var entity = new cls(this);
        this.effects.pending.push(entity);
        return entity;
    }
    addRock(cls, radius) {
        radius = getDefault(radius, Random.randNumber(7, 32) * RADIUSMUL);
        var entity = new cls(this, radius);
        this.rocks.pending.push(entity);
        return entity;
    }
    addPlanet(cls) {
        var entity = new cls(this);
        this.planets.pending.push(entity);
        return entity;
    }
    addPendingEntities(entityArray) {
        for(var entity of entityArray.pending) entityArray.push(entity);
        entityArray.pending.length = 0;
    }
    step() {
        for(var entityArray of this.entityArrays) {
            this.addPendingEntities(entityArray);
        }

        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.step();
        }

        for(var shot of this.shots) {
            for(var ship of this.ships) {
                if(shot.ship && ship.isAlly(shot.ship)) continue;
                if(ship.rock) continue;
                if(shot.colliding(ship)) shot.hit(ship);
                // Don't bother calling handleCollision() with Shots
                // (We might want to in future, though...)
            }
            for(var rock of this.rocks) {
                if(shot.ship && rock.mole && shot.ship === rock.mole) continue;
                if(shot.colliding(rock)) shot.hit(rock);
                // Don't bother calling handleCollision() with Shots
                // (We might want to in future, though...)
            }
        }

        for(var i = 0; i < this.rocks.length; i++) {
            var rock = this.rocks[i];
            for(var j = i + 1; j < this.rocks.length; j++) {
                var other = this.rocks[j];
                if(rock.colliding(other)) {
                    rock.handleCollision(other);
                    other.handleCollision(rock);
                    rock.handleCollisionPhysics(other);
                }
            }
            for(var ship of this.ships) {
                if(rock.colliding(ship)) {
                    if(ship.rock === rock) continue;
                    if(ship.rockPullTo || ship.rockPullOn) {
                        ship.magneticField(rock,
                            ship.rockPullTo, ship.rockPullOn);
                    }
                    rock.handleCollision(ship);
                    ship.handleCollision(rock);
                    rock.handleCollisionPhysics(ship);
                }
            }
        }

        for(var i = 0; i < this.ships.length; i++) {
            var ship = this.ships[i];
            for(var j = i + 1; j < this.ships.length; j++) {
                var other = this.ships[j];
                var pullTo = ship.shipPullTo + other.shipPullOn;
                var pullOn = ship.shipPullOn + other.shipPullTo;
                if(pullTo || pullOn) {
                    ship.magneticField(other, pullTo, pullOn);
                }
                if(ship.colliding(other)) {
                    ship.handleCollision(other);
                    other.handleCollision(ship);
                    ship.handleCollisionPhysics(other);
                }
            }
        }

        for(var i = 0; i < this.planets.length; i++) {
            var planet = this.planets[i];
            for(var j = i + 1; j < this.planets.length; j++) {
                var other = this.planets[j];
                if(planet.colliding(other)) {
                    planet.handleCollisionPhysics(other);
                    // Don't bother calling handleCollision() with Planets
                }
            }
        }

        for(var entityArray of this.entityArrays) {
            this.removeEntities(entityArray);
        }

        for(var star of this.stars) star.stepPhysics();
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.stepPhysics();
        }
    }
    removeEntities(entityArray) {
        for(var i = 0; i < entityArray.length; i++) {
            var entity = entityArray[i];
            if(entity._shouldRemove) {
                entity.cleanup();
                entityArray.splice(i, 1);
                i--;
            }
        }
    }
    innerRender(camera) {
        var canvas = this.innerCanvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if(RENDER_BOUNDARY) this.renderBoundary(canvas);

        for(var star of this.stars) star.render(canvas, camera);
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.render(canvas, camera);
        }
    }
    renderBoundary(canvas) {
        /* Draw a box around the field */
        var ctx = canvas.getContext('2d');
        var w = this.size.x;
        var h = this.size.y;
        ctx.strokeStyle = '#800';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, 0);
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        ctx.stroke();
    }
    render(canvas, camera) {
        this.innerRender(camera);
        var innerCanvas = this.innerCanvas;

        var ctx = canvas.getContext('2d');
        var x0 = canvas.width  / 2 - camera.pos.x;
        var y0 = canvas.height / 2 - camera.pos.y;

        x0 = modulo(x0, innerCanvas.width);
        if(x0 > 0) x0 -= innerCanvas.width;
        y0 = modulo(y0, innerCanvas.height);
        if(y0 > 0) y0 -= innerCanvas.height;

        for(var x = x0; x < canvas.width; x += innerCanvas.width) {
            for(var y = y0; y < canvas.height; y += innerCanvas.height) {
                ctx.drawImage(this.innerCanvas, x, y);
            }
        }
    }
}

class Particle {
    /* Represents a thing with position and velocity.
    It lives on a Field. */

    maxvel = 100;

    constructor(field) {
        this.field = field;
        this.pos = new Point();
        this.vel = new Point();
    }
    stepPhysics() {
        // Make sure velocity stays within this.maxvel
        var veldist = this.vel.dist();
        if(veldist > this.maxvel) this.vel.mul(this.maxvel / veldist);

        this.pos.addMul(this.vel, VELMUL).modulo(this.field.size);
    }
}

class Shape {
    /* Specifies a polygon to draw on a canvas.
    Each Picture can have multiple Shapes. */

    stroke = true;
    fill = true;
    close = true;

    constructor(points, props) {

        this.pos = new Point();
        this.rot = 0;
        this.points = points || [];

        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    static newPolygon(n_points, opts, props) {
        opts = opts || EMPTY;
        var rotVariance = getDefault(opts.rotVariance, 0);
        var radiusVariance = getDefault(opts.radiusVariance, 0);
        var rot = getDefault(opts.rot, 0);

        var points = [];
        for(var i = 0; i < n_points; i++) {
            var i_varied = i + Random.randNumber(-rotVariance, rotVariance);
            var point_rot = (Math.PI * 2) * i_varied / n_points + rot;
            var radius = 1 + Random.randNumber(-.5, .5) * radiusVariance;
            var point = new Point().addSpeed(radius, point_rot);
            points.push(point);
        }
        return new this(points, props);
    }
    clone() {
        var points = this.points.map(p => p.clone());
        var shape = new Shape(points);
        shape.stroke = this.stroke;
        shape.fill = this.fill;
        shape.close = this.close;
        shape.rot = this.rot;
        shape.pos = this.pos.clone();
        return shape;
    }
    flip() {
        for(var point of this.points) point.y = -point.y;
        return this;
    }
    add(other_point) {
        for(var point of this.points) point.add(other_point);
        return this;
    }
    addxy(x, y) {
        for(var point of this.points) point.addxy(x, y);
        return this;
    }
    mul(n) {
        for(var point of this.points) point.mul(n);
        return this;
    }
}

class Picture {
    radiusmul = 1;

    constructor(shapes, props) {
        this.shapes = shapes || [];
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    static newPolygon(n_points, opts, props) {
        var shape = Shape.newPolygon(n_points, opts);
        return new this([shape], props);
    }
    render(entity, canvas, camera, addx, addy) {
        var x0 = entity.pos.x + addx;
        var y0 = entity.pos.y + addy;
        var rot = entity.rot;
        var radius = entity.radius * this.radiusmul;

        // Point used for calculations
        var p = new Point();

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = entity.circleStrokeStyle;
        ctx.lineWidth = entity.circleLineWidth;
        ctx.fillStyle = entity.circleFillStyle;

        for(var shape of this.shapes) {
            var firstPoint = true;
            ctx.beginPath();
            for(var point of shape.points) {
                p.copy(point)
                    .rotate(shape.rot)
                    .add(shape.pos)
                    .rotate(rot)
                    .mul(radius)
                    .addxy(x0, y0);
                if(firstPoint) {
                    ctx.moveTo(p.x, p.y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            if(shape.close) ctx.closePath();
            if(shape.stroke) ctx.stroke();
            if(shape.fill) ctx.fill();
        }

    }
}

class Sprite extends Particle {
    /* Represents a Particle which can be drawn onto a <canvas>. */

    radius = 10 * RADIUSMUL;

    shouldRenderCircle = false;
    shouldRenderCircleLine = true;
    circleStrokeStyle = 'rgb(0,200,0)';
    circleFillStyle   = 'rgba(255,255,255,.15)';
    circleLineWidth = 2;

    shouldRenderTrail = false;
    trailStart = 0;
    trailEnd   = 1;
    trailCamVel = 1;
    trailStrokeStyle = 'rgba(255,150,0,25)';
    trailLineWidth = 2;

    picture = null; /* instanceof Picture */

    render(canvas, camera) {
        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var addx0 = this.pos.x < fieldx / 2? 0: -fieldx;
        var addy0 = this.pos.y < fieldy / 2? 0: -fieldy;

        for(var addx = addx0; addx <= addx0 + fieldx; addx += fieldx) {
            for(var addy = addy0; addy <= addy0 + fieldy; addy += fieldy) {
                if(this.shouldRenderTrail) {
                    this.renderTrail(canvas, camera, addx, addy);
                }
                if(this.shouldRenderCircle || RENDER_CIRCLES) {
                    this.renderCircle(canvas, camera, addx, addy);
                }
                if(this.picture) {
                    this.renderPicture(canvas, camera, addx, addy);
                }
            }
        }
    }
    renderPicture(canvas, camera, addx, addy) {
        this.picture.render(this, canvas, camera, addx, addy);
    }
    renderTrail(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var x1 = x0 - this.vel.x + camera.vel.x * this.trailCamVel;
        var y1 = y0 - this.vel.y + camera.vel.y * this.trailCamVel;
        var trail_x0 = linear(x0, x1, this.trailStart);
        var trail_y0 = linear(y0, y1, this.trailStart);
        var trail_x1 = linear(x0, x1, this.trailEnd);
        var trail_y1 = linear(y0, y1, this.trailEnd);

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.trailStrokeStyle;
        ctx.lineWidth = this.trailLineWidth;
        ctx.beginPath();
        ctx.moveTo(trail_x0, trail_y0);
        ctx.lineTo(trail_x1, trail_y1);
        ctx.stroke();
    }
    renderCircle(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var ctx = canvas.getContext('2d');

        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.fillStyle = this.circleFillStyle;
        renderCircle(ctx, x0, y0, this.rot, this.radius);
    }
}

class Star extends Sprite {
    radius = 3 * RADIUSMUL;
    shouldRenderTrail = true;
    trailLineWidth = 1;
    trailCamVel = 1;
}

class Key {
    /* Represents the state of a key on the keyboard */

    static KEYNAMES = 'udlrxy';

    constructor() {
        this.isDown = false;
        this.wasDown = false;
    }
    static createKeys() {
        var keys = {};
        for(var keyname of this.KEYNAMES) {
            keys[keyname] = new this();
        }
        return keys;
    }
    copy(other) {
        this.isDown = other.isDown;
        this.wasDown = other.wasDown;
    }
    down() {
        this.isDown = this.wasDown = true;
    }
    up() {
        this.isDown = false;
    }
    step() {
        this.wasDown = this.isDown;
    }
}

class Entity extends Sprite {
    /* An Entity is a sprite with "volition" -- it has virtual keys which
    can be pressed, and based on their state, it can move itself. */

    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .5;

    maxAge = -1;
    fadeWithAge = false;

    team = null;
    inheritTeamColor = true;

    SHOT_KEYNAMES = 'xy';
    shotClass = {
        x: null,
        y: null,
    };

    thrustEffectClass = ThrustEffect;
    thrustEffectSpeedMul = 2;
    thrustEffectVelMul = 1;
    thrustEffectEvery = 3;

    // Set to thrustEffectEvery each time a thrust Effect is created
    thrustEffectCooldown = 0;

    is_warping = false;
    warping_counter = 0;

    static maxhp = -1;

    addhp = 1 / 40;

    constructor(field) {
        super(field);

        this.hp = this.maxhp = this.constructor.maxhp;

        // addpos: entities can add to each others' addpos during step(),
        // and then addpos is added to pos during stepPhysics().
        // The purpose of this is to avoid modifying pos during step(),
        // because it's used in many calculations, so if it's modified
        // then the interactions between entities would be subtly different
        // depending on the order in which entities' step() is called...
        // Hope you get what I mean.
        this.addpos = new Point();

        this.rot = 0;
        this.rot_vel = 0;

        this.shotprops = {};
        for(var keyname of this.SHOT_KEYNAMES) {
            this.shotprops[keyname] = {
                cooldown: 0,
                n_shots: 0,
            };
        };

        this.keys = Key.createKeys();

        this.setTeam(TEAMS[0]);

        this.age = 0;
        this._shouldRemove = false;
    }
    getPlayer() {
        for(var player of this.field.game.players) {
            if(player.entity === this) return player;
        }
        return null;
    }
    setTeam(team) {
        this.team = team;
        if(this.inheritTeamColor) {
            this.lineStrokeStyle = team.strokeStyle;
            this.circleStrokeStyle = team.strokeStyle;
        }
    }
    heal(addhp) {
        if((this.hp += addhp) > this.maxhp) this.hp = this.maxhp;
    }
    damage(hp) {
        // hp < 0: this thing is invincible
        if(this.hp < 0) return;

        // hp === 0: this thing is already dead
        // (This check is important so we don't call this.die() multiple
        // times on the same thing, which can e.g. result in a LOT of rocks
        // being generated when this is a Rock)
        if(this.hp === 0) return;

        if(this instanceof Ship && NODAMAGE) return;

        this.hp -= hp * DAMAGEMUL;
        if(this.hp < 0) this.hp = 0;
        if(!this.hp) {
            this.die();
        }
    }
    die() {
        this.remove();
    }
    remove() {
        this._shouldRemove = true;
    }
    cleanup() {
        var game = this.field.game;

        for(var player of game.players) {
            if(player.entity !== this) continue;
            player.unsetEntity();
        }

        var camera = game.camera;
        if(camera.target === this) {
            camera.unsetTarget();
        }
    }
    step() {
        for(var keyname of this.SHOT_KEYNAMES) {
            var shotprops = this.shotprops[keyname];
            if(shotprops.cooldown > 0) shotprops.cooldown--;
        }

        if(this.thrustEffectCooldown > 0) this.thrustEffectCooldown--;

        if(this.is_warping) {
            var speed = this.thrustSpeed * 2 / Math.pow(this.velmul, 3);
            this.thrust(speed, this.rot);

            this.warping_counter++;
            if(this.warping_counter > WARP_AFTER_STEPS) {
                this.field.game.warp();
            }
        }

        this.handleKeys();
        for(var keyname of Key.KEYNAMES) {
            this.keys[keyname].step();
        }

        this.heal(this.addhp);

        this.age++;
        if(this.maxAge >= 0 && this.age >= this.maxAge) {
            this.die();
        }
    }
    stepPhysics() {
        this.vel.mul(this.velmul);
        this.rot += this.rot_vel * ROTVELMUL;
        this.rot_vel *= this.rotmul;

        super.stepPhysics();

        // Add addpos to pos, then reset addpos
        this.pos.add(this.addpos);
        this.addpos.set();
    }
    handleKeys() {
        if(this.keys.u.wasDown && !this.is_warping) {
            this.thrust(this.thrustSpeed, this.rot);
        }
        if(this.keys.d.wasDown && !this.is_warping) {
            this.thrust(this.reverseSpeed, this.rot + Math.PI);
        }
        if(this.keys.l.wasDown) {
            this.turn(this.rotspeed);
        }
        if(this.keys.r.wasDown) {
            this.turn(-this.rotspeed);
        }
        for(var keyname of this.SHOT_KEYNAMES) {
            var shotprops = this.shotprops[keyname];
            if(this.keys[keyname].wasDown && shotprops.cooldown === 0) {
                this.fire(keyname);
            }
        }
    }
    turn(rot) {
        this.rot_vel += rot;
    }
    thrust(speed, rot) {
        this.vel.addSpeed(speed, rot);
        if(this.thrustEffectCooldown === 0) {
            if(this.thrustEffectClass) {
                this.addThrustEffect(speed, rot + Math.PI);
            }
            this.thrustEffectCooldown += this.thrustEffectEvery;
        }
    }
    addThrustEffect(speed, rot) {
        var effect = this.field.addEffect(this.thrustEffectClass);
        effect.pos.copy(this.pos).addSpeed(this.radius, rot);
        effect.vel.copy(this.vel)
            .mul(this.thrustEffectVelMul)
            .addSpeed(speed * this.thrustEffectSpeedMul, rot);
        effect.rot = rot;
        return effect;
    }
    emitEffects(cls, n_effects, opts) {
        var speed_min = getDefault(opts.speed_min, 0);
        var speed_max = getDefault(opts.speed_max, 0);
        var velmul = getDefault(opts.velmul, 0);

        var effects = [];
        for(var i = 0; i < n_effects; i++) {
            var effect = this.field.addEffect(cls);
            effect.rot = this.rot;
            effect.pos.copy(this.pos);
            var speed = Random.randNumber(speed_min, speed_max);
            effect.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, Random.randRotation());
            effects.push(effect);
        }
        return effects;
    }
    emitShots(cls, n_shots, opts) {
        var rot_variance = getDefault(opts.rot_variance, 0);
        var rand_rot_variance = getDefault(opts.rand_rot_variance, 0);
        var speed_min = getDefault(opts.speed_min, 0);
        var speed_max = getDefault(opts.speed_max, 0);

        var velmul = .8;
        var shots = [];
        for(var i = 0; i < n_shots; i++) {
            var shot = this.field.addShot(cls);
            shot.ship = this.ship;
            shot.setTeam(this.team);
            shot.pos.copy(this.pos);
            shot.rot = this.rot
                + getRotVariance(i, n_shots) * rot_variance
                + Random.randNumber(-.5, .5) * rand_rot_variance;
            var speed = Random.randNumber(speed_min, speed_max);
            shot.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, shot.rot);
            shot.afterShotBy(this);
            shots.push(shot);
        }
        return shots;
    }
    fire(keyname) {
        var shotprops = this.shotprops[keyname];
        var cls = this.shotClass[keyname];
        if(!cls) return;

        var serial_i = shotprops.n_shots % cls.serialShots;
        for(var i = 0; i < cls.initialShots; i++) {
            var shot = this.shoot(cls, i, serial_i);
            shot.afterShotBy(this);
        }

        shotprops.cooldown += cls.cooldown;
        shotprops.n_shots++;
    }
    shoot(cls, shot_i, serial_shot_i) {
        // shot_i: index of this shot. E.g. if 3 are being fired at once,
        // this one might be 0, 1, or 2.

        var shot = this.field.addShot(cls);
        shot.ship = this;
        shot.setTeam(this.team);

        shot.rot = this.rot
            + getRotVariance(shot_i, cls.initialShots)
                * cls.initialRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * cls.serialRotVariance
            + Random.randNumber(-.5, .5)
                * cls.randomRotVariance;

        var posrot = 0
            + getRotVariance(shot_i, cls.initialShots)
                * cls.initialPosRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * cls.serialPosRotVariance
            + Random.randNumber(-.5, .5)
                * cls.randomPosRotVariance;

        var speed = cls.initialSpeed
            + Random.randNumber(-.5, 5)
                * cls.randomSpeedVariance;

        shot.pos.copy(this.pos)
            .addSpeed(this.radius, shot.rot + posrot);
        shot.vel.copy(this.vel)
            .mul(cls.initialVelMul)
            .addSpeed(speed, shot.rot);
        return shot;
    }
    colliding(other) {
        var d = this.pos.dist(other.pos, this.field.size);
        return d < this.radius + other.radius;
    }
    handleCollision(other) {
        /* We collided with another Entity! Now what?
        (Subclasses are free to answer that question in various ways...) */

        if(this.is_warping) {
            this.abortWarp();
        }
    }
    handleCollisionPhysics(other) {
        /* We collided with another Entity!
        We are both pushed away, and take on some of each others
        velocity.
        NOTE: unlike handleCollision, this method is only called once
        per step for any given pair of entities.
        Subclasses should not override this method. */

        /* r0: number between 0 and 1.
        The closer it is to 1, the larger this.radius is than other.radius.
        If .5, they are equal. */
        var r0 = this.radius / (this.radius + other.radius);
        var r1 = 1 - r0;

        /* Distance between this and other */
        var dist = this.pos.dist(other.pos, this.field.size);

        /* Avoid div by zero, eh */
        if(dist < .1) dist = .1;

        /* Target distance: this and other are just barely touching */
        var tdist = this.radius + other.radius;

        /* dx, dy: shortest vector from this to other, on the torus
        represented by this.field.size */
        var dx = moduloDiff(this.pos.x, other.pos.x, this.field.size.x);
        var dy = moduloDiff(this.pos.y, other.pos.y, this.field.size.y);

        /* mx, my: vector which would move this away from other, to where
        they are just barely touching */
        var mx = dx / dist * (dist - tdist);
        var my = dy / dist * (dist - tdist);

        var posmul = .5;
        this.addpos.x  += mx * r1 * posmul;
        this.addpos.y  += my * r1 * posmul;
        other.addpos.x -= mx * r0 * posmul;
        other.addpos.y -= my * r0 * posmul;

        var velmul = .7;
        this.vel.x  += mx * r1 * velmul;
        this.vel.y  += my * r1 * velmul;
        other.vel.x -= mx * r0 * velmul;
        other.vel.y -= my * r0 * velmul;
    }
    magneticField(other, pullTo, pullOn, opts) {
        opts = opts || EMPTY;
        pullTo = getDefault(pullTo, 1);
        pullOn = getDefault(pullOn, 1);
        var distmul = getDefault(opts.distmul, 1);
        var velmul = getDefault(opts.velmul, 9);

        /* r0: number between 0 and 1.
        The closer it is to 1, the larger this.radius is than other.radius.
        If .5, they are equal. */
        var r0 = this.radius / (this.radius + other.radius);
        var r1 = 1 - r0;

        /* Distance between this and other */
        var dist = this.pos.dist(other.pos, this.field.size);

        /* Avoid div by zero, eh */
        if(dist < .1) dist = .1;

        /* dx, dy: shortest vector from this to other, on the torus
        represented by this.field.size */
        var dx = moduloDiff(this.pos.x, other.pos.x, this.field.size.x);
        var dy = moduloDiff(this.pos.y, other.pos.y, this.field.size.y);

        /* mx, my: vector which moves this towards other */
        var m = Math.pow(dist * distmul, 2);
        var mx = dx * velmul / m;
        var my = dy * velmul / m;

        this.vel.x  += mx * r1 * pullTo;
        this.vel.y  += my * r1 * pullTo;
        other.vel.x -= mx * r0 * pullOn;
        other.vel.y -= my * r0 * pullOn;
    }
    beginWarp() {
        this.is_warping = true;
        this.vel.addSpeed(this.thrustSpeed * 5, this.rot);
    }
    abortWarp() {
        var warp_damage = 10;
        this.damage(warp_damage);

        this.emitEffects(SmokeEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.emitEffects(SparkEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });

        this.is_warping = false;
        this.warping_counter = 0;
    }
    render(canvas, camera) {
        var fade = 1;
        if(this.fadeWithAge && this.maxAge >= 0) {
            // maxFade: don't set fade lower than 1 - maxFade, that
            // would be too close to 0, so we wouldn't be able to see
            // the Entity
            var maxFade = .85;
            fade = 1 - (this.age / this.maxAge) * maxFade;
        }

        var ctx = canvas.getContext('2d');
        ctx.globalAlpha = fade;
        super.render(canvas, camera);
        ctx.globalAlpha = 1;
    }
    renderCircle(canvas, camera, addx, addy) {
        super.renderCircle(canvas, camera, addx, addy);
        if(this.shouldRenderCircleLine) {
            this.renderCircleLine(canvas, camera, addx, addy);
        }
    }
    renderCircleLine(canvas, camera, addx, addy) {
        /* Render a little line indicating this.rot */
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var p = new Point(this.radius).rotate(this.rot);
        var x1 = x0 + p.x;
        var y1 = y0 + p.y;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
    }
}

class Camera extends Particle {
    velmul = .7;
    springmul = .1;

    constructor(field) {
        super(field);
        this.target = null;
        this.pos.setMidpoint(field.size);
    }
    setTarget(target) {
        this.unsetTarget();
        this.target = target;
        this.pos.copy(target.pos);
    }
    unsetTarget() {
        if(!this.target) return;
        this.target = null;
    }
    step() {
        this.vel.mul(this.velmul);

        if(this.target) {
            var x0 = this.pos.x;
            var y0 = this.pos.y;
            var x1 = this.target.pos.x;
            var y1 = this.target.pos.y;
            this.vel.x += moduloDiff(x0, x1, this.field.size.x)
                * this.springmul;
            this.vel.y += moduloDiff(y0, y1, this.field.size.y)
                * this.springmul;
        }
    }
}

class Player {

    shipClass = null;

    constructor(game) {
        this.game = game;
        this.entity = null;
        this.team = TEAMS[0];
        this.keys = Key.createKeys();
    }
    setTeam(team) {
        this.team = team;
        if(this.entity) this.entity.setTeam(team);
    }
    setEntity(entity) {
        this.unsetEntity();
        this.entity = entity;
        entity.setTeam(this.team);
    }
    unsetEntity() {
        if(!this.entity) return;
        this.entity = null;
    }
    createShip(cls) {
        cls = cls || this.shipClass;
        this.shipClass = cls;

        var ship = this.game.addShip(cls);
        ship.pos.setRandomWithin(this.game.field.size);
        ship.rot = Random.randRotation();
        this.setEntity(ship);
        return ship;
    }
    step() {
        if(!this.entity) return;
        for(var keyname of Key.KEYNAMES) {
            var key = this.keys[keyname];
            this.entity.keys[keyname].copy(key);
            key.step();
        }
    }
}

class CPUPlayer extends Player {
    step() {
        if(Math.random() < .1) this.keys.u.down();
        if(Math.random() < .1) this.keys.u.up();
        if(Math.random() < .1) this.keys.d.down();
        if(Math.random() < .1) this.keys.d.up();
        if(Math.random() < .1) this.keys.l.down();
        if(Math.random() < .1) this.keys.l.up();
        if(Math.random() < .1) this.keys.r.down();
        if(Math.random() < .1) this.keys.r.up();
        if(Math.random() < .1) this.keys.x.down();
        if(Math.random() < .1) this.keys.x.up();
        if(Math.random() < .1) this.keys.y.down();
        if(Math.random() < .1) this.keys.y.up();
        super.step();
    }
}

class Game {

    constructor(canvas, progress) {
        canvas.addEventListener('keydown', this.onKeyDown.bind(this));
        canvas.addEventListener('keyup', this.onKeyUp.bind(this));

        this.canvas = canvas;
        this.intervalId = 0;
        this.players = [];
        this.menu = null;

        /* Hashmap from keyCode values to Key instances belonging to
        Player instances in this.players */
        this.keysByCode = {};

        this.progress = progress;
        this._createField();
    }
    _createField() {
        /* Create this.field and related things */

        // NOTE: need to set this.cpus before calling the Field constructor
        this.cpus = [];

        // destination: MapNode or MapEdge
        var destination = this.progress.getDestination();
        var template = destination.template;
        var size = template.getSize();

        // NOTE: field.populate needs to be a separate method from
        // field.constructor, so that field.populate can rely on
        // field.game.field being set.
        this.field = new Field(this, size);
        this.field.populate(template);

        this.camera = new Camera(this.field);
    }
    warp() {
        /* Warp to the next Field */

        this.progress.proceed();

        // Figure out which player's ship our camera is targeting.
        // This is a bit of a hack...
        var targetPlayer = null;
        for(var player of this.players) {
            if(player.entity === this.camera.target) {
                targetPlayer = player;
                break;
            }
        }

        this.camera.unsetTarget();

        this.field.cleanup();
        this._createField();

        for(var player of this.players) player.createShip();

        if(targetPlayer) this.camera.setTarget(targetPlayer.entity);
    }
    onKeyDown(event) {
        this.keyDown(event.keyCode);
        event.preventDefault();
    }
    onKeyUp(event) {
        this.keyUp(event.keyCode);
        event.preventDefault();
    }
    mapKey(key, keyCode) {
        this.keysByCode[keyCode] = key;
    }
    keyDown(keyCode) {
        if(this.menu) {
            this.menu.keyDown(keyCode);
        } else if(keyCode === KEY_ESCAPE) {
            this.setTitleMenu();
        } else if(keyCode === KEY_TAB) {
            this.setMapMenu();
        } else if(keyCode === KEY_WARP) {
            // HACK!
            var ship = this.camera.target;
            if(ship && !ship.is_warping) {
                ship.beginWarp();
            }
        } else {
            var key = this.keysByCode[keyCode];
            if(key) key.down();
        }
    }
    keyUp(keyCode) {
        if(this.menu instanceof MapMenu && keyCode === KEY_TAB) {
            this.unsetMenu();
        } else if(this.menu) {
            this.menu.keyUp(keyCode);
        } else {
            var key = this.keysByCode[keyCode];
            if(key) key.up();
        }
    }
    setMenu(cls) {
        this.unsetMenu();
        this.menu = new cls(this);

        // Unpress all keys so our ship doesn't fly in circles
        // or whatever while menu is open
        for(var key of Object.values(this.keysByCode)) key.up();
    }
    unsetMenu() {
        if(!this.menu) return;
        this.menu.cleanup();
        this.menu = null;
    }
    setTitleMenu() {
        this.setMenu(TitleMenu);
    }
    setMapMenu() {
        this.setMenu(MapMenu);
    }
    addShip(cls) {
        return this.field.addShip(cls);
    }
    addPlayer() {
        var player = new Player(this);
        this.players.push(player);
        return player;
    }
    addCPUPlayer() {
        var player = new CPUPlayer(this);
        this.cpus.push(player);
        return player;
    }
    step() {
        for(var player of this.players) player.step();
        for(var player of this.cpus) player.step();

        this.progress.map.step();
        this.field.step();
        this.camera.step();
        this.camera.stepPhysics();
    }
    render() {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.field.render(canvas, this.camera);
        if(this.menu) {
            this.menu.render();
        } else {
            var text = this.progress.getDestination().text;
            if(text && !HIDE_TEXT) text.render(canvas);
        }
        if(this.camera.target) this.renderEntityStats(this.camera.target);
    }
    renderEntityStats(entity) {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = 'normal bold 24px sans-serif';

        var x = canvas.width / 2;
        var y = canvas.height - 24;

        var text = parseInt(entity.hp) + ' / ' + entity.maxhp;
        ctx.fillText(text, x, y);
        y += 20;

        if(entity.rock) {
            var text = parseInt(entity.rock.hp) + ' / ' + entity.rock.maxhp;
            ctx.fillText(text, x, y);
            y += 20;
        }
    }
    renderTitle(title, subtitles) {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';

        var x = canvas.width / 2;
        var y = canvas.height / 4;

        ctx.font = 'normal bold 40px sans-serif';
        ctx.fillText(title, x, y);
        y += 40;

        if(subtitles) for(var subtitle of subtitles) {
            ctx.font = 'normal bold 20px sans-serif';
            ctx.fillText(subtitle, x, y);
            y += 20;
        }
    }
    intervalCallback() {
        /* Callback for use with setInterval */
        if(TIMING) var t0 = new Date();
        try {
            this.step();
            this.render();
        } catch(ex) {
            // Stop the same error from throwing repeatedly.
            // Don't set this.intervalId to 0 though, for debugging
            // purposes.
            clearInterval(this.intervalId);

            throw ex;
        }
        if(TIMING) {
            var t1 = new Date();
            console.log('TIMING: ' + String(t1 - t0));
        }
    }
    play(millis) {
        millis = getDefault(millis, 30);
        if(this.intervalId) clearInterval(this.intervalId);
        var callback = this.intervalCallback.bind(this);
        this.intervalId = setInterval(callback, millis);
    }
    pause() {
        if(!this.intervalId) return;
        clearInterval(this.intervalId);
        this.intervalId = 0;
    }
}

class Menu {
    constructor(game) {
        this.game = game;
    }
    cleanup() {
    }
    render() {
    }
    keyDown(keyCode) {
    }
    keyUp(keyCode) {
    }
}

class TitleMenu extends Menu {
    player = null;
    ship_class_i = 0;

    static ACTIONS = [
        {
            name: 'choose ship',
            subtitles: [
                'Choose your ship',
                '(Left/right arrow keys + Enter)',
            ],
        },
    ];

    constructor(game) {
        super(game);
        this.action_i = 0;

        if(game.players.length > 0) {
            // Hack: choose first player
            var player = game.players[0];
            this.setPlayer(player);
        }
    }
    setPlayer(player) {
        this.player = player;

        var ship = player.entity;
        this.ship_class_i = player.shipClass === null?
            0: SHIP_CLASSES.indexOf(player.shipClass);

        this.updateShipClass();
    }
    render() {
        var action = this.constructor.ACTIONS[this.action_i];
        this.game.renderTitle('Shipteroids', action.subtitles);
    }
    keyDown(keyCode) {
        if(!this.player) return;
        var action = this.constructor.ACTIONS[this.action_i];
        if(keyCode === KEY_U) {
            this.action_i = modulo(this.action_i - 1,
                this.constructor.ACTIONS.length);
        } else if(keyCode === KEY_D) {
            this.action_i = modulo(this.action_i + 1,
                this.constructor.ACTIONS.length);
        } else if(keyCode === KEY_L) {
            if(action.name === 'choose ship') {
                this.ship_class_i = modulo(this.ship_class_i - 1,
                    SHIP_CLASSES.length);
                this.updateShipClass();
            }
        } else if(keyCode === KEY_R) {
            if(action.name === 'choose ship') {
                this.ship_class_i = modulo(this.ship_class_i + 1,
                    SHIP_CLASSES.length);
                this.updateShipClass();
            }
        } else if(keyCode === KEY_ENTER) {
            if(action.name === 'choose ship') {
                this.game.unsetMenu();
            }
        }
    }
    updateShipClass() {
        var old_ship = this.player.entity;

        var cls = SHIP_CLASSES[this.ship_class_i];
        var ship = this.player.createShip(cls);

        if(old_ship) {
            ship.pos.copy(old_ship.pos);
            ship.vel.copy(old_ship.vel);
            ship.rot = old_ship.rot;

            old_ship.remove();
            // HACK: old_ship has only been marked for removal, we now
            // manually call the function which truly removes it.
            // We do this because otherwise, the old and new ships
            // coexist for one frame, which is enough time for them
            // to collide with each other...
            this.game.field.removeEntities(this.game.field.ships);
        } else {
            ship.pos.setMidpoint(this.game.field.size);
        }

        this.game.camera.setTarget(ship);
    }
}

class MapMenu extends Menu {

    node = null;
    edge_i = 0;

    constructor(game) {
        super(game);
        this.setNode(game.progress.node);
    }
    getEdge() {
        var n_edges = this.node.edges.length + this.node.backedges.length;
        if(!n_edges) return null;
        var edge_i = modulo(this.edge_i, n_edges);
        return (edge_i < this.node.edges.length)?
            this.node.edges[edge_i].forwardEdge:
            this.node.backedges[edge_i - this.node.edges.length].backEdge;
    }
    setNode(node) {
        this.node = node;
        this.edge_i = 0;
    }
    keyDown(keyCode) {
        if(keyCode === KEY_U) {
            var edge = this.getEdge();
            if(edge) this.setNode(edge.getNode1());
        } else if(keyCode === KEY_L) {
            this.edge_i--;
        } else if(keyCode === KEY_R) {
            this.edge_i++;
        } else if(keyCode === KEY_ENTER) {
            var progress = this.game.progress;
            if(
                progress.node === this.node &&
                (!progress.edge || progress.edgeDist)
            ) {
                progress.setEdge(this.getEdge());
            }
        }
    }
    render() {
        var canvas = this.game.canvas;
        var ctx = canvas.getContext('2d');
        var x0 = canvas.width / 2 - this.node.pos.x;
        var y0 = canvas.height / 2 - this.node.pos.y;

        var progress = this.game.progress;
        var map = progress.map;
        for(var node of map.nodes) {
            var x = x0 + node.pos.x;
            var y = y0 + node.pos.y;
            var radius = node.radius;
            var strokeStyle = node.strokeStyle;
            var fillStyle = node.fillStyle;
            var lineWidth = 2;

            if(node === progress.node) {
                radius += 4;
                lineWidth += 2;
            }
            if(node === this.node) {
                strokeStyle = '#fff';
            }

            ctx.strokeStyle = strokeStyle;
            ctx.fillStyle = fillStyle;
            ctx.lineWidth = lineWidth;
            renderCircle(ctx, x, y, 0, radius);

            for(var edge of node.edges) {
                var node2 = edge.node1;
                var x2 = x0 + node2.pos.x;
                var y2 = y0 + node2.pos.y;
                var strokeStyle = edge.strokeStyle;
                var lineWidth = 1;

                if(progress.edge && edge === progress.edge.edge) {
                    lineWidth += 2;
                }

                var thisEdge = this.getEdge();
                if(thisEdge && edge === thisEdge.edge) {
                    strokeStyle = '#fff';
                }

                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = strokeStyle;

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.closePath();
                ctx.stroke();
            }
        }
    }
}

class Effect extends Entity {
    fadeWithAge = true;
}

class SmokeEffect extends Effect {
    radius = 7 * RADIUSMUL;
    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgba(200,200,200,.2)';
    velmul = 1;
    maxAge = 20;
}

class FlameSmokeEffect extends SmokeEffect {
    radius = 5 * RADIUSMUL;
    circleFillStyle = 'rgba(200,150,100,.2)';
}

class ThrustEffect extends Effect {
    radius = 5 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(0,255,255,.7)';
    trailLineWidth = 3;
    maxAge = 20;
}

class SmokeThrustEffect extends SmokeEffect {
    radius = 3 * RADIUSMUL;
}

class SparkEffect extends Effect {
    radius = 3 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(255,255,0,.7)';
    trailLineWidth = 3;
    velmul = .95;
    maxAge = 20;
}

class Ship extends Entity {
    static maxhp = 100;

    shipPullTo = MAGNETIC_FIELD? 1: 0;
    shipPullOn = MAGNETIC_FIELD? 1: 0;

    rockPullTo = 0;
    rockPullOn = 0;

    die() {
        this.emitEffects(SmokeEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
    isAlly(other) {
        if(this === other || this.team === other.team) return true;
        return this._isAlly(other) || other._isAlly(this);
    }
    _isAlly(other) {
        // May be overridden by subclasses
        return false;
    }
}

class FighterShip extends Ship {
    radius = 7 * RADIUSMUL;
    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .45;

    static maxhp = 100;

    shotClass = {
        x: DoubleShot,
        y: DoubleMissileShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {stroke: false}),
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {fill: false, close: false}),
    ]);
}

class ScoutShip extends Ship {
    radius = 6 * RADIUSMUL;

    static maxhp = 100;
    wingsOut = true;

    shotClassWingsOut = {
        x: QuadrupleShot,
        y: null,
    };

    shotClassWingsIn = {
        x: RapidDoubleShot,
        y: null,
    };

    pictureWingsOut = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point( -.2,   -1.8),
            new Point( -.1,   -.75),
            new Point( 1.2,    0),
            new Point( -.1,    .75),
            new Point( -.2,    1.8),
        ]),
    ]);

    pictureWingsIn = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point(- .7,   -.75),
            new Point( 1.2,    0),
            new Point(- .7,    .75),
        ]),
    ]);

    constructor(field) {
        super(field);
        this._updateStats();
    }
    _updateStats() {
        if(this.wingsOut) {
            this.thrustSpeed = 2.25;
            this.reverseSpeed = 1.5;
            this.velmul = .85;
            this.rotspeed = Math.PI / 25;
            this.rotmul = .6;
            this.picture = this.pictureWingsOut;
            this.shotClass = this.shotClassWingsOut;
        } else {
            this.thrustSpeed = 2.75;
            this.reverseSpeed = 1.75;
            this.velmul = .95;
            this.rotspeed = Math.PI / 30;
            this.rotmul = .4;
            this.picture = this.pictureWingsIn;
            this.shotClass = this.shotClassWingsIn;
        }
    }
    step() {
        var wingsOut = !this.keys.y.wasDown;
        if(wingsOut != this.wingsOut) {
            this.wingsOut = wingsOut;
            this._updateStats();
        }
        super.step();
    }
}

class AssaultShip extends Ship {
    radius = 12 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = .5;
    velmul = .95;
    rotspeed = Math.PI / 26;
    rotmul = .65;

    static maxhp = 230;

    shotClass = {
        x: TripleShot,
        y: BlasterShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-.9,    0),
            new Point(-.4, -.95),
            new Point( .9,    0),
            new Point(-.4,  .95),
        ]),
    ]);
}

class TorchShip extends Ship {
    radius = 6 * RADIUSMUL;
    thrustSpeed = 1.45;
    reverseSpeed = 1;
    velmul = .95;
    rotspeed = Math.PI / 30;
    rotmul = .7;

    static maxhp = 80;

    shotClass = {
        x: FlameShot,
        y: MineShot,
    };

    thrustEffectClass = SmokeThrustEffect;
    thrustEffectVelMul = .2;
    thrustEffectEvery = 3;

    circleFillStyle = 'rgba(255,200,150,.35)';
    picture = new Picture([
        new Shape([
            new Point(-1.3,    0),
            new Point( 0  ,   -1),
            new Point( 1  ,    0),
            new Point( 0  ,    1),
        ]),
    ]);
}

class TurretShip extends Ship {
    radius = 6 * RADIUSMUL;
    thrustSpeed = .95;
    reverseSpeed = .55;
    velmul = .95;
    rotspeed = Math.PI / 40;
    rotmul = .7;

    static maxhp = 180;

    shotClass = {
        x: QuadrupleShot,
        y: QuadrupleMissileShot,
    };

    picture = new Picture([
        Shape.newPolygon(6),
        new Shape([
            new Point(0  , 0),
            new Point(1.2, 0),
        ], {fill: false, close: false}),
    ]);

    flagship = null;

    remove() {
        if(this.flagship) this.flagship.removeTurret(this);
        super.remove();
    }
    _isAlly(other) {
        if(
            other.flagship && this.flagShip &&
            other.flagship.isAlly(this.flagship)
        ) return true;
        return super._isAlly(other);
    }
}

class FlagShip extends Ship {
    radius = 10.5 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = 1.25;
    velmul = .9;
    rotspeed = Math.PI / 34;
    rotmul = .5;

    shotClass = {
        x: SingleShot,
        y: MissileShot,
    };

    static maxhp = 175;

    static max_turret_cooldown = 100;
    static max_turrets = 2;

    picture = new Picture([
        new Shape([
            new Point(-.9, -.3),
            new Point(-.7, -.5),
            new Point( .9, -.5),
            new Point( .9,  .5),
            new Point(-.7,  .5),
            new Point(-.9,  .3),
        ]),
    ], {radiusmul: 1.2});

    constructor(field) {
        super(field);

        this.turrets = [];
        this.turret_cooldown = this.constructor.max_turret_cooldown;
    }
    remove() {
        // We iterate over a copy of this.turrets, because when we kill
        // each turret, it removes itself from this.turrets, which would
        // mess up an iteration over this.turrets.
        var turrets = this.turrets.slice();
        for(var turret of turrets) turret.die();
        super.remove();
    }
    addTurret() {
        var turret = this.field.addShip(TurretShip);
        turret.hp = turret.maxhp = 60;
        turret.setTeam(this.team);
        turret.pos.copy(this.pos)
            .addSpeed(this.radius + turret.radius, this.rot);
        turret.vel.copy(this.vel);
        turret.flagship = this;

        this.turrets.push(turret);
        this.turret_cooldown = this.constructor.max_turret_cooldown;
        return turret;
    }
    removeTurret(turret) {
        var i = this.turrets.indexOf(turret);
        this.turrets.splice(i, 1);
        turret.flagship = null;
    }
    _isAlly(other) {
        if(this.turrets.indexOf(other) >= 0) return true;
        return super._isAlly(other);
    }
    step() {
        super.step();
        for(var turret of this.turrets) {
            for(var keyname of 'xy') {
                var key = this.keys[keyname];
                turret.keys[keyname].copy(key);
            }
            for(var keyname of 'lrud') {
                var key = this.keys[keyname];
                turret.keys[keyname].up(key);
            }

            var targetAngle = turret.pos.angle(this.pos, this.field.size);
            turret.rot_vel += rotDiff(turret.rot, targetAngle) * .2;

            var dist = this.pos.dist(turret.pos, this.field.size);
            var mindist = 45 * RADIUSMUL;
            var maxdist = 65 * RADIUSMUL;
            if(dist < mindist) {
                turret.keys.u.down();
            } else if(dist > maxdist) {
                turret.keys.d.down();
            }
        }
        if(this.turrets.length < this.constructor.max_turrets) {
            if(this.turret_cooldown) {
                this.turret_cooldown--;
            } else {
                this.addTurret();
            }
        }
    }
}

class MoleShip extends Ship {
    radius = 6 * RADIUSMUL;
    thrustSpeed = 2.05;
    reverseSpeed = 1.15;
    velmul = .95;
    rotspeed = Math.PI / 30;
    rotmul = .6;

    static maxhp = 60;

    shotClass = {
        x: ShortDoubleShot,
        y: null,
    };

    picture = new Picture([
        new Shape([
            new Point(-.7, -.3),
            new Point(-.4, -.9),
            new Point( .9, -.5),
            new Point(-.1,   0),
            new Point( .9,  .5),
            new Point(-.4,  .9),
            new Point(-.7,  .3),
        ]),
    ]);

    rock = null;

    remove() {
        if(this.rock) this.exitRock();
        super.remove();
    }
    step() {
        var rock = this.rock;
        if(rock) {
            var fieldx = this.field.size.x;
            var fieldy = this.field.size.y;

            var dx = moduloDiff(this.pos.x, rock.pos.x, fieldx);
            var dy = moduloDiff(this.pos.y, rock.pos.y, fieldy);

            this.addpos.x += dx * .2;
            this.addpos.y += dy * .2;
            this.vel.x += dx * .1;
            this.vel.y += dy * .1;

            rock.rot_vel *= .95;
            rock.vel.mul(this.velmul);

            rock.heal(1 / 20);
        }
        super.step();
    }
    fire(keyname) {
        if(keyname === 'y') {
            var shotprops = this.shotprops[keyname];
            if(this.rock) {
                this.addpos.addSpeed(this.rock.radius * .8, this.rot);
                this.vel.addSpeed(this.rock.radius * .2, this.rot);
                this.exitRock();
                shotprops.cooldown += 10;
            } else {
                var foundRock = null;
                for(var rock of this.field.rocks) {
                    if(!this.colliding(rock)) continue;
                    if(rock.mole) continue;
                    foundRock = rock;
                    break;
                }
                if(foundRock) {
                    this.enterRock(foundRock);
                    shotprops.cooldown += 30;
                }
            }
        } else {
            super.fire(keyname);
        }
    }
    shoot(cls, shot_i, serial_shot_i) {
        var shot = super.shoot(cls, shot_i, serial_shot_i);

        var rock = this.rock;
        if(rock) {
            shot.addpos.addSpeed(rock.radius - this.radius, this.rot);
        }

        return shot;
    }
    thrust(speed, rot) {
        var rock = this.rock;
        if(rock) {
            var mul = DEFAULT_ROCK_RADIUS / rock.radius;
            if(mul > 1) mul = 1;
            rock.vel.addSpeed(speed * mul, rot);
        }
        super.thrust(speed, rot);
    }
    turn(rot) {
        var rock = this.rock;
        if(rock) {
            var mul = DEFAULT_ROCK_RADIUS / rock.radius;
            if(mul > 1) mul = 1;
            rock.rot_vel += rot * mul * .3;
        }
        super.turn(rot);
    }
    enterRock(rock) {
        rock.mole = this;
        this.rock = rock;
        this.emitEffects(SparkEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
    }
    exitRock() {
        this.rock.mole = null;
        this.rock = null;
    }
}

class EngineerShip extends Ship {
    radius = 6 * RADIUSMUL;
    thrustSpeed = 1.15;
    reverseSpeed = .8;
    velmul = .9;
    rotspeed = Math.PI / 50;
    rotmul = .85;

    static maxhp = 60;

    thrustEffectClass = null;

    shotClass = {
        x: DoubleShot,
        y: null,
    };

    picture = new Picture([
        Shape.newPolygon(5).addxy(-.3, 0).mul(.9),
        Shape.newPolygon(4).addxy(1.2, 0).mul(.5),
    ]);
}

class ChomperShip extends Ship {
    radius = 14 * RADIUSMUL;
    thrustSpeed = 3.25;
    reverseSpeed = 2.5;
    velmul = .85;
    rotspeed = Math.PI / 30;
    rotmul = .65;

    addhp = 1 / 10;

    static maxhp = 250;

    shotClass = {
        x: ChompShot,
        y: null,
    };

    constructor(field) {
        super(field);

        this.chomp_thrust = this.thrustSpeed * 10;
        this.chomp_cooldown = 32;

        // Set up this.picture with Shapes assigned to properties of
        // this so that we can easily animate them
        this.left_arm = new Shape([
            new Point(  0, -.4),
            new Point( .2, -.9),
            new Point(  1, -.4),
        ]);
        this.right_arm = this.left_arm.clone().flip();
        this.picture = new Picture([
            new Shape([
                // Body
                new Point(  0, -.7),
                new Point(-.8,   0),
                new Point(  0,  .7),
            ]),
            this.left_arm,
            this.right_arm,
        ]);
    }
    step() {
        super.step();
        this.animate();
    }
    animate() {
        var i = this.shotprops.x.cooldown / this.chomp_cooldown;

        // NOTE: arm_addx, arm_addy seem to have less effect than I expected.
        // Bug in Picture.render?..
        var arm_addx = 1 * i;
        var arm_addy = .5 * i;

        var arm_rot = -Math.PI / 2 * i;

        this.left_arm.pos.set(arm_addx, arm_addy);
        this.left_arm.rot = arm_rot;

        this.right_arm.pos.set(arm_addx, -arm_addy);
        this.right_arm.rot = -arm_rot;
    }
    turn(rot) {

        // This is kind of cool, but doesn't quite feel right.
        //var speed = rot * this.thrustSpeed * 4;
        //this.vel.addSpeed(speed, this.rot + Math.PI / 2);

        super.turn(rot);
    }
    fire(keyname) {
        if(keyname === 'y') {
            this.thrust(this.chomp_thrust, this.rot);

            var shotprops = this.shotprops[keyname];
            shotprops.cooldown += this.chomp_cooldown;
        } else {
            super.fire(keyname);
        }
    }
}

class Shot extends Entity {

    static initialShots = 1;
    static serialShots = 1;
    // "rot variance": difference in radians between the rot of first
    // and last Shot instance produced by firing this Shot type
    static initialRotVariance = 0;
    static serialRotVariance = 0;
    static randomRotVariance = 0;
    static initialPosRotVariance = 0;
    static serialPosRotVariance = 0;
    static randomPosRotVariance = 0;

    static initialSpeed = 20;
    static initialVelMul = 1;
    static randomSpeedVariance = 0;

    // How hard we move things we hit
    hitVelMul = .1;

    // How much damage we do
    hitDamage = 10;

    // If < 1, the amount of damage we do goes down over time
    hitDamageAgeMul = 1;

    hitEffectClass = SparkEffect;

    static cooldown = 4;

    constructor(field) {
        super(field);

        // The Ship who shot us out
        this.ship = null;
    }
    afterShotBy(entity) {
        // Bit of a hack, called by Entity.shoot, Entity.emitShots, etc.
        // Just lets subclasses of Shot customize themselves a bit based
        // on the entity which shot them.
    }
    step() {
        super.step();
        this.hitDamage *= this.hitDamageAgeMul;
    }
    hit(other) {
        other.vel.addMul(this.vel, this.hitVelMul);
        other.damage(this.hitDamage);
        this.emitEffects(this.hitEffectClass, 2, {
            speed_min: 2,
            speed_max: 4,
            velmul: .75,
        });
        this.die();
    }
}

class SingleShot extends Shot {
    radius = 3 * RADIUSMUL;
    velmul = .95;
    static initialSpeed = 23;
    hitDamage = 10;
    hitDamageAgeMul = .95;
    shouldRenderTrail = true;
    static cooldown = 4;
    maxAge = 40;
    fadeWithAge = true;
}

class ShortSingleShot extends SingleShot {
    static initialSpeed = 17;
    static cooldown = 3;
}

class RapidSingleShot extends SingleShot {
    radius = 4 * RADIUSMUL;
    static initialSpeed = 26;
    hitDamage = 6;
    hitDamageAgeMul = .98;
    static cooldown = 2;
    hitVelMul = .05;
    trailStrokeStyle = '#aaa';
    trailEnd = .3;
}

class RapidDoubleShot extends RapidSingleShot {
    static serialShots = 2;
    static serialPosRotVariance = Math.PI / 2;
}

class DoubleShot extends SingleShot {
    static serialShots = 2;
    static serialRotVariance = Math.PI / 18;
}

class ShortDoubleShot extends ShortSingleShot {
    static serialShots = 2;
    static serialRotVariance = Math.PI / 26;
    static serialPosRotVariance = Math.PI / 3;
}

class TripleShot extends SingleShot {
    static initialShots = 3;
    static serialShots = 1;
    static initialRotVariance = Math.PI / 13;
    static serialRotVariance = 0;
    static cooldown = 7;
}

class QuadrupleShot extends SingleShot {
    static serialShots = 4;
    static serialRotVariance = Math.PI / 20;
    static serialPosRotVariance = Math.PI;
    static cooldown = 2;
}

class BlasterShot extends Shot {
    radius = 10 * RADIUSMUL;
    static initialSpeed = 14;
    static initialVelMul = .7;
    velmul = 1;

    hitVelMul = .5;
    hitDamage = 15;

    maxAge = 20;
    static cooldown = 32;

    picture = Picture.newPolygon(6);

    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.emitShots(SingleShot, 5, {
            rot_variance: Math.PI / 4,
            speed_min: 10,
            speed_max: 10,
        });
        super.die();
    }
}

class MissileShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 10;
    static initialVelMul = .2;
    velmul = .9;

    thrustSpeed = 3;

    hitVelMul = .45;
    hitDamage = 10;

    maxAge = 30;
    fadeWithAge = false;
    static cooldown = 24;

    shouldRenderTrail = true;
    trailCamVel = 0;

    picture = new Picture([
        new Shape([
            new Point(-1.2, -.3),
            new Point( 1.2, -.3),
            new Point( 1.2,  .3),
            new Point(-1.2,  .3),
        ]),
    ]);

    step() {
        if(this.age < this.maxAge / 2) {
            this.vel.addSpeed(this.thrustSpeed, this.rot);
        } else {
            this.shouldRenderTrail = false;
        }
        super.step();
    }
    afterShotBy(entity) {
        super.afterShotBy(entity);
        this.rot_vel = rotDiff(this.rot, entity.rot) * 2;
    }
    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class DoubleMissileShot extends MissileShot {
    static initialShots = 2;
    static initialRotVariance = Math.PI / 9;
    static initialPosRotVariance = Math.PI / 3;
}

class QuadrupleMissileShot extends MissileShot {
    static serialShots = 4;
    static serialRotVariance = Math.PI / 4;
    static serialPosRotVariance = Math.PI;
    static cooldown = 8;
}

class FlameShot extends Shot {
    static randomRotVariance = Math.PI / 20;
    static randomPosRotVariance = Math.PI / 4;
    static randomSpeedVariance = 1.5;

    static initialShots = 2;
    static initialRotVariance = Math.PI / 9;
    static initialSpeed = 10;
    static initialVelMul = .8;

    hitVelMul = 0;
    hitDamage = 3;
    hitDamageAgeMul = .975;
    hitEffectClass = FlameSmokeEffect;

    static cooldown = 1;

    radius = 3 * RADIUSMUL;
    velmul = .95;
    maxAge = 25;
    fadeWithAge = true;

    picture = new Picture([
        Shape.newPolygon(3, null, {stroke: false}),
        Shape.newPolygon(3, {rot: Math.PI * 2 / 6}, {stroke: false}),
    ]);
    circleFillStyle = 'rgba(255,180,0,.25)';

    constructor(field) {
        super(field);
        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    step() {
        super.step();
        this.radius += .2 * RADIUSMUL;
    }
}

class MineShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 0;
    velmul = .9;

    hitDamage = 8;

    maxAge = 300;
    static cooldown = 32;

    picture = Picture.newPolygon(6);
    circleFillStyle = 'rgba(255,180,0,.4)';
    circleLineWidth = 3;

    die() {
        var shots = this.emitShots(FlameShot, 5, {
            rot_variance: Math.PI * 2,
            rand_rot_variance: Math.PI / 3,
            speed_min: 3,
            speed_max: 6,
        });

        super.die();
    }
}

class ChompShot extends Shot {
    radius = 10 * RADIUSMUL;
    static initialSpeed = 24;
    static initialVelMul = 1;
    velmul = .9;

    hitVelMul = .325;
    hitDamage = 10;

    maxAge = 5;
    static cooldown = 6;

    circleStrokeStyle = 'rgba(255,150,0,.4)';
    inheritTeamColor = false;

    picture = new Picture([
        new Shape([
            new Point(-.4, -.85),
            new Point( .9,    0),
            new Point(-.4,  .85),
        ], {fill: false, close: false}),
    ]);

    hit(other) {
        var velmul = .35;
        var rot_velmul = .3;
        other.vel.mul(velmul);
        other.rot_vel *= rot_velmul;

        super.hit(other);
    }
}

class Rock extends Entity {

    circleStrokeStyle = '#987';
    velmul = 1;
    rotmul = 1;

    mole = null;

    constructor(field, radius) {
        super(field);

        radius = getDefault(radius, DEFAULT_ROCK_RADIUS);
        this.radius = radius;

        var default_hp = 30;
        this.hp = this.maxhp = parseInt(
            default_hp * radius / DEFAULT_ROCK_RADIUS);

        var n_points = Random.randIntInclusive(5, 10);
        this.picture = Picture.newPolygon(n_points,
            {rotVariance: .5, radiusVariance: .1});

        this.pos.setRandomWithin(field.size);

        var speed = Random.randNumber(3.5);
        this.vel.setSpeed(speed, Random.randRotation());

        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    damage(hp) {
        if(this.mole) hp /= 2;
        super.damage(hp);
    }
    remove() {
        if(this.mole) this.mole.exitRock();
        super.remove();
    }
    die() {
        var min_radius = 9 * RADIUSMUL;
        if(this.radius >= min_radius) {
            var velmul = .75;
            var n_rocks = 2;
            var addposrot = Random.randRotation();
            for(var i = 0; i < n_rocks; i++) {
                var rock = this.field.addRock(
                    this.constructor, this.radius * .65);
                var posrot = (i / n_rocks) * Math.PI * 2 + addposrot;
                var posradius = this.radius;
                var radiusvelmul = .1;
                rock.pos.copy(this.pos)
                    .addSpeed(posradius, posrot);
                rock.vel.addMul(this.vel, velmul)
                    .addSpeed(posradius * radiusvelmul, posrot);
            }
        }
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class Planet extends Entity {

    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgb(0,0,255)';

    velmul = 1;
    rotmul = 1;

    constructor(field) {
        super(field);

        this.radius = Random.randNumber(50,200);
        this.circleFillStyle = this.createFillGradient();

        this.pos.setRandomWithin(field.size);

        var speed = Random.randNumber(6,9) * VELMUL;
        this.vel.setSpeed(speed, Random.randRotation());

        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    createFillGradient() {
        var canvas = this.field.game.canvas;
        var ctx = canvas.getContext('2d');

        var innerPosSpeed = Random.randNumber(this.radius);
        var innerPos = new Point()
            .addSpeed(innerPosSpeed, Random.randRotation());

        var gradient = ctx.createRadialGradient(
            // x0, y0, r0
            innerPos.x, innerPos.y, 0,
            // x1, y1, r1
            0, 0, this.radius);

        var c0 = Random.randColor(50, 150);
        var c1 = Random.randColor(50, 100);
        var c2 = Random.randColor(100);

        gradient.addColorStop(.5, c0);
        gradient.addColorStop(.75, c1);
        gradient.addColorStop(1, c2);
        return gradient;
    }
}


var SHIP_CLASSES = [
    FighterShip,
    ScoutShip,
    AssaultShip,
    TorchShip,
    TurretShip,
    FlagShip,
    MoleShip,
    //EngineerShip,
    ChomperShip,
];


var canvas = document.getElementById('canvas');

var defaultMap = (function() {
    var map = new Map();

    var tutorial1 = map.addNode(
        new FieldTemplate(),
        new Text('Controls', [
            'Left/right: turn left/right',
            'Up/down   : thrust/reverse',
            'Spacebar  : fire weapon / use ability #1',
            'Shift     : fire weapon / use ability #2',
            'Escape    : open menu',
            'W         : attempt to warp to next area',
        ]),
    );

    var basicTemplate = new FieldTemplate();
    var fireTemplate = new FieldTemplate();
    var rockTemplate = new FieldTemplate();

    var basicNode = map.addNode(basicTemplate);
    var fireNode = map.addNode(fireTemplate);
    var rockNode = map.addNode(rockTemplate);

    tutorial1.addEdge(basicNode);
    basicNode.addEdge(fireNode, 4, fireTemplate);
    basicNode.addEdge(rockNode, 5, rockTemplate);

    map.startNode = tutorial1;
    return map;
})();
var game = new Game(canvas, new MapProgress(defaultMap));

var player = game.addPlayer();
game.mapKey(player.keys.u, KEY_U);
game.mapKey(player.keys.d, KEY_D);
game.mapKey(player.keys.l, KEY_L);
game.mapKey(player.keys.r, KEY_R);
game.mapKey(player.keys.x, KEY_SPACE);
game.mapKey(player.keys.y, KEY_SHIFT);

game.setTitleMenu();

game.play();
canvas.style.border = 'none';
canvas.focus();


</script>
</body>
</html>