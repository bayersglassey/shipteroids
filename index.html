<html>
<head>
<title>Shipteroids!</title>
<style>
body {
    color: #fff;
    background-color: #000;
}
.canvas {
    border: solid 1px #0f0;
    display: inline;
}
.canvas-container {
    width: 100%;
    text-align: center;
}
.controls {
    width: 100%;
    text-align: center;
}
.controls-table {
    margin: auto;
}
</style>
</head>
<body>
<div class="controls">
    <h2>&#x25BC; SCROLL DOWN TO SEE CONTROLS &#x25BC;</h2>
</div>
<div class="canvas-container">
    <canvas id="canvas" class="canvas" width=700 height=700 tabindex=-1></canvas>
</div>
<div class="controls">
    <h2>&#x25BC; SCROLL DOWN TO SEE CONTROLS &#x25BC;</h2>
    <table class="controls-table">
        <tr><td><b>Left / right</b></td><td>Turn left / right</td></tr>
        <tr><td><b>Up / down</b></td><td>Thrust / reverse</td></tr>
        <tr><td><b>Spacebar</b></td><td>Fire weapon / use ability #1</td></tr>
        <tr><td><b>Shift</b></td><td>Fire weapon / use ability #2</td></tr>
        <tr><td><b>W</b></td><td>Attempt to warp to next area</td></tr>
        <tr><td><b>Tab</b></td><td>Hold to view map</td></tr>
        <tr><td><b>Escape</b></td><td>Open menu</td></tr>
    </table>
</div>

<script>

'use strict';


/******************************
* IDEAS:
*
* Really big ship (MotherShip) with "gravity"
*
* Slightly better AI: each CPUPlayer can have 1 target, which is rendered
* as a line. By default, when cpu player is hit, it targets the shot's ship.
* cpu should probably understand the range of its weapons.
* (E.g. crab had better try to get close, others should try to stay within
* a certain range but not too close, etc)
* Some ships override the default behaviour, e.g. Torch tries to lay mines
* within a small area and stay out of trouble.
* It should be possible for cpu to target rocks, but idunno when they would.
* (Moles and Suits should know to try and get into/onto a rock, so they
* target them but don't shoot when targeting a rock.)
*
* TODO:
*
* MapMenu: your destination (node1) needs to be highlighted, and it needs to
* be clear which direction you're travelling.
*
* When a Field is populated, we should make sure things don't overlap,
* otherwise everything will start immediately rocketing around the screen.
*
* Should be able to aim camera at a player (camera.targetPlayer) so we don't
* need maps to call setTarget explicitly...
*
* When a player loses their ship, reset players' keys (otherwise e.g. they can
* still be holding Up while you're in the menu choosing ships)
* (Is this... already done?)
*
* Seems like one end of RopeShot can get stuck to something and live forever...
*
* How can we add upgrades?
* Do we add shops?
*   * Do they show up on the Field?
*   * Do you just warp to them?
*     * I kind of like that. So add special ShopMapNode, or MapNode.shop,
*       or something.
* Can you mine planets? Maybe some ships are better at it?
*   * What is the mechanism?.. land on the planet?.. just hover over it?..
*   * Do planets shrink as they are mined? Or how do you tell how much
*     stuff is left?..
*
******************************/


// an empty Object (do not modify!!)
var EMPTY = {};


// query params
var PARAMS = new URLSearchParams(window.location.search);
function getParam(name, default_value) {
    var value = PARAMS.get(name);
    return value === null? default_value: value;
}
function getBoolParam(name) {
    return Boolean(getParam(name, false));
}

// debug stuff
var DEBUG = getBoolParam('debug');
var TIMING = getBoolParam('timing');
var RENDER_CIRCLES = getBoolParam('render_circles');
var RENDER_BOUNDARY = getBoolParam('render_boundary');
var HIDE_TEXT = getBoolParam('hide_text');
var NODAMAGE = getBoolParam('nodamage');
var NOVIBRATE = getBoolParam('novibrate');
var VIBRATE = !NOVIBRATE;

// physics tweaking stuff
var VELMUL = .7;
var MAXSPEED = 80;
var ROTVELMUL = .5;
var RADIUSMUL = 2;
var DAMAGEMUL = 1;
var DEFAULT_ROCK_RADIUS = 10 * RADIUSMUL;
var MIN_ROCK_RADIUS = 9 * RADIUSMUL;
var WARP_RADIUS = 10 * RADIUSMUL;
var WARP_AFTER_STEPS = 30;
var WARP_RADIUS = 10;
var MAX_WARP_ADDRADIUS = 16;
var MAX_ROT_VEL = Math.PI / 5;
var DEFAULT_ADDHP = 1 / 40;
var DEFAULT_ADDFUEL = 1 / 80;
var DEFAULT_MAXFUEL = 100;
var MAXGOLD = 100;
var WARP_COLLISION_DAMAGE = 10;
var WARP_FUEL = 10;

// Game/field default options
var DEFAULT_FIELD_WIDTH  = 1000;
var DEFAULT_FIELD_HEIGHT = 1000;
var DEFAULT_STARS_PER    = 1 /    5000;
var DEFAULT_ROCKS_PER    = 1 /  300000;
var DEFAULT_PLANETS_PER  = 1 / 1000000;
var DEFAULT_SHIPS_PER    = 1 /  500000;
var DEFAULT_STAR_SPEED = 3;
var DEFAULT_ENERGY_CHANCE = .05;
var DEFAULT_FUEL_CHANCE = .1;
var DEFAULT_GOLD_CHANCE = .2;

// keyCode values
var KEY_U = 38;
var KEY_D = 40;
var KEY_L = 37;
var KEY_R = 39;
var KEY_ENTER = 13;
var KEY_SPACE = 32;
var KEY_SHIFT = 16;
var KEY_ESCAPE = 27;
var KEY_WARP = 87; // 'W'
var KEY_TAB = 9;

// Gamepad button indices for HTML5 Gamepad.buttons
// (Assumes the "standard mapping",
// see: https://w3c.github.io/gamepad/#remapping)
var GAMEPAD_BUTTONS = {
    12: 'u',
    13: 'd',
    14: 'l',
    15: 'r',
     0: 'u',
     1: 'u',
     2: 'd',
     3: 'd',
     5: 'x',
     7: 'x',
     4: 'y',
     6: 'y',
};

// Axis threshold: value between 0 and 1, past which we
// consider an HTML5 Gamepad axis (e.g. joystick) to be
// "pressed".
// That is, each value in Gamepad.axes can be between -1 and 1,
// but we want to convert that into boolean key presses for "left",
// "right", "up", "down".
var GAMEPAD_AXIS_THRESHOLD = .5;


class OrderedDictEntry {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
class OrderedDict {
    entries = []; // Array of OrderedDictEntry

    size() {
        return this.entries.length;
    }
    set(key, value) {
        var entry = this.getEntry(key);
        if(entry) {
            entry.value = value;
        } else {
            var entry = new OrderedDictEntry(key, value);
            this.entries.push(entry);
        }
        return this;
    }
    indexOf(value) {
        for(var i = 0; i < this.entries.length; i++) {
            var entry = this.entries[i];
            if(entry.value === value) return i;
        }
        return -1;
    }
    getEntry(key) {
        for(var entry of this.entries) {
            if(entry.key === key) return entry;
        }
        return null;
    }
    get(key) {
        var entry = this.getEntry(key);
        if(entry) return entry.value;
        return null;
    }
    getAt(i) {
        var entry = this.entries[i];
        if(entry) return entry.value;
        return null;
    }
    getKeys() {
        return this.entries.map(entry => entry.key);
    }
    getValues() {
        return this.entries.map(entry => entry.value);
    }
}

// teams
class Team {
    constructor(name, color) {
        this.name = name;
        this.color = color;
    }
}
var TEAMS = new OrderedDict()
    .set('green', new Team('Green', '#0f0'))
    .set('red', new Team('Red', '#f33'))
    .set('blue', new Team('Blue', '#33f'))
    .set('yellow', new Team('Yellow', '#ff0'))
;


function linear(x0, x1, n) {
    /* Assumes: 0 <= n <= 1 */
    return x0 + (x1 - x0) * n;
}

function getDefault(value, default_value) {
    return value === undefined? default_value: value;
}

function range(a, b) {
    if(b === undefined) {
        b = a;
        a = 0;
    }
    var values = [];
    for(var i = a; i < b; i++) values.push(i);
    return values;
}

function modulo(x, n) {
    /* Returns the modulus of x / n.
    Expects n > 0.

    Example:

         x | n | modulo(x, n)
        ---+---+--------------
         -3| 3 | 0
         -2| 3 | 1
         -1| 3 | 2
          0| 3 | 0
          1| 3 | 1
          2| 3 | 2
          3| 3 | 0
    */
    return ((x % n) + n) % n;
}

function getRotVariance(i, n) {
    // rotVariance: number between -.5 and .5
    if(n <= 1) return 0;
    return i / (n - 1) - .5;
}

function moduloDiff(x0, x1, w) {
    /* Difference between two numbers on the "wrapped" interval between
    0 and w.
    (Distance from x0 to x1.) */
    x0 = modulo(x0, w);
    x1 = modulo(x1, w);
    var diff = x1 - x0;

    if(diff < -w/2)return diff + w;
    else if(diff > w/2)return diff - w;
    else return diff;
}

function rotDiff(r0, r1) {
    return moduloDiff(r0, r1, Math.PI * 2);
}

function renderCircle(ctx, x0, y0, rot, radius, opts) {
    opts = opts || EMPTY;
    var scale = getDefault(opts.scale, 1);
    var scalex = getDefault(opts.scalex, scale);
    var scaley = getDefault(opts.scaley, scale);
    ctx.save();
    {
        ctx.translate(x0, y0);
        ctx.scale(scalex, scaley);
        ctx.rotate(rot);
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fill();
    }
    ctx.restore();
}

class Text {
    /* Text which can be rendered onto a canvas. */

    constructor(title, lines) {
        this.title = title;
        this.lines = lines;
    }
    clone() {
        return new this.constructor(this.title, this.lines.slice());
    }
    render(canvas) {
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';

        var x = 16;
        var y = 20;

        ctx.font = 'normal bold 24px sans-serif';
        ctx.fillText(this.title, x, y);
        y += 26;

        ctx.font = 'normal 18px monospace';
        for(var line of this.lines) {
            ctx.fillText(line, x, y);
            y += 18;
        }
    }
}

class Random {
    /* Utility functions for producing random values */

    static randNumber(a, b) {
        if(b === undefined) {
            b = a;
            a = 0;
        }
        return a + Math.random() * (b - a);
    }
    static randInt(a, b) {
        return Math.floor(this.randNumber(a, b));
    }
    static randIntInclusive(a, b) {
        return this.randInt(a, b + 1);
    }
    static choice(choices) {
        return choices[this.randInt(choices.length)];
    }
    static randRotation() {
        return this.randNumber(Math.PI * 2);
    }
    static randColor(min, max, alpha) {
        if(max === undefined) {
            max = min;
            min = 0;
        }
        if(max === undefined) max = 256;

        var r = this.randInt(min, max);
        var g = this.randInt(min, max);
        var b = this.randInt(min, max);
        return alpha === undefined? Color.rgb(r, g, b):
            Color.rgba(r, g, b, alpha);
    }
}

class Color {
    /* Helper functions for creating CSS colours */
    static rgb(r, g, b) {
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }
    static rgba(r, g, b, a) {
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    }
}

class Point {
    /* A 2-dimensional point.
    Can also be used to represent the width+height of a rectangle,
    and/or represent the rectangle between (0,0) and (this.x,this.y). */

    constructor(x, y) {
        this.x = getDefault(x, 0);
        this.y = getDefault(y, 0);
    }
    clone() {
        return new Point(this.x, this.y);
    }
    set(x, y) {
        this.x = getDefault(x, 0);
        this.y = getDefault(y, 0);
        return this;
    }
    linear(other, m) {
        this.x = linear(this.x, other.x, m);
        this.y = linear(this.y, other.y, m);
        return this;
    }
    area() {
        return this.x * this.y;
    }
    dist(other, modulo) {
        var x0 = this.x;
        var y0 = this.y;
        var x1 = other? other.x: 0;
        var y1 = other? other.y: 0;

        var dx = Math.abs(x1 - x0);
        var dy = Math.abs(y1 - y0);
        if(modulo) {
            // If modulo is provided, it should be a Point representing
            // a rectangle representing a torus within which this and other
            // are contained.
            if(dx > modulo.x / 2) dx = modulo.x - dx;
            if(dy > modulo.y / 2) dy = modulo.y - dy;
        }
        return Math.sqrt(dx * dx + dy * dy);
    }
    angle(other, modulo) {
        var dx, dy;
        if(other) {
            if(modulo) {
                dx = moduloDiff(this.x, other.x, modulo.x);
                dy = moduloDiff(this.y, other.y, modulo.y);
            } else {
                dx = other.x - this.x;
                dy = other.y - this.y;
            }
        } else {
            dx = this.x;
            dy = this.y;
        }
        if(!dx && !dy) throw new Error("No angle between equal points");
        return Math.atan2(-dy, dx);
    }
    copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }
    setMidpoint(other) {
        /* Sets this to the midpoint of the a rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = other.x / 2;
        this.y = other.y / 2;
        return this;
    }
    setRandomWithin(other) {
        /* Sets this to a random point within the rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = Random.randNumber(other.x);
        this.y = Random.randNumber(other.y);
        return this;
    }
    eq(other) {
        return this.x === other.x && this.y === other.y;
    }
    addxy(x, y) {
        this.x += getDefault(x, 0);
        this.y += getDefault(y, 0);
        return this;
    }
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    addMul(other, mul) {
        this.x += other.x * mul;
        this.y += other.y * mul;
        return this;
    }
    mul(n) {
        this.x *= n;
        this.y *= n;
        return this;
    }
    mulxy(x, y) {
        this.x *= getDefault(x, 1);
        this.y *= getDefault(y, 1);
        return this;
    }
    modulo(other) {
        /* Returns this Point modulo the rectangle between (0,0) and
        (other.x, other.y).
        You can think of this as constraining this Point within the
        torus defined by the rectangle defined by other.
        If you're into that kind of thing. O_o */
        this.x = modulo(this.x, other.x);
        this.y = modulo(this.y, other.y);
        return this;
    }
    rotate(rot) {
        /*
            for(var i = 0; i < 4; i++) {
                var p = new Point(1).rotate(Math.PI * i / 2); 
                console.log(p);
            }
            // {x:  1, y:  0}
            // {x:  0, y: -1}
            // {x: -1, y:  0}
            // {x:  0, y:  1}
        */
        var sin = Math.sin(rot);
        var cos = Math.cos(rot);
        var x =  this.x;
        var y = -this.y;
        this.x =  (x * cos - y * sin);
        this.y = -(x * sin + y * cos);
        return this;
    }
    static unit(rotmul) {
        return new this(1).rotate(Math.PI * 2 * rotmul);
    }
    static units(len, array) {
        /* Bit of a wacky function. Basically just used by
        rockWriter. */

        var points = [];
        for(var elem of array) {
            if(typeof elem === 'number') {
                points.push(this.unit(elem / len));
            } else if(elem instanceof Point) {
                points.push(elem.clone());
            } else {
                console.log('Invalid array element', elem);
                throw new Error('Invalid array element');
            }
        }
        return points;
    }
    setSpeed(speed, rot) {
        return this.set(speed).rotate(rot);
    }
    addSpeed(speed, rot) {
        var x = this.x;
        var y = this.y;
        this.setSpeed(speed, rot);
        this.x += x;
        this.y += y;
        return this;
    }
}

class Particle {
    /* Represents a thing with position and velocity. */

    radius = 1;

    modulo = null; // subclasses may override this

    constructor() {
        this.pos = new Point();
        this.vel = new Point();
    }
    stepPhysics() {
        this.pos.add(this.vel);
    }
    repel(other, opts) {
        opts = opts || EMPTY;
        var mul = getDefault(opts.mul, 1);

        var dx, dy;
        if(this.modulo) {
            dx = moduloDiff(this.pos.x, other.pos.x, this.modulo.x);
            dy = moduloDiff(this.pos.y, other.pos.y, this.modulo.y);
        } else {
            dx = other.pos.x - this.pos.x;
            dy = other.pos.y - this.pos.y;
        }

        var dist = this.pos.dist(other.pos, this.modulo);

        // Just say no to dividing by zero!
        if(!dist) {
            dist = .01;
            var p = new Point().addSpeed(dist, Random.randRotation());
            dx += p.x;
            dy += p.y;
        }

        var m = -mul / (dist * dist);
        this.vel.x += dx * m;
        this.vel.y += dy * m;
        other.vel.x -= dx * m;
        other.vel.y -= dy * m;
    }
    spring(other, tdist, opts) {
        // tdist: target distance (target spring length)

        opts = opts || EMPTY;
        var mul = getDefault(opts.mul, 1);
        var push = getDefault(opts.push, true);

        var dx, dy;
        if(this.modulo) {
            dx = moduloDiff(this.pos.x, other.pos.x, this.modulo.x);
            dy = moduloDiff(this.pos.y, other.pos.y, this.modulo.y);
        } else {
            dx = other.pos.x - this.pos.x;
            dy = other.pos.y - this.pos.y;
        }

        var dist = this.pos.dist(other.pos, this.modulo);

        // Early exit if we're already within target distance, and caller
        // said we shouldn't "push"
        if(!push && dist <= tdist) return;

        // Just say no to dividing by zero!
        if(!dist) {
            dist = .01;
            var p = new Point().addSpeed(dist, Random.randRotation());
            dx += p.x;
            dy += p.y;
        }

        // Vector which would move this to where dist between
        // this and other would be tdist
        var mx = dx / dist * (dist - tdist);
        var my = dy / dist * (dist - tdist);

        // r0, r1: relative "weights" of this and other.
        //    r0 is 0:   only other moves
        //    r0 is 1/2: this & other each move just as much
        //    r0 is 1:   only this moves
        var r0 = getDefault(opts.r0,
            this.radius / (this.radius + other.radius));
        var r1 = 1 - r0;

        this.vel.x += mx * r1 * mul;
        this.vel.y += my * r1 * mul;
        other.vel.x -= mx * r0 * mul;
        other.vel.y -= my * r0 * mul;
    }
}

class MinMax {
    /* Represents a range of numbers, min..max.
    Used for e.g. generating random values within a range. */

    constructor(min, max) {
        this.min = getDefault(min, 0);
        this.max = getDefault(max, this.min);
    }
    clone() {
        return new this.constructor(this.min, this.max);
    }
    getAverage() {
        return (this.min + this.max) / 2;
    }
    getRand() {
        return Random.randNumber(this.min, this.max);
    }
    add(n) {
        this.min += n;
        this.max += n;
        return this;
    }
    mul(n) {
        this.min *= n;
        this.max *= n;
        return this;
    }
    createInterpolated(other, m) {
        return new MinMax(
            linear(this.min, other.min, m),
            linear(this.max, other.max, m));
    }
}

class WeightedArrayEntry {
    /* An entry of a WeightedArray */

    constructor(value, weight) {
        this.value = value;
        this.weight = weight;
    }
}

class WeightedArray {
    /* An Array whose values each have a "weight", used when e.g.
    choosing a value at random. */

    constructor(defaultValue, entries) {
        defaultValue = getDefault(defaultValue, null);
        entries = getDefault(entries, []);

        if(!(entries instanceof Array)) {
            throw new Error('Entries not an instance of Array');
        }
        for(var entry of entries) {
            if(!(entry instanceof WeightedArrayEntry)) {
                console.log(defaultValue, entries, entry);
                throw new Error(
                    'Entry is not an instance of WeightedArrayEntry');
            }
        }

        this.defaultValue = defaultValue;

        // entries: Array of WeightedArrayEntry
        this.entries = entries;
    }
    static from(values, defaultValue) {
        var a = new this(defaultValue);
        for(var value of values) a.addEntry(value, 1);
        return a;
    }
    static fromEntries(entries, defaultValue) {
        var a = new this(defaultValue);
        for(var entry of entries) a.addEntry(entry.value, entry.weight);
        return a;
    }
    addEntry(value, weight) {
        weight = getDefault(weight, 1);
        var entry = new WeightedArrayEntry(value, weight);
        this.entries.push(entry);
        return this;
    }
    getTotalWeight() {
        var totalWeight = 0;
        for(var entry of this.entries) totalWeight += entry.weight;
        return totalWeight;
    }
    normalize(targetTotalWeight) {
        targetTotalWeight = getDefault(targetTotalWeight, 1);

        var totalWeight = this.getTotalWeight();
        for(var entry of this.entries) {
            entry.weight = entry.weight / totalWeight * targetTotalWeight;
        }
        return this;
    }
    clone() {
        return WeightedArray.fromEntries(this.entries, this.defaultValue);
    }
    getEntry(value) {
        for(var entry of this.entries) {
            if(entry.value === value) return entry;
        }
        return null;
    }
    mul(m) {
        for(var entry of this.entries) entry.weight *= m;
    }
    add(other, m) {
        // m: number between 0 and 1, used to weight this and other.
        // That is, if m === 0 then all weights are equal to this's weights.
        // If m === 1 then all weights are equal to other's weights.
        // If m === .5 then this and other are equally weighted.
        m = getDefault(m, .5);

        this.mul(1 - m);

        for(var otherEntry of other.entries) {
            var thisEntry = this.getEntry(otherEntry.value);
            if(thisEntry) {
                thisEntry.weight += otherEntry.weight * m;
            } else {
                this.addEntry(otherEntry.value, otherEntry.weight * m);
            }
        }
        return this;
    }
    addNormalized(other, m) {
        var otherTotalWeight = other.getTotalWeight();
        if(otherTotalWeight) {
            this.normalize(otherTotalWeight);
            return this.add(other, m);
        }
        return this;
    }
    randValue() {
        var totalWeight = this.getTotalWeight();
        var r = Random.randNumber(totalWeight);
        for(var entry of this.entries) {
            r -= entry.weight;
            if(r < 0) return entry.value;
        }

        // If e.g. this.entries was empty, or totalWeight is 0:
        return this.defaultValue;
    }
}

class ShipTemplate {
    /* Blueprint for creating a Ship */

    constructor(cls, team) {
        this.cls = cls;
        this.team = team;
    }
}
class FieldTemplate {
    /* Blueprint for creating a Field and populating it with entities (stars,
    rocks, ships, etc). */

    text = null;
    rocksText = null;
    shop = null;

    width = new MinMax(DEFAULT_FIELD_WIDTH);
    height = new MinMax(DEFAULT_FIELD_HEIGHT);

    stars_per = new MinMax(DEFAULT_STARS_PER);
    rocks_per = new MinMax(DEFAULT_ROCKS_PER);
    planets_per = new MinMax(DEFAULT_PLANETS_PER);
    ships_per = new MinMax(DEFAULT_SHIPS_PER);

    rock_radius = new MinMax(7, 32).mul(RADIUSMUL);
    star_speed = new MinMax(
        DEFAULT_STAR_SPEED - 1.6, DEFAULT_STAR_SPEED + 1.5);

    energy_chance = DEFAULT_ENERGY_CHANCE;
    fuel_chance = DEFAULT_FUEL_CHANCE;
    gold_chance = DEFAULT_GOLD_CHANCE;

    ships = new WeightedArray();

    constructor(props) {
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    getSize() {
        return new Point(this.width.getRand(), this.height.getRand());
    }
    clone(props) {
        props = props || {};
        for(var name in this) {
            if(name in props) continue;

            var thisProp = this[name];
            if(thisProp instanceof MinMax) {
                props[name] = thisProp.clone();
            } else if(thisProp instanceof Shop) {
                props[name] = thisProp;
            } else if(thisProp instanceof WeightedArray) {
                props[name] = thisProp.clone();
            } else if(thisProp instanceof Text) {
                props[name] = thisProp.clone();
            } else if(typeof thisProp !== 'object' || thisProp === null) {
                // number, string, null
                props[name] = thisProp;
            } else {
                console.log(this);
                console.log(thisProp);
                throw new Error('Dunno what to do with property: ' + name);
            }
        }
        return new this.constructor(props);
    }
    createInterpolated(other, m) {
        // We create & return a new FieldTemplate whose values are linear
        // interpolations of those in this and other.
        // m: number between 0 and 1 (inclusive).
        // If m is 0, new FieldTemplate's values are exactly this's values.
        // If m is 1, new FieldTemplate's values are exactly other's values.
        // If m is .5, new FieldTemplate's values are halfway between this's
        // and other's values.
        // ...etc.

        var props = {};
        for(var name in this) {
            var thisProp = this[name];
            var otherProp = other[name];
            if(thisProp instanceof MinMax) {
                props[name] = thisProp.createInterpolated(otherProp, m);
            } else if(thisProp instanceof WeightedArray) {
                props[name] = thisProp.clone().addNormalized(otherProp, m);
            } else if(typeof thisProp === 'number') {
                props[name] = linear(thisProp, otherProp, m);
            } else if(
                thisProp instanceof Text ||
                otherProp instanceof Text ||
                thisProp instanceof Shop ||
                otherProp instanceof Shop ||
                typeof thisProp === 'string' ||
                typeof otherProp === 'string'
            ) {
                if(m === 0) props[name] = thisProp;
                else if(m === 1) props[name] = otherProp;
                else if(thisProp === otherProp) props[name] = thisProp;
                else {
                    // Don't bother trying to "interpolate"
                }
            } else if(thisProp === null || otherProp === null) {
                props[name] = null;
            } else {
                console.log(this, other);
                console.log(thisProp, otherProp);
                throw new Error('Dunno what to do with property: ' + name);
            }
        }
        return new FieldTemplate(props);
    }
}

class MapNode extends Particle {
    /* A node of the graph represented by class Map. */

    constructor(map, template, title) {
        super();

        this.map = map;
        this.template = template;
        this.title = title;
        this.edges = [];
        this.backedges = [];

        // radius, pos, vel: don't affect anything, only used for rendering the
        // Map and its nodes/edges as a graph with "springy physics"
        // (also apparently known as a "force-directed graph")
        var speed = Random.randNumber(250);
        var rot = Random.randRotation();
        this.pos.addSpeed(speed, rot);
        this.radius = Random.randNumber(9, 15);

        this.strokeStyle = Random.randColor(80, 256, .75);
        this.fillStyle = 'rgba(255,255,255,.25)';
    }
    addEdge(other, len) {
        var edge = new MapEdge(this, other, len);
        this.edges.push(edge);
        other.backedges.push(edge);
        return edge;
    }
    numEdges(includeBackedges) {
        includeBackedges = getDefault(includeBackedges, false);
        return includeBackedges?
            this.edges.length + this.backedges.length:
            this.edges.length;
    }
    getEdgeIndex(edge) {
        var i = this.edges.indexOf(edge.edge);
        if(i < 0) {
            i = this.backedges.indexOf(edge.edge);
            if(i < 0) {
                console.log(this, edge);
                throw new Error('Couldn\'t find edge');
            }
            i += this.edges.length;
        }
        return i;
    }
    getEdge(i) {
        return (i < this.edges.length)?
            this.edges[i].forwardEdge:
            this.backedges[i - this.edges.length].backEdge;
    }
    step() {
        this.pos.add(this.vel);
    }
}

class MapEdge {
    /* Connects one MapNode (this.node0) to another (this.node1).
    Has a length (this.len), an integer representing the number of
    warps you need to make in order to travel between this.node0 and
    this.node1. */

    constructor(node0, node1, len) {
        this.node0 = node0;
        this.node1 = node1;
        this.len = getDefault(len, 1);

        this.forwardEdge = new DirectedMapEdge(this, false);
        this.backEdge = new DirectedMapEdge(this, true);

        this.strokeStyle = Random.randColor(0, 200, .75);
    }
}

class DirectedMapEdge {
    /* Wraps a MapEdge, representing an arrow pointing along it in either
    direction (that is, either from node0 to node1, or vice versa). */

    constructor(edge, isBackEdge) {
        this.edge = edge;
        this.isBackEdge = isBackEdge;
    }
    getReversed() {
        return this.isBackEdge? this.edge.forwardEdge: this.edge.backEdge;
    }
    getLen() {
        return this.edge.len;
    }
    getNode0() {
        return this.isBackEdge? this.edge.node1: this.edge.node0;
    }
    getNode1() {
        return this.isBackEdge? this.edge.node0: this.edge.node1;
    }
}

class Map {
    /* A directed graph of MapNodes and MapEdges, each of which have an
    associated FieldTemplate. */

    nodes = [];
    startNode = null;

    getStartNode() {
        if(this.startNode) return this.startNode;
        if(this.nodes.length) return this.nodes[0];
        return null;
    }
    addNode(template, title) {
        var node = new MapNode(this, template, title);
        this.nodes.push(node);
        return node;
    }
    step() {
        for(var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];

            var velmul = .95;
            node.vel.mul(velmul);

            // Nodes repel
            for(var j = i + 1; j < this.nodes.length; j++) {
                var other = this.nodes[j];
                node.repel(other, {mul: 5});
            }

            // Multiplier, converts edge.len into a length in pixels
            var lenmul = 50;

            // Edges act like springs
            for(var edge of node.edges) {
                var other = edge.node1;

                // Target distance (edge's length in pixels)
                var tdist = edge.len * lenmul;
                node.spring(other, tdist, {mul: .02});
            }
        }
        for(var node of this.nodes) node.step();
    }
}

class MapProgress {
    /* Represents players' "progress" across a Map.
    For instance, the MapNode at which they are currently located, and
    the MapEdge along which they are travelling (if applicable). */

    map = null;
    node = null;
    edge = null;

    // edgeDist: how far we've travelled along this.edge.
    // It should always be the case that:
    //
    //   edgeDist >= 0 && edgeDist < edge.getLen()
    //
    edgeDist = 0;

    template = null;

    constructor(map, startNode) {
        if(!map.nodes.length) throw new Error('Map has no nodes');

        this.map = map;
        this.node = getDefault(startNode, map.getStartNode());
        this.updateTemplate();
    }
    getPos() {
        if(this.edge) {
            var pos0 = this.node.pos;
            var pos1 = this.edge.getNode1().pos;
            var m = this.edgeDist / this.edge.getLen();
            return pos0.clone().linear(pos1, m);
        } else {
            return this.node.pos;
        }
    }
    canProceed() {
        return Boolean(this.edge);
    }
    setEdge(edge) {
        if(this.canProceed()) {
            throw new Error("Can't set edge yet, must proceed first");
        }
        this.edge = edge;
        this.edgeDist = 0;
        this.updateTemplate();
    }
    proceed() {
        if(!this.canProceed()) {
            throw new Error("Can't proceed yet, must set edge first");
        }

        if(this.edgeDist < this.edge.getLen() - 1) {
            this.edgeDist++;
        } else {
            this.node = this.edge.getNode1();
            this.edge = null;
        }

        this.updateTemplate();
    }
    updateTemplate() {
        if(!this.edge) {
            this.template = this.node.template;
            return;
        }

        var m = this.edgeDist / this.edge.getLen();
        var node0 = this.edge.getNode0();
        var node1 = this.edge.getNode1();
        this.template = node0.template
            .createInterpolated(node1.template, m);
    }
}

class Field {
    /* Think of "field" in the sense of "playing field".
    It's basically a rectangle within which sprites can fly around.
    The edges of the rectangle "wrap around" (or you can say it's a
    "torus" if you prefer). */

    constructor(game, size) {
        this.game = game;
        this.size = size;

        this.stars = [];

        this.entityArrays = [];
        this.planets = this.addEntityArray();
        this.ships = this.addEntityArray();
        this.shots = this.addEntityArray();
        this.effects = this.addEntityArray();
        this.rocks = this.addEntityArray();
        this.pickups = this.addEntityArray();

        this.template = null;
        this.shop = null;

        /* Create a canvas for rendering this Field.
        This canvas is never attached to a parent element, we only
        use it for drawing, then copy its image onto another canvas. */
        this.innerCanvas = document.createElement('canvas');
        this.innerCanvas.width = this.size.x;
        this.innerCanvas.height = this.size.y;
    }
    populate(template) {
        this.template = template;

        this.shop = template.shop;

        var area = this.size.area();
        var n_stars = area * template.stars_per.getRand();
        var n_rocks = area * template.rocks_per.getRand();
        var n_planets = area * template.planets_per.getRand();
        var n_ships = area * template.ships_per.getRand();

        /* Add some random stars */
        var star_vel_rot = Random.randRotation();
        var star_speed = template.star_speed.getRand();
        for(var i = 0; i < n_stars; i++) {
            var star = new Star(this);
            this.stars.push(star);

            star.pos.setRandomWithin(this.size);

            /* Each star has a random "distance", as in, how far away it
            is.
            Distance is a number between 0 and 1, with higher numbers
            meaning "further away".
            Stars which are "further away" are darker and move slower,
            to give a bit of parallax-ish effect. */
            var distance = Random.randNumber(0.25, 0.75);
            var color_component = Math.floor(255 * distance);
            star.trailStrokeStyle = 'rgb('
                + color_component + ','
                + color_component + ','
                + color_component + ')';
            star.vel.setSpeed(star_speed * distance, star_vel_rot);
            star.distance = distance;
        }

        /* Sort this.stars by "distance" so that when we iterate over
        it in render(), more distant stars are rendered first, and
        therefore "painted over" by closer stars. */
        this.stars.sort((s1, s2) => Math.sign(s2.distance - s1.distance));

        // Add rocks
        for(var i = 0; i < n_rocks; i++) {
            var radius = template.rock_radius.getRand();
            var rock = this.addRock(Rock, radius);
        }

        // Add planets
        for(var i = 0; i < n_planets; i++) {
            var planet = this.addPlanet(Planet);
        }

        // Add ships
        for(var i = 0; i < n_ships; i++) {
            var ship_template = template.ships.randValue();
            if(!ship_template) continue;

            var player = this.game.addCPUPlayer();
            player.setTeam(ship_template.team);
            player.createShip(ship_template.cls);
        }

        // Maybe add rocks which spell out some text
        if(template.rocksText) {
            this.addRocksText(template.rocksText);
        }
    }
    addEntityArray() {
        // Create an Array used to store Entity instances
        // (E.g. Game.ships, Game.rocks, etc)
        var entityArray = [];

        // Add a pending Array of things to be added to the Array at the
        // start of next Field.step
        entityArray.pending = [];

        this.entityArrays.push(entityArray);
        return entityArray;
    }
    cleanup() {
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.cleanup();
        }
    }
    addShip(cls) {
        var entity = new cls(this);
        this.ships.pending.push(entity);
        return entity;
    }
    addShot(cls) {
        var entity = new cls(this);
        this.shots.pending.push(entity);
        return entity;
    }
    addEffect(cls) {
        var entity = new cls(this);
        this.effects.pending.push(entity);
        return entity;
    }
    addRock(cls, radius) {
        radius = getDefault(radius, DEFAULT_ROCK_RADIUS);
        var entity = new cls(this, radius);
        this.rocks.pending.push(entity);
        return entity;
    }
    addPickup(cls) {
        var entity = new cls(this);
        this.pickups.pending.push(entity);
        return entity;
    }
    addPlanet(cls) {
        var entity = new cls(this);
        this.planets.pending.push(entity);
        return entity;
    }
    addPendingEntities(entityArray) {
        for(var entity of entityArray.pending) entityArray.push(entity);
        entityArray.pending.length = 0;
    }
    addRocksText(text) {
        if(!text.length) return;

        var radiusmul = 1.2;

        var pictures = rockWriter.getPictures(text);
        var radius = DEFAULT_ROCK_RADIUS * radiusmul;
        var x0 = this.size.x / 2;
        var y0 = this.size.y / 2 - radius * 2.5;

        var padWidth = 0;
        var w = text.length * (radius * 2) + (text.length - 1) * padWidth;
        var x = x0 - w / 2;
        var y = y0;
        var dx = radius * 2 + padWidth;

        for(var picture of pictures) {

            // Kind of a hack: turn picture.radiusmul into a multiplier for
            // rock's radius, instead of for picture's radius.
            var thisRadius = radius * picture.radiusmul;
            picture.mul = 1;

            var rock = this.addRock(Rock, thisRadius);
            rock.pos.set(x, y);
            rock.vel.set();
            rock.picture = picture;
            rock.rot = 0;
            rock.rot_vel = 0;

            x += dx;
        }
    }
    step() {
        for(var entityArray of this.entityArrays) {
            this.addPendingEntities(entityArray);
        }

        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.step();
        }

        for(var shot of this.shots) {
            for(var ship of this.ships) {
                if(shot.ship && ship.isAlly(shot.ship)) continue;
                if(shot.colliding(ship)) shot.hit(ship);
                // Don't bother calling handleCollision() with Shots
                // (We might want to in future, though...)
            }
            for(var rock of this.rocks) {
                if(shot.ship && rock.isAlly(shot.ship)) continue;
                if(shot.colliding(rock)) shot.hit(rock);
                // Don't bother calling handleCollision() with Shots
                // (We might want to in future, though...)
            }
        }

        for(var i = 0; i < this.rocks.length; i++) {
            var rock = this.rocks[i];
            for(var j = i + 1; j < this.rocks.length; j++) {
                var other = this.rocks[j];
                if(rock.colliding(other)) {
                    rock.handleCollision(other);
                    other.handleCollision(rock);
                    rock.handleCollisionPhysics(other);
                }
            }
            for(var ship of this.ships) {
                if(rock.colliding(ship)) {
                    rock.handleCollision(ship);
                    ship.handleCollision(rock);
                    rock.handleCollisionPhysics(ship);
                }
            }
            for(var pickup of this.pickups) {
                if(rock.colliding(pickup)) {
                    rock.handleCollision(pickup);
                    pickup.handleCollision(rock);
                    rock.handleCollisionPhysics(pickup);
                }
            }
        }

        for(var i = 0; i < this.ships.length; i++) {
            var ship = this.ships[i];
            for(var j = i + 1; j < this.ships.length; j++) {
                var other = this.ships[j];
                if(ship.colliding(other)) {
                    ship.handleCollision(other);
                    other.handleCollision(ship);
                    ship.handleCollisionPhysics(other);
                }
            }
            for(var pickup of this.pickups) {
                if(ship.colliding(pickup)) {
                    ship.handleCollision(pickup);
                    pickup.handleCollision(ship);
                    ship.handleCollisionPhysics(pickup);
                }
            }
        }

        for(var i = 0; i < this.planets.length; i++) {
            var planet = this.planets[i];
            for(var j = i + 1; j < this.planets.length; j++) {
                var other = this.planets[j];
                if(planet.colliding(other)) {
                    planet.handleCollisionPhysics(other);
                    // Don't bother calling handleCollision() with Planets
                }
            }
        }

        for(var entityArray of this.entityArrays) {
            this.removeEntities(entityArray);
        }

        for(var star of this.stars) star.stepPhysics();
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.stepPhysics();
        }
    }
    removeEntities(entityArray) {
        for(var i = 0; i < entityArray.length; i++) {
            var entity = entityArray[i];
            if(entity._shouldRemove) {
                entity.removed = true;
                entity.cleanup();
                entityArray.splice(i, 1);
                i--;
            }
        }
    }
    innerRender(camera) {
        var canvas = this.innerCanvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if(RENDER_BOUNDARY) this.renderBoundary(canvas);

        for(var star of this.stars) star.render(canvas, camera);
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.render(canvas, camera);
        }
    }
    renderBoundary(canvas) {
        /* Draw a box around the field */
        var ctx = canvas.getContext('2d');
        var w = this.size.x;
        var h = this.size.y;
        ctx.strokeStyle = '#800';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, 0);
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        ctx.stroke();
    }
    render(canvas, camera) {
        this.innerRender(camera);
        var innerCanvas = this.innerCanvas;

        var ctx = canvas.getContext('2d');
        var x0 = canvas.width  / 2 - camera.pos.x;
        var y0 = canvas.height / 2 - camera.pos.y;

        x0 = modulo(x0, innerCanvas.width);
        if(x0 > 0) x0 -= innerCanvas.width;
        y0 = modulo(y0, innerCanvas.height);
        if(y0 > 0) y0 -= innerCanvas.height;

        for(var x = x0; x < canvas.width; x += innerCanvas.width) {
            for(var y = y0; y < canvas.height; y += innerCanvas.height) {
                ctx.drawImage(this.innerCanvas, x, y);
            }
        }
    }
}

class FieldParticle extends Particle {
    /* A particle which lives on a field. */

    radius = 10 * RADIUSMUL;

    constructor(field) {
        super();
        this.field = field;
        this.modulo = field.size;
    }
    stepPhysics() {
        // Make sure we don't go too gast
        var maxspeed = MAXSPEED;
        var speed = this.vel.dist();
        if(speed > maxspeed) this.vel.mul(maxspeed / speed);

        this.pos.addMul(this.vel, VELMUL).modulo(this.field.size);
    }
}

class Shape {
    /* Specifies a polygon to draw on a canvas.
    Each Picture can have multiple Shapes. */

    stroke = true;
    fill = true;
    close = true;

    pos = new Point();
    rot = 0;
    radiusmul = 1;

    points = null; // Array of Point

    constructor(points, props) {
        if(points) this.points = points;
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    static newRect(x0, y0, x1, y1) {
        return new this([
            new Point(x0, y0),
            new Point(x1, y0),
            new Point(x1, y1),
            new Point(x0, y1),
        ]);
    }
    static newPolygon(n_points, opts, props) {
        opts = opts || EMPTY;
        var rotVariance = getDefault(opts.rotVariance, 0);
        var radiusVariance = getDefault(opts.radiusVariance, 0);
        var rot = getDefault(opts.rot, 0);

        var points = [];
        for(var i = 0; i < n_points; i++) {
            var i_varied = i + Random.randNumber(-rotVariance, rotVariance);
            var point_rot = (Math.PI * 2) * i_varied / n_points + rot;
            var radius = 1 + Random.randNumber(-.5, .5) * radiusVariance;
            var point = new Point().addSpeed(radius, point_rot);
            points.push(point);
        }
        return new this(points, props);
    }
    clone() {
        var points = this.points.map(p => p.clone());
        var shape = new this.constructor(points);
        shape.pos.copy(this.pos);
        for(var key in this) {
            if(typeof this[key] !== 'object') {
                shape[key] = this[key];
            }
        }
        return shape;
    }
    flip() {
        for(var point of this.points) point.y = -point.y;
        return this;
    }
    add(other_point) {
        for(var point of this.points) point.add(other_point);
        return this;
    }
    addxy(x, y) {
        for(var point of this.points) point.addxy(x, y);
        return this;
    }
    mul(n) {
        for(var point of this.points) point.mul(n);
        return this;
    }
    mulxy(x, y) {
        for(var point of this.points) point.mulxy(x, y);
        return this;
    }
}

class Picture {
    radiusmul = 1;

    constructor(shapes, props) {
        this.shapes = shapes || [];
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    clone() {
        var shapes = this.shapes.map(shape => shape.clone());
        var picture = new this.constructor(shapes);
        for(var key in this) {
            if(typeof this[key] !== 'object') {
                picture[key] = this[key];
            }
        }
        return picture;
    }
    static newPolygon(n_points, opts, props) {
        var shape = Shape.newPolygon(n_points, opts);
        return new this([shape], props);
    }
    render(canvas, x0, y0, rot, radius_x, radius_y, opts) {
        opts = opts || EMPTY;
        var strokeStyle = getDefault(opts.strokeStyle, 'rgb(255,255,255)');
        var lineWidth = getDefault(opts.lineWidth, 1);
        var fillStyle = getDefault(opts.fillStyle, 'rgba(255,255,255,.25)');

        // Point used for calculations
        var p = new Point();

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.fillStyle = fillStyle;

        for(var shape of this.shapes) {
            var firstPoint = true;
            ctx.beginPath();
            for(var point of shape.points) {
                p.copy(point)
                    .rotate(shape.rot)
                    .add(shape.pos)
                    .rotate(rot)
                    .mulxy(radius_x, radius_y)
                    .mul(shape.radiusmul)
                    .addxy(x0, y0);
                if(firstPoint) {
                    ctx.moveTo(p.x, p.y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            if(shape.close) ctx.closePath();
            if(shape.stroke) ctx.stroke();
            if(shape.fill) ctx.fill();
        }

    }
    renderEntity(entity, canvas, camera, addx, addy) {
        var x0 = entity.pos.x + addx;
        var y0 = entity.pos.y + addy;
        var rot = entity.rot;
        var radius = entity.radius * this.radiusmul;

        this.render(canvas, x0, y0, rot, radius, radius, {
            strokeStyle: entity.circleStrokeStyle,
            lineWidth: entity.circleLineWidth,
            fillStyle: entity.circleFillStyle,
        });
    }
}

class Writer {
    /* Utility class which converts strings of text into Arrays of
    Picture. */

    constructor(pictures_by_letter) {
        // pictures_by_letter: Object mapping letters (single-character
        // strings) to instances of Picture.
        this.pictures_by_letter = pictures_by_letter;
    }
    getPicture(letter) {
        var picture = this.pictures_by_letter[letter];
        if(!picture) {
            throw new Error(
                'No picture defined for letter: ' + letter);
        }
        return picture;
    }
    getPictures(text) {
        var pictures = [];
        for(var letter of text) {
            var picture = this.getPicture(letter);
            pictures.push(picture.clone());
        }
        return pictures;
    }
}

var rockWriter = new Writer({
    // I dare you to make sense of the following.
    // (Hint: we're basically chipping each letter out of a decahedron.
    // The points of the decahedron are represented by the numbers 0 through
    // 9, and we use the Point.unit and Point.units helper functions to turn
    // those numbers into points.)

    ' ': new Picture(),
    S: new Picture([new Shape(Point.units(10, [
        new Point(0, -.5), 1, 2, 3, 4,
        new Point(0,  .5), 6, 7, 8, 9,
    ])).mulxy(1, 1.3)]),
    H: new Picture([new Shape(Point.units(10, [
        0, 1, 2,
        Point.unit(2 / 10).addxy(0,  .5),
        Point.unit(3 / 10).addxy(0,  .5), 3, 4,

        5, 6, 7,
        Point.unit(7 / 10).addxy(0, -.5),
        Point.unit(8 / 10).addxy(0, -.5), 8, 9,
    ]))]),
    I: new Picture([new Shape(Point.units(10, [1, 2, 3,  6, 7, 8]), {radiusmul: .9})]),
    P: new Picture([new Shape(Point.units(10, [0, 1, 2, 3, 4,  7, 8,
        Point.unit(0 / 10).addxy(-.6, .2)]))]),
    t: new Picture([new Shape(Point.units(10, [
        Point.unit(1 / 10).addxy(-.2), 2, 3,
        Point.unit(4 / 10).addxy( .2), 4, 5,
        Point.unit(5 / 10).addxy( .5), 7, 8,
        Point.unit(0 / 10).addxy(-.5), 0, 1,
    ]), {radiusmul: 1})]),
    e: new Picture([new Shape(Point.units(10, [0, 1, 2, 3, 4, 5, 6, 7, 8,
        new Point(-.25)]), {radiusmul: .85})]),
    r: new Picture([new Shape(Point.units(10, [0, 1, 2, 3, 4,  6, 7,
        new Point(-.25), new Point(.2, -.2)]), {radiusmul: .85})]),
    o: new Picture([Shape.newPolygon(10, {}, {radiusmul: 1.1})]),
    i: new Picture([new Shape(Point.units(10, [
        Point.unit(6 / 10).addxy(0, -.75), 6, 7, 8, 9,
        Point.unit(9 / 10).addxy(0, -.75),
        new Point(0, -.25), 2, 3,
        new Point(0, -.25),
    ]), {radiusmul: .85}).mulxy(.9, 1.2)]),
    d: new Picture([new Shape(Point.units(10, [
        2, 3,
        Point.unit(3 / 10).addxy(0, .75), 5, 6, 7, 8,
    ]), {radiusmul: 1})]),
    s: new Picture([new Shape(Point.units(10, [
        new Point( .25, -.25), 1, 2, 3, 4,
        new Point(-.25,  .25), 6, 7, 8, 9,
    ])).mulxy(.9, .8)]),
});

class BlockyDigits {
    /* Maps digits (single-character strings, e.g. '0') onto Pictures */

    constructor() {
        /* THE "PARTS":

              BBBB
            AA    CC
            AA    CC
              DDDD
            EE    GG
            EE    GG
              FFFF
        */
        this.shapes_by_part = {
            A: Shape.newRect(-1 , -1 , -.5,  0 ),
            B: Shape.newRect(-.5, -1 ,  .5, -.7),
            C: Shape.newRect( .5, -1 ,  1 ,  0 ),

            D: Shape.newRect(-.5, -.2,  .5,  .2),

            E: Shape.newRect(-1 ,  0 , -.5,  1 ),
            F: Shape.newRect(-.5,  .7,  .5,  1 ),
            G: Shape.newRect( .5,  0 ,  1 ,  1 ),
        };
        this.pictures_by_digit = {
            0: this.makePicture('ABCEFG'),
            1: this.makePicture('CG'),
            2: this.makePicture('BCDEF'),
            3: this.makePicture('BCDGF'),
            4: this.makePicture('ACDG'),
            5: this.makePicture('BADGF'),
            6: this.makePicture('BADEFG'),
            7: this.makePicture('BCG'),
            8: this.makePicture('ABCDEFG'),
            9: this.makePicture('BACDG'),
            '[': this.makePicture('BAEF'),
            ']': this.makePicture('BCGF'),
        };
    }
    makePicture(parts) {
        var shapes = [];
        for(var part of parts) {
            var shape = this.shapes_by_part[part];
            if(!shape) throw new Error('Part not found: ' + part);
            shapes.push(shape);
        }
        return new Picture(shapes);
    }
    getPicture(digit) {
        var picture = this.pictures_by_digit[digit];
        if(!picture) {
            throw new Error(
                'No picture defined for digit: ' + digit);
        }
        return picture;
    }
}

var blockyDigits = new BlockyDigits();

var blockyWriter = new Writer({
    E: new Picture([new Shape([
        // Top
        new Point(-1 , -1 ),
        new Point( 1 , -1 ),
        new Point( 1 , -.7),
        new Point(-.5, -.7),

        // Middle
        new Point(-.5, -.2),
        new Point( .5, -.2),
        new Point( .5,  .2),
        new Point(-.5,  .2),

        // Bottom
        new Point(-.5,  .7),
        new Point( 1 ,  .7),
        new Point( 1 ,  1 ),
        new Point(-1 ,  1 ),
    ])]),
    F: new Picture([new Shape([
        // Top
        new Point(-1 , -1 ),
        new Point( 1 , -1 ),
        new Point( 1 , -.7),
        new Point(-.5, -.7),

        // Middle
        new Point(-.5, -.2),
        new Point( .5, -.2),
        new Point( .5,  .2),
        new Point(-.5,  .2),

        // Bottom
        new Point(-.5,  1 ),
        new Point(-1 ,  1 ),
    ])]),
    G: new Picture([new Shape([
        // Top
        new Point( 1 , -.7),
        new Point( .5, -1 ),
        new Point(-.5, -1 ),
        new Point(-1 , -.7),

        // Bottom
        new Point(-1 ,  .7),
        new Point(-.5,  1 ),
        new Point( .5,  1 ),
        new Point( 1 ,  .7),

        // Middle
        new Point( 1 , -.2),
        new Point( 0 , -.2),
        new Point( 0 ,  .2),
        new Point( .5,  .2),
        new Point( .5,  .7),
        new Point(-.5,  .7),
        new Point(-.5, -.7),
    ])]),

    ' ': new Picture(),
    ':': new Picture([
        Shape.newRect(-.25, -.7,  .25, -.2),
        Shape.newRect(-.25,  .2,  .25,  .7),
    ]),
    '/': new Picture([new Shape([
        new Point(-1 ,  1 ),
        new Point(-.8,  1 ),
        new Point( .8, -1 ),
        new Point( 1 , -1 ),
    ])]),

    0: blockyDigits.getPicture('0'),
    1: blockyDigits.getPicture('1'),
    2: blockyDigits.getPicture('2'),
    3: blockyDigits.getPicture('3'),
    4: blockyDigits.getPicture('4'),
    5: blockyDigits.getPicture('5'),
    6: blockyDigits.getPicture('6'),
    7: blockyDigits.getPicture('7'),
    8: blockyDigits.getPicture('8'),
    9: blockyDigits.getPicture('9'),
});

var ENERGY_PICTURE = blockyWriter.getPicture('E');
var ENERGY_COLOR = 'rgb(80,200,200)';
var FUEL_PICTURE = blockyWriter.getPicture('F');
var FUEL_COLOR = 'rgb(180,65,0)';
var GOLD_PICTURE = blockyWriter.getPicture('G');
var GOLD_COLOR = 'rgb(255,165,50)';

class Sprite extends FieldParticle {
    /* Represents a Particle which can be drawn onto a <canvas>. */

    shouldRenderCircle = false;
    shouldRenderCircleLine = true;
    circleStrokeStyle = 'rgb(0,200,0)';
    circleFillStyle   = 'rgba(255,255,255,.15)';
    circleLineWidth = 2;

    shouldRenderTrail = false;
    trailStart = 0;
    trailEnd   = 1;
    trailCamVel = 1;
    trailStrokeStyle = 'rgba(255,150,0,25)';
    trailLineWidth = 2;

    picture = null; /* instanceof Picture */

    render(canvas, camera) {
        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var addx0 = this.pos.x < fieldx / 2? 0: -fieldx;
        var addy0 = this.pos.y < fieldy / 2? 0: -fieldy;

        for(var addx = addx0; addx <= addx0 + fieldx; addx += fieldx) {
            for(var addy = addy0; addy <= addy0 + fieldy; addy += fieldy) {
                if(this.shouldRenderTrail) {
                    this.renderTrail(canvas, camera, addx, addy);
                }
                if(this.shouldRenderCircle || RENDER_CIRCLES) {
                    this.renderCircle(canvas, camera, addx, addy);
                }
                if(this.picture) {
                    this.renderPicture(canvas, camera, addx, addy);
                }
            }
        }
    }
    renderPicture(canvas, camera, addx, addy) {
        this.picture.renderEntity(this, canvas, camera, addx, addy);
    }
    renderTrail(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var x1 = x0 - this.vel.x + camera.vel.x * this.trailCamVel;
        var y1 = y0 - this.vel.y + camera.vel.y * this.trailCamVel;
        var trail_x0 = linear(x0, x1, this.trailStart);
        var trail_y0 = linear(y0, y1, this.trailStart);
        var trail_x1 = linear(x0, x1, this.trailEnd);
        var trail_y1 = linear(y0, y1, this.trailEnd);

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.trailStrokeStyle;
        ctx.lineWidth = this.trailLineWidth;
        ctx.beginPath();
        ctx.moveTo(trail_x0, trail_y0);
        ctx.lineTo(trail_x1, trail_y1);
        ctx.stroke();
    }
    renderCircle(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var ctx = canvas.getContext('2d');

        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.fillStyle = this.circleFillStyle;
        renderCircle(ctx, x0, y0, this.rot, this.radius);
    }
}

class Star extends Sprite {
    radius = 3 * RADIUSMUL;
    shouldRenderTrail = true;
    trailLineWidth = 1;
    trailCamVel = 1;
}

class Key {
    /* Represents the state of a key on the keyboard */

    static KEYNAMES = 'udlrxy';

    constructor(name) {
        this.name = name;
        this.isDown = false;
        this.wasDown = false;
    }
    static createKeys() {
        var keys = {};
        for(var keyname of this.KEYNAMES) {
            keys[keyname] = new this(keyname);
        }
        return keys;
    }
    copy(other) {
        this.isDown = other.isDown;
        this.wasDown = other.wasDown;
        return this;
    }
    union(other) {
        // The state of this becomes the "union" of this and other.
        // So think "boolean OR".
        if(other.isDown) this.isDown = true;
        if(other.wasDown) this.wasDown = true;
        return this;
    }
    down() {
        this.isDown = this.wasDown = true;
    }
    up() {
        this.isDown = false;
    }
    set(isDown) {
        if(isDown) this.down();
        else this.up();
    }
    step() {
        this.wasDown = this.isDown;
    }
}

class Entity extends Sprite {
    /* An Entity is a sprite with "volition" -- it has virtual keys which
    can be pressed, and based on their state, it can move itself. */

    static name = 'Entity';

    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .5;

    maxAge = -1;
    fadeWithAge = false;

    team = null;
    inheritTeamColor = true;

    shotClass = {
        x: null,
        y: null,
        extra1: null, // No key for this one
    };

    thrustEffectClass = ThrustEffect;
    thrustEffectSpeedMul = 2;
    thrustEffectVelMul = 1;
    thrustEffectEvery = 3;
    thrustEffects = 1;
    thrustEffectPosRot = 0;

    // Set to thrustEffectEvery each time a thrust Effect is created
    thrustEffectCooldown = 0;

    is_warping = false;
    warping_counter = 0;

    static maxhp = -1;

    addhp = DEFAULT_ADDHP;

    constructor(field) {
        super(field);

        this.hp = this.maxhp = this.constructor.maxhp;

        // addpos: entities can add to each others' addpos during step(),
        // and then addpos is added to pos during stepPhysics().
        // The purpose of this is to avoid modifying pos during step(),
        // because it's used in many calculations, so if it's modified
        // then the interactions between entities would be subtly different
        // depending on the order in which entities' step() is called...
        // Hope you get what I mean.
        this.addpos = new Point();

        this.rot = 0;
        this.rot_vel = 0;

        this.shotprops = {};
        for(var keyname in this.shotClass) {
            this.shotprops[keyname] = {
                cooldown: 0,
                n_shots: 0,
            };
        };

        this.keys = Key.createKeys();

        this.age = 0;
        this.dead = false;
        this._shouldRemove = false;

        // removed: used by other entities with references to this one,
        // so they know they should stop referencing it
        this.removed = false;
    }
    getPlayer() {
        for(var player of this.field.game.players) {
            if(player.entity === this) return player;
        }
        return null;
    }
    setTeam(team) {
        this.team = team;
        if(team && this.inheritTeamColor) {
            this.lineStrokeStyle = team.color;
            this.circleStrokeStyle = team.color;
        }
    }
    isAlly(other) {
        if(this === other) return true;
        if(this.team && this.team === other.team) return true;
        return this._isAlly(other) || other._isAlly(this);
    }
    _isAlly(other) {
        // May be overridden by subclasses
        return false;
    }
    setMaxHp(maxhp) {
        this.maxhp = maxhp;
        if(this.hp > this.maxhp) this.hp = this.maxhp;
    }
    setHp(hp) {
        this.hp = hp > this.maxhp? this.maxhp: hp;
    }
    heal(addhp) {
        if((this.hp += addhp) > this.maxhp) this.hp = this.maxhp;
    }
    damage(hp) {
        // hp < 0: this thing is invincible
        if(this.hp < 0) return;

        // hp === 0: this thing is already dead
        // (This check is important so we don't call this.die() multiple
        // times on the same thing, which can e.g. result in a LOT of rocks
        // being generated when this is a Rock)
        if(this.hp === 0) return;

        var m = Math.min(hp / 35, 1);
        this.vibrate(Math.max(1000 * m, 200), m, m/4);

        if(this instanceof Ship && NODAMAGE) return;

        this.hp -= hp * DAMAGEMUL;
        if(this.hp < 0) this.hp = 0;
        if(!this.hp) {
            this.dieFromDamage();
        }
    }
    dieFromDamage() {
        // Subclasses may want to override this
        this.vibrate(1500, .2, .5);
        this.die();
    }
    die() {
        this.dead = true;
        this.remove();
    }
    remove() {
        this._shouldRemove = true;
    }
    cleanup() {
        var game = this.field.game;

        for(var player of game.players) {
            if(player.entity !== this) continue;
            player.unsetEntity();
        }

        var camera = game.camera;
        if(camera.target === this) {
            camera.unsetTarget();
        }
    }
    step() {
        for(var keyname in this.shotClass) {
            var shotprops = this.shotprops[keyname];
            if(shotprops.cooldown > 0) shotprops.cooldown--;
        }

        if(this.thrustEffectCooldown > 0) this.thrustEffectCooldown--;

        if(this.is_warping) {
            var speed = this.thrustSpeed * 2 / Math.pow(this.velmul, 3);
            this.thrust(speed, this.rot, {cls: null});
            if(this.age % 3 === 0) {
                this.addThrustEffects(speed, this.rot + Math.PI, {
                    cls: WarpEffect,
                    n_effects: 1,
                    velmul: 0,
                    posrot: Math.PI / 2,
                });
            }

            this.warping_counter++;
            if(this.warping_counter > WARP_AFTER_STEPS) {
                this.finishWarp();
            }
        }

        this.handleKeys();
        for(var keyname of Key.KEYNAMES) {
            this.keys[keyname].step();
        }

        this.heal(this.addhp);

        this.age++;
        if(this.maxAge >= 0 && this.age >= this.maxAge) {
            this.die();
        }
    }
    stepPhysics() {
        if(this.rot_vel < -MAX_ROT_VEL) this.rot_vel = -MAX_ROT_VEL;
        if(this.rot_vel > MAX_ROT_VEL) this.rot_vel = MAX_ROT_VEL;

        this.vel.mul(this.velmul);
        this.rot += this.rot_vel * ROTVELMUL;
        this.rot_vel *= this.rotmul;

        super.stepPhysics();

        // Add addpos to pos, then reset addpos
        this.pos.add(this.addpos);
        this.addpos.set();
    }
    handleKeys() {
        this._handleKeys();
        this.handleShotKeys();
    }
    _handleKeys() {
        // May be overridden entirely, see SuitShip
        if(this.keys.u.wasDown && !this.is_warping) {
            this.thrust(this.thrustSpeed, this.rot);
        }
        if(this.keys.d.wasDown && !this.is_warping) {
            this.thrust(this.reverseSpeed, this.rot + Math.PI);
        }
        if(this.keys.l.wasDown) {
            this.turn(this.rotspeed);
        }
        if(this.keys.r.wasDown) {
            this.turn(-this.rotspeed);
        }
    }
    handleShotKeys() {
        for(var keyname in this.shotClass) {
            var shotprops = this.shotprops[keyname];
            if(!this.keys[keyname]) continue; // e.g. 'extra1'
            if(this.keys[keyname].wasDown && shotprops.cooldown === 0) {
                this.fire(keyname);
            }
        }
    }
    stepCPUKeys(keys) {
        // Do one step of a CPU player deciding which keys to press/release
        // NOTE: keys is player.keys (presumably this.getPlayer().keys)
        for(var keyname in keys) {
            var key = keys[keyname];
            this.stepCPUKey(key);
        }
    }
    stepCPUKey(key) {
        // Handle CPU player's decision of whether to press/release given key
        if(Math.random() < .1) key.down();
        if(Math.random() < .1) key.up();
    }
    turn(rot) {
        this.rot_vel += rot;
    }
    thrust(speed, rot, effect_opts) {
        this.vel.addSpeed(speed, rot);
        if(this.thrustEffectCooldown === 0) {
            this.addThrustEffects(speed, rot + Math.PI, effect_opts);
            this.thrustEffectCooldown += this.thrustEffectEvery;
        }
    }
    addThrustEffects(speed, rot, opts) {
        opts = opts || EMPTY;
        var cls = getDefault(opts.cls, this.thrustEffectClass);
        var n_effects = getDefault(opts.n_effects, this.thrustEffects);
        var velmul = getDefault(opts.velmul, this.thrustEffectVelMul);
        var speedmul = getDefault(opts.speedmul, this.thrustEffectSpeedMul);
        var posrot = getDefault(opts.posrot, this.thrustEffectPosRot);

        if(!cls) return;

        for(var i = 0; i < n_effects; i++) {
            var effect = this.field.addEffect(cls);

            var addrot = getRotVariance(i, n_effects) * posrot;
            effect.pos.copy(this.pos).addSpeed(this.radius, rot + addrot);

            effect.vel.copy(this.vel)
                .mul(velmul)
                .addSpeed(speed * speedmul, rot);

            effect.rot = rot;
        }
    }
    emitPickup(cls, opts) {
        opts = opts || EMPTY;
        var speed_min = getDefault(opts.speed_min, 2);
        var speed_max = getDefault(opts.speed_max, 5);
        var velmul = getDefault(opts.velmul, .75);

        var pickup = this.field.addPickup(cls);
        pickup.rot = this.rot;
        pickup.pos.copy(this.pos);
        var speed = Random.randNumber(speed_min, speed_max);
        pickup.vel.copy(this.vel).mul(velmul)
            .addSpeed(speed, Random.randRotation());

        return pickup;
    }
    emitEffects(cls, n_effects, opts) {
        opts = opts || EMPTY;
        var speed_min = getDefault(opts.speed_min, 0);
        var speed_max = getDefault(opts.speed_max, 0);
        var velmul = getDefault(opts.velmul, 0);
        var addx = getDefault(opts.addx, 0);
        var addy = getDefault(opts.addy, 0);

        for(var i = 0; i < n_effects; i++) {
            var effect = this.field.addEffect(cls);
            effect.rot = this.rot;
            effect.pos.copy(this.pos).addxy(addx, addy);
            var speed = Random.randNumber(speed_min, speed_max);
            effect.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, Random.randRotation());
        }
    }
    emitShots(cls, n_shots, opts) {
        var rot_variance = getDefault(opts.rot_variance, 0);
        var rand_rot_variance = getDefault(opts.rand_rot_variance, 0);
        var speed_min = getDefault(opts.speed_min, 0);
        var speed_max = getDefault(opts.speed_max, 0);

        var velmul = .8;
        for(var i = 0; i < n_shots; i++) {
            var shot = this.field.addShot(cls);
            shot.ship = this.ship;
            shot.setTeam(this.team);
            shot.pos.copy(this.pos);
            shot.rot = this.rot
                + getRotVariance(i, n_shots) * rot_variance
                + Random.randNumber(-.5, .5) * rand_rot_variance;
            var speed = Random.randNumber(speed_min, speed_max);
            shot.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, shot.rot);
        }
    }
    fire(keyname) {
        var shotprops = this.shotprops[keyname];
        var cls = this.shotClass[keyname];
        if(!cls) return;

        var serial_i = shotprops.n_shots % cls.serialShots;
        for(var i = 0; i < cls.initialShots; i++) {
            var shot = this.shoot(cls, i, serial_i);
            this.afterShot(shot);
        }

        if(cls.vibrateDuration) {
            this.vibrate(cls.vibrateDuration,
                cls.vibrateWeakMagnitude,
                cls.vibrateStrongMagnitude);
        }

        shotprops.cooldown += cls.cooldown;
        shotprops.n_shots++;
    }
    afterShot(shot) {
        // Subclasses may add special behaviour...
        shot.afterShotBy(this);
    }
    shoot(cls, shot_i, serial_shot_i) {
        // shot_i: index of this shot. E.g. if 3 are being fired at once,
        // this one might be 0, 1, or 2.

        var shot = this.field.addShot(cls);
        shot.ship = this;
        shot.setTeam(this.team);

        shot.rot = this.rot
            + getRotVariance(shot_i, cls.initialShots)
                * cls.initialRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * cls.serialRotVariance
            + Random.randNumber(-.5, .5)
                * cls.randomRotVariance;

        var posrot = 0
            + getRotVariance(shot_i, cls.initialShots)
                * cls.initialPosRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * cls.serialPosRotVariance
            + Random.randNumber(-.5, .5)
                * cls.randomPosRotVariance;

        var speed = cls.initialSpeed
            + Random.randNumber(-.5, 5)
                * cls.randomSpeedVariance;

        var addpos = this.radius;

        if(cls.isReverseShot) {
            addpos = -addpos;
            speed = -speed;
        }

        shot.pos.copy(this.pos)
            .addSpeed(addpos, shot.rot + posrot);
        shot.vel.copy(this.vel)
            .mul(cls.initialVelMul)
            .addSpeed(speed, shot.rot);
        return shot;
    }
    canCollide(other) {
        if(this === other) return false;
        return this._canCollide(other) && other._canCollide(this);
    }
    _canCollide(other) {
        // Can be overridden by subclasses
        return true;
    }
    colliding(other) {
        if(!this.canCollide(other)) return;
        var d = this.pos.dist(other.pos, this.field.size);
        return d < this.radius + other.radius;
    }
    handleCollision(other) {
        /* We collided with another Entity! Now what?
        (Subclasses are free to answer that question in various ways...) */

        if(this.is_warping && !this.isAlly(other)) {
            this.damage(WARP_COLLISION_DAMAGE);

            // ???...
            // If we don't do this, we could take warp_damage every frame
            // we're touching other...
            other.die();

            this.emitEffects(SmokeEffect, 4, {
                speed_min: 3,
                speed_max: 6,
                velmul: .65,
            });
            this.emitEffects(SparkEffect, 4, {
                speed_min: 3,
                speed_max: 6,
                velmul: .65,
            });
        }
    }
    handleCollisionPhysics(other) {
        /* We collided with another Entity!
        We are both pushed away, and take on some of each others
        velocity.
        NOTE: unlike handleCollision, this method is only called once
        per step for any given pair of entities.
        Subclasses should not override this method. */

        /* r0: number between 0 and 1.
        The closer it is to 1, the larger this.radius is than other.radius.
        If .5, they are equal. */
        var r0 = this.radius / (this.radius + other.radius);
        var r1 = 1 - r0;

        /* Distance between this and other */
        var dist = this.pos.dist(other.pos, this.field.size);

        /* Vibrate players' controllers?? */
        var vib_m = 1 - Math.min(dist / (this.radius + other.radius), 1);
        this.vibrate(Math.max(1000 * vib_m, 200), vib_m * .5 * r1, 0);
        other.vibrate(Math.max(1000 * vib_m, 200), vib_m * .5 * r0, 0);

        /* Avoid div by zero, eh */
        if(dist < .1) {
            dist = .1;
            var p = new Point().addSpeed(dist, Random.randRotation());
            dx += p.x;
            dy += p.y;
        }

        /* Target distance: this and other are just barely touching */
        var tdist = this.radius + other.radius;

        /* dx, dy: shortest vector from this to other, on the torus
        represented by this.field.size */
        var dx = moduloDiff(this.pos.x, other.pos.x, this.field.size.x);
        var dy = moduloDiff(this.pos.y, other.pos.y, this.field.size.y);

        /* mx, my: vector which would move this away from other, to where
        they are just barely touching */
        var mx = dx / dist * (dist - tdist);
        var my = dy / dist * (dist - tdist);

        /* Update addpos */
        var posmul = .5;
        this.addpos.x  += mx * r1 * posmul;
        this.addpos.y  += my * r1 * posmul;
        other.addpos.x -= mx * r0 * posmul;
        other.addpos.y -= my * r0 * posmul;

        /* Update vel */
        var velmul = .7;
        this.vel.x  += mx * r1 * velmul;
        this.vel.y  += my * r1 * velmul;
        other.vel.x -= mx * r0 * velmul;
        other.vel.y -= my * r0 * velmul;

        if(
            /* We are both instances of Ship or Rock */
            (this instanceof Ship || this instanceof Rock) &&
            (other instanceof Ship || other instanceof Rock) &&

            /* We are not BOTH rocks
            (because then we'll just cause each other to spin more
            and more... because rocks always have rotmul = 1) */
            !(this instanceof Rock && other instanceof Rock)
        ) {
            /* Update rot_vel */
            var rot_velmul = .15;
            this.rot_vel  += other.rot_vel * r1 * rot_velmul;
            other.rot_vel += this.rot_vel  * r0 * rot_velmul;
        }
    }
    canWarp() {
        // May be overridden by subclasses
        return !this.is_warping;
    }
    beginWarp() {
        this.is_warping = true;
        this.vel.addSpeed(this.thrustSpeed * 5, this.rot);
    }
    finishWarp() {
        var player = this.getPlayer();
        player.useFuel(WARP_FUEL);

        var progress = this.field.game.progress;
        if(progress.canProceed()) {
            // Immediately warp to next area
            progress.proceed();
            this.field.game.warp();
        } else {
            // Pop up a menu, so player can choose where to warp to next
            this.field.game.setMenu(WarpMapMenu);
            var player = this.getPlayer();
            player.shipHp = this.hp;
            this.die();
        }
    }
    render(canvas, camera) {
        var fade = 1;
        if(this.fadeWithAge && this.maxAge > 0) {
            // maxFade: don't set fade lower than 1 - maxFade, that
            // would be too close to 0, so we wouldn't be able to see
            // the Entity
            var maxFade = .85;
            fade = 1 - (this.age / this.maxAge) * maxFade;
        }

        var ctx = canvas.getContext('2d');
        ctx.globalAlpha = fade;
        super.render(canvas, camera);
        ctx.globalAlpha = 1;
    }
    renderCircle(canvas, camera, addx, addy) {
        super.renderCircle(canvas, camera, addx, addy);
        if(this.shouldRenderCircleLine) {
            this.renderCircleLine(canvas, camera, addx, addy);
        }
    }
    renderCircleLine(canvas, camera, addx, addy) {
        /* Render a little line indicating this.rot */
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var p = new Point(this.radius).rotate(this.rot);
        var x1 = x0 + p.x;
        var y1 = y0 + p.y;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
    }
    vibrate(duration, weakMagnitude, strongMagnitude) {
        if(!VIBRATE) return;
        var player = this.getPlayer();
        if(!player) return;
        if(player.gamepad && player.gamepad.vibrationActuator) {
            player.gamepad.vibrationActuator.playEffect("dual-rumble", {
              startDelay: 0,
              duration: duration,
              weakMagnitude: weakMagnitude,
              strongMagnitude: strongMagnitude,
            });
        }
    }
}

class Camera extends FieldParticle {
    velmul = .7;
    springmul = .1;

    constructor(field) {
        super(field);
        this.target = null;
        this.pos.setMidpoint(field.size);
    }
    setTarget(target) {
        this.unsetTarget();
        this.target = target;
        this.pos.copy(target.pos);
    }
    unsetTarget() {
        if(!this.target) return;
        this.target = null;
    }
    step() {
        this.vel.mul(this.velmul);

        if(this.target) {
            var x0 = this.pos.x;
            var y0 = this.pos.y;
            var x1 = this.target.pos.x;
            var y1 = this.target.pos.y;
            this.vel.x += moduloDiff(x0, x1, this.field.size.x)
                * this.springmul;
            this.vel.y += moduloDiff(y0, y1, this.field.size.y)
                * this.springmul;
        }
    }
}

class Pickup extends Entity {
    static name = 'Pickup';

    radius = 6 * RADIUSMUL;
    velmul = .95;

    circleStrokeStyle = 'rgb(255,255,255,.75)';
    circleFillStyle   = 'rgba(255,255,255,.15)';
    circleLineWidth = 2;

    picture = Picture.newPolygon(3);

    constructor(field) {
        super(field);

        var r = Random.randInt(3);
        this.radius = (4 + r * 1.25) * RADIUSMUL;
        this.pickupAmount = 5 + r * 5;
    }
    handleCollision(other) {
        if(other instanceof Ship && other.canPickup(this)) {
            this.handlePickedUp(other);
        }
        super.handleCollision(other);
    }
    handlePickedUp(other) {
        this.die();
    }
    die() {
        this.emitEffects(PickupEffect, 6, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class EnergyPickup extends Pickup {
    static name = 'Energy';

    circleStrokeStyle = ENERGY_COLOR;
    picture = ENERGY_PICTURE;

    handlePickedUp(other) {
        other.heal(this.pickupAmount);
        super.handlePickedUp(other);
    }
}

class FuelPickup extends Pickup {
    static name = 'Fuel';

    circleStrokeStyle = FUEL_COLOR;
    picture = FUEL_PICTURE;

    handlePickedUp(other) {
        var player = other.getPlayer();
        if(player) {
            player.addFuel(this.pickupAmount);
        }
        super.handlePickedUp(other);
    }
}

class GoldPickup extends Pickup {
    static name = 'Gold';

    circleStrokeStyle = GOLD_COLOR;
    picture = GOLD_PICTURE;

    handlePickedUp(other) {
        var player = other.getPlayer();
        if(player) {
            player.addGold(this.pickupAmount);
        }
        super.handlePickedUp(other);
    }
}


class Trinket {
    /* Something with no particular use, which players can obtain */

    constructor(name, description) {
        this.name = name;
        this.description = description;
    }
}

class Player {

    // trinkets: Array of Trinket
    trinkets = [];

    shipClass = null;

    // shipHp: saved between areas when warping.
    // MAYBE TODO: make a new class, StuffToSave or whatever, so we can
    // save more than just hp?..
    shipHp = null;

    // addmaxhp: whenever a new ship is created for us, add this much to its
    // max hp.
    addmaxhp = 0;

    maxfuel = DEFAULT_MAXFUEL;
    fuel = DEFAULT_MAXFUEL / 2;

    maxgold = MAXGOLD;
    gold = DEBUG? MAXGOLD: 0;

    shipClasses = DEBUG? SHIP_CLASSES.getValues():
        [FighterShip, ScoutShip, AssaultShip];

    // gamepad: an HTML5 Gamepad instance, or null
    gamepad = null;

    constructor(game) {
        this.game = game;
        this.entity = null;
        this.team = TEAMS.get('green');
        this.keys = Key.createKeys();
        this.gamepad_keys = Key.createKeys();
    }
    addMaxHp(hp) {
        this.addmaxhp += hp;
        if(this.entity) {
            this.entity.maxhp += hp;
            this.entity.hp += hp;
        }
    }
    addFuel(fuel) {
        this.fuel += fuel;
        if(this.fuel > this.maxfuel) this.fuel = this.maxfuel;
    }
    useFuel(fuel) {
        this.fuel -= fuel;
        if(this.fuel < 0) this.fuel = 0;
    }
    addGold(gold) {
        this.gold += gold;
        if(this.gold > this.maxgold) this.gold = this.maxgold;
    }
    useGold(gold) {
        this.gold -= gold;
        if(this.gold < 0) this.gold = 0;
    }
    canWarp() {
         return this.fuel >= WARP_FUEL;
    }
    beginWarp() {
        this.entity.beginWarp();
    }
    setTeam(team) {
        this.team = team;
        if(this.entity) this.entity.setTeam(team);
    }
    setEntity(entity) {
        this.unsetEntity();
        this.entity = entity;
        entity.setTeam(this.team);
    }
    unsetEntity() {
        if(!this.entity) return;
        this.entity = null;
    }
    createShip(cls) {
        cls = cls || this.shipClass;
        this.shipClass = cls;

        var ship = this.game.addShip(cls);
        ship.pos.setRandomWithin(this.game.field.size);
        ship.rot = Random.randRotation();
        ship.maxhp += this.addmaxhp;
        ship.hp += this.addmaxhp;
        this.setEntity(ship);
        return ship;
    }
    reviveShip() {
        // "Revive" the ship "killed" when you warped from previous area
        var ship = this.createShip();
        if(this.shipHp !== null) ship.setHp(this.shipHp);
        return ship;
    }
    step() {
        if(!this.entity) return;

        if(this.fuel < WARP_FUEL) this.addFuel(DEFAULT_ADDFUEL);

        if(this.gamepad) {
            // If a gamepad is connected for this player, update
            // this.gamepad_keys based on gamepad's input
            this.handleGamepadInput();
        } else {
            // Reset gamepad keys if no gamepad is connected
            for(var keyname of Key.KEYNAMES) {
                var gamepad_key = this.gamepad_keys[keyname];
                gamepad_key.up();
            }
        }

        for(var keyname of Key.KEYNAMES) {
            var key = this.keys[keyname];
            var gamepad_key = this.gamepad_keys[keyname];

            this.entity.keys[keyname].copy(key).union(gamepad_key);

            key.step();
            gamepad_key.step();
        }
    }
    handleGamepadInput() {
        var gamepad = this.gamepad;

        for(var button_index in GAMEPAD_BUTTONS) {
            var keyname = GAMEPAD_BUTTONS[button_index];
            var key = this.gamepad_keys[keyname];
            var button = gamepad.buttons[button_index];
            if(button.pressed) key.down();
            else key.up();
        }

        var x_axis = gamepad.axes[0];
        var y_axis = gamepad.axes[1];
        this.gamepad_keys.l.set(x_axis < -GAMEPAD_AXIS_THRESHOLD);
        this.gamepad_keys.r.set(x_axis >  GAMEPAD_AXIS_THRESHOLD);
        this.gamepad_keys.u.set(y_axis < -GAMEPAD_AXIS_THRESHOLD);
        this.gamepad_keys.d.set(y_axis >  GAMEPAD_AXIS_THRESHOLD);
    }
}

class CPUPlayer extends Player {

    step() {

        // Press/release keys
        if(this.entity) {
            // Entity decides which keys to press/release
            // (Basically so each subclass of Ship can override the default
            // "press random keys" implementation and maybe do something
            // slightly smarter for its shotClasses.
            // TODO: so maybe it's better to implement CPU stuff in CPUPlayer,
            // by switching on entity's shotClasses?..)
            this.entity.stepCPUKeys(this.keys);
        } else {
            for(var key of this.keys) key.down();
        }

        super.step();
    }
}

class Game {

    constructor(canvas, progress) {
        canvas.addEventListener('keydown', this.onKeyDown.bind(this));
        canvas.addEventListener('keyup', this.onKeyUp.bind(this));

        window.addEventListener('gamepadconnected',
            this.onGamepadActivity.bind(this));
        window.addEventListener('gamepaddisconnected',
            this.onGamepadActivity.bind(this));

        this.canvas = canvas;
        this.intervalId = 0;
        this.players = [];
        this.menu = null;

        // Whether to bother polling for gamepads
        this.gamepadsConnected = false;

        // HTML5 GamepadList or null
        this.gamepads = null;

        /* Hashmap from keyCode values to Key instances belonging to
        Player instances in this.players */
        this.keysByCode = {};

        this.progress = progress;
        this._createField();
    }
    _createField() {
        /* Create this.field and related things */

        // NOTE: need to set this.cpus before calling the Field constructor
        this.cpus = [];

        var template = this.progress.template;
        var size = template.getSize();

        // NOTE: field.populate needs to be a separate method from
        // field.constructor, so that field.populate can rely on
        // field.game.field being set.
        this.field = new Field(this, size);
        this.field.populate(template);

        this.camera = new Camera(this.field);
    }
    warp() {
        /* Warp to the next Field */

        var targetPlayer = null;
        if(this.camera.target) targetPlayer = this.camera.target.getPlayer();

        this.camera.unsetTarget();

        this.field.cleanup();
        this._createField();

        for(var player of this.players) player.reviveShip();

        if(targetPlayer) this.camera.setTarget(targetPlayer.entity);

        if(this.field.shop) this.setMenu(ShopMenu);
    }
    onKeyDown(event) {
        if(!event.repeat) this.keyDown(event.keyCode);
        event.preventDefault();
    }
    onKeyUp(event) {
        if(!event.repeat) this.keyUp(event.keyCode);
        event.preventDefault();
    }
    onGamepadActivity(event) {
        // This handler is for either of these events:
        //   'gamepadconnected'
        //   'gamepaddisconnected'
        // ...why? Well you see:
        // Apparently the Gamepad API can be a bit wonky, and fire
        // 'gamepaddisconnected' when gamepads are connected.
        // Also, I've found that holding onto a Gamepad object is no
        // good -- its buttons are never updated.
        // So we need to call navigator.getGamepads() ever frame anyway.
        // SOOOO, instead of trying to detect when gamepads are
        // connected/disconnected, we just listen for either event, and
        // in either case *somebody was touching a gamepad at some point*,
        // so we flip a flag which tells us to bother polling
        // navigator.getGamepads() every frame.
        // Make sense?
        // Hahahahaha sure
        this.gamepadsConnected = true;
    }
    mapKey(key, keyCode) {
        this.keysByCode[keyCode] = key;
    }
    keyDown(keyCode) {
        if(this.menu) {
            this.menu.keyDown(keyCode);
        } else if(keyCode === KEY_ESCAPE) {
            this.setMenu(ChooseShipMenu);
        } else if(keyCode === KEY_TAB) {
            this.setMenu(TabMapMenu);
        } else if(keyCode === KEY_WARP) {
            // HACK!
            var ship = this.camera.target;
            if(ship && ship.canWarp()) {
                var player = ship.getPlayer();
                if(player && player.canWarp()) {
                    player.beginWarp();
                }
            }
        } else {
            var key = this.keysByCode[keyCode];
            if(key) key.down();
        }
    }
    keyUp(keyCode) {
        if(this.menu instanceof TabMapMenu && keyCode === KEY_TAB) {
            this.unsetMenu();
        } else if(this.menu) {
            this.menu.keyUp(keyCode);
        } else {
            var key = this.keysByCode[keyCode];
            if(key) key.up();
        }
    }
    setMenu(cls) {
        var previous = this.menu;
        this.menu = new cls(this);
        this.menu.previous = previous;

        // Unpress all keys so our ship doesn't fly in circles
        // or whatever while menu is open
        for(var key of Object.values(this.keysByCode)) key.up();
    }
    unsetMenu() {
        if(!this.menu) return;
        this.menu.cleanup();
        this.menu = this.menu.previous;
    }
    addShip(cls) {
        return this.field.addShip(cls);
    }
    addPlayer() {
        var player = new Player(this);
        this.players.push(player);
        return player;
    }
    addCPUPlayer() {
        var player = new CPUPlayer(this);
        this.cpus.push(player);
        return player;
    }
    step() {

        // Unset player.gamepad for all players.
        for(var player of this.players) player.gamepad = null;

        // Maybe poll for gamepads, and set player.gamepad for players
        // with a connected gamepad.
        if(this.gamepadsConnected) {
            var gamepads = navigator.getGamepads();
            for(var i = 0; i < gamepads.length; i++) {
                // HACK: we associate gamepads to players in the order
                // gamepads are connected, i.e. the first gamepad to be
                // connected is associated with the first player.
                // TODO: fix this (whenever we get around to adding some
                // kind of UI for choosing controls)
                var player = this.players[i];
                if(!player) continue;
                player.gamepad = gamepads[i];
            }
        }

        for(var player of this.players) player.step();
        for(var player of this.cpus) player.step();

        this.progress.map.step();
        this.field.step();
        this.camera.step();
        this.camera.stepPhysics();
    }
    render() {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        this.field.render(canvas, this.camera);
        if(this.menu) {
            this.menu.render();
        } else {
            var text = this.progress.template.text;
            if(text && !HIDE_TEXT) text.render(canvas);
        }
        if(this.camera.target) this.renderEntityStats(this.camera.target);
    }
    renderTextPictures(text, writer, x0, y0, letterWidth, letterHeight, padWidth, padHeight, render_opts) {
        writer = getDefault(writer, blockyWriter);
        x0 = getDefault(x0, 0);
        y0 = getDefault(y0, 0);
        letterWidth = getDefault(letterWidth, 14);
        letterHeight = getDefault(letterHeight, 12);
        padWidth = getDefault(padWidth, 4);
        padHeight = getDefault(padHeight, 4);

        var x = x0;
        var y = y0;

        // "radius" x and y are just half the width * height.
        // Weird nomenclature, but anyway they are ultimately used as
        // multipliers of picture's points' x and y positions.
        var radius_x = letterWidth / 2;
        var radius_y = letterHeight / 2;

        var pictures = writer.getPictures(text);
        for(var picture of pictures) {

            // NOTE: we add radius_x/y (that is, half letter's width/height)
            // to x and y, because the letters' origins are in their centers,
            // but for rendering text we want to treat their top-left
            // corners as their origins.
            picture.render(this.canvas,
                x + radius_x, y + radius_y,
                0, radius_x, radius_y, render_opts);

            x += letterWidth + padWidth;
        }
    }
    renderEntityStats(entity) {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');

        // Arguments to this.renderTextPictures:
        var writer = blockyWriter;
        var letterWidth = 20;
        var letterHeight = 24;
        var padWidth = 4;
        var padHeight = 4;

        // Number of lines of text we plan to render (bit of a hack, this)
        var n_lines = 3;

        var x0 = padWidth * 2;
        var y0 = canvas.height
            - letterHeight * n_lines
            - padHeight * (n_lines - 1)
            - padHeight * 2;
        var x = x0;
        var y = y0;
        var dx = letterWidth + padWidth;
        var dy = letterHeight + padHeight;

        var game = this;
        function renderText(text, strokeStyle) {
            var is_colored = strokeStyle !== undefined;
            strokeStyle = getDefault(strokeStyle, 'rgb(255,255,255)');
            var render_opts = {
                lineWidth: 2,
                strokeStyle: strokeStyle,
                fillStyle: is_colored? 'rgba(255,255,255,.25)':
                    'rgb(255,255,255)',
            };
            game.renderTextPictures(text, writer, x, y,
                letterWidth, letterHeight, padWidth, padHeight, render_opts);
            x += dx;
        }
        function newline() {
            x = x0;
            y += dy;
        }
        var parseAmount = amount =>
            parseInt(amount).toString().padStart(3, ' ');

        renderText('E', ENERGY_COLOR);
        var text = ': ' + parseAmount(entity.hp)
            + ' / ' + parseAmount(entity.maxhp);
        if(entity.rock) {
            var rock = entity.rock;
            text += ' [' + parseAmount(rock.hp)
                + ' / ' + parseAmount(rock.maxhp) + ']';
        }
        renderText(text);
        newline();

        var player = entity.getPlayer();
        if(player) {
            renderText('F', FUEL_COLOR);
            renderText(': ' + parseAmount(player.fuel)
                + ' / ' + parseAmount(player.maxfuel));
            newline();

            renderText('G', GOLD_COLOR);
            renderText(': ' + parseAmount(player.gold));
            newline();
        }
    }
    renderTitle(title, subtitles) {
        var canvas = this.canvas;
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';

        var x = canvas.width / 2;
        var y = canvas.height / 4;

        ctx.font = 'normal bold 40px sans-serif';
        ctx.fillText(title, x, y);
        y += 40;

        if(subtitles) for(var subtitle of subtitles) {
            ctx.font = 'normal bold 20px sans-serif';
            ctx.fillText(subtitle, x, y);
            y += 20;
        }
    }
    intervalCallback() {
        /* Callback for use with setInterval */
        if(TIMING) var t0 = new Date();
        try {
            this.step();
            this.render();
        } catch(ex) {
            // Stop the same error from throwing repeatedly.
            // Don't set this.intervalId to 0 though, for debugging
            // purposes.
            clearInterval(this.intervalId);

            throw ex;
        }
        if(TIMING) {
            var t1 = new Date();
            console.log('TIMING: ' + String(t1 - t0));
        }
    }
    play(millis) {
        millis = getDefault(millis, 30);
        if(this.intervalId) clearInterval(this.intervalId);
        var callback = this.intervalCallback.bind(this);
        this.intervalId = setInterval(callback, millis);
    }
    pause() {
        if(!this.intervalId) return;
        clearInterval(this.intervalId);
        this.intervalId = 0;
    }
}

class Menu {
    constructor(game) {
        this.game = game;

        // previous: Menu instance or null.
        // (The Menu to return to when this one is closed)
        this.previous = null;
    }
    cleanup() {
    }
    render() {
    }
    keyDown(keyCode) {
    }
    keyUp(keyCode) {
    }
}

class ShopMenu extends Menu {
    player = null;
    shop = null;

    // item_i: index into this.shop.items, or -1 for "leave the shop"
    item_i = -1;

    // string, set by this.update()
    title = null;

    // Array of string, set by this.update()
    subtitles = null;

    constructor(game) {
        super(game);

        if(!game.players.length) {
            // Should never happen... *shifty eyes*
            throw new Error('No players!');
        }

        // Hack: choose first player
        this.player = game.players[0];

        this.shop = game.field.shop;
        this.update();
    }
    getSelectedItem() {
        if(!this.shop.items.length) return null;
        if(this.item_i < 0) return null;
        return this.shop.items[this.item_i];
    }
    update() {
        this.title = this.shop.name;

        this.subtitles = this.shop.description.slice();
        this.subtitles.push('');

        var LBRACKET = '> ';
        var RBRACKET = ' <';

        if(!this.shop.items.length) {
            this.subtitles.push('...nothing left to buy!');
        }

        var subtitle = 'Leave the shop';
        if(this.item_i === -1) {
            subtitle = LBRACKET + subtitle + RBRACKET;
        }
        this.subtitles.push(subtitle);

        var selected_item = this.getSelectedItem();

        for(var i = 0; i < this.shop.items.length; i++) {
            var item = this.shop.items[i];

            var subtitle = item.name;
            if(item.bought) {
                subtitle = '[BOUGHT] ' + subtitle;
            } else if(item.price > this.player.gold) {
                subtitle = '[CAN\'T AFFORD] ' + subtitle;
            } else if(item.cantBuy(this.player)) {
                subtitle = '[CAN\'T BUY] ' + subtitle;
            }
            if(item === selected_item) {
                subtitle = LBRACKET + subtitle + RBRACKET;
            }
            this.subtitles.push(subtitle);
        }

        if(selected_item) {
            this.subtitles.push('');
            this.subtitles.push(selected_item.description);

            var cantBuy = selected_item.cantBuy(this.player);
            if(cantBuy) this.subtitles.push(
                "[Can't buy this: " + cantBuy + ']');
        }
    }
    keyDown(keyCode) {
        if(!this.player) return;
        if(keyCode === KEY_U) {
            if(this.item_i > -1) this.item_i--;
            this.update();
        } else if(keyCode === KEY_D) {
            if(this.item_i < this.shop.items.length - 1) this.item_i++;
            this.update();
        } else if(keyCode === KEY_ENTER) {
            if(this.item_i === -1) {
                this.finish();
            } else {
                var item = this.getSelectedItem();
                if(item && !item.cantBuy(this.player)) {
                    item.buy(this.player);
                    this.update();
                }
            }
        } else if(keyCode === KEY_ESCAPE) {
            this.finish();
        }
    }
    render() {
        this.game.renderTitle(this.title, this.subtitles);
    }
    finish() {
        // That is, "leave the shop"
        this.game.unsetMenu();
    }
}

class ChooseShipMenu extends Menu {
    player = null;
    ship_class_i = 0;

    // Array of string, set by this.updateShipClass()
    subtitles = null;

    constructor(game) {
        super(game);

        if(!game.players.length) {
            // Should never happen... *shifty eyes*
            throw new Error('No players!');
        }

        // Hack: choose first player
        var player = game.players[0];
        this.setPlayer(player);
    }
    setPlayer(player) {
        this.player = player;

        var ship = player.entity;
        this.ship_class_i = player.shipClass === null?
            0: player.shipClasses.indexOf(player.shipClass);

        this.updateShipClass();
    }
    render() {
        this.game.renderTitle('Get Ready', this.subtitles);
    }
    keyDown(keyCode) {
        if(!this.player) return;
        if(keyCode === KEY_L) {
            this.ship_class_i = modulo(this.ship_class_i - 1,
                player.shipClasses.length);
            this.updateShipClass();
        } else if(keyCode === KEY_R) {
            this.ship_class_i = modulo(this.ship_class_i + 1,
                player.shipClasses.length);
            this.updateShipClass();
        } else if(keyCode === KEY_ENTER) {
            this.game.unsetMenu();
        }
    }
    updateShipClass() {
        var old_ship = this.player.entity;

        var cls = player.shipClasses[this.ship_class_i];
        var ship = this.player.createShip(cls);

        // Point the ship upwards
        ship.rot = Math.PI / 2;

        if(old_ship) {
            ship.pos.copy(old_ship.pos);
            ship.vel.copy(old_ship.vel);
            ship.rot = old_ship.rot;

            old_ship.remove();
            // HACK: old_ship has only been marked for removal, we now
            // manually call the function which truly removes it.
            // We do this because otherwise, the old and new ships
            // coexist for one frame, which is enough time for them
            // to collide with each other...
            this.game.field.removeEntities(this.game.field.ships);
        } else {
            ship.pos.setMidpoint(this.game.field.size);
        }

        this.game.camera.setTarget(ship);

        this.subtitles = [
            'Choose your ship',
            '(Left/right arrow keys + Enter)',
            '[' + cls.name + ']',
        ];
    }
}

class MapMenu extends Menu {
    /* A menu which shows game.progress.map */

    node = null;
    edge_i = 0;

    // edge: calculated by updateEdge() based on node, edge_i
    // (Never null!)
    edge = null;

    // text: instance of Text, calculated by updateEdge()
    text = null;

    constructor(game) {
        super(game);

        var node = game.progress.node;
        var edge = game.progress.edge;
        var edge_i = edge? node.getEdgeIndex(edge): 0;
        this.setNode(node, edge_i);
    }
    updateEdge() {
        var n_edges = this.node.numEdges();
        var edge_i = modulo(this.edge_i, n_edges);
        this.edge = this.node.getEdge(edge_i);
        this.updateText();
    }
    updateText() {
        var title = this.node.title;
        var lines = [];

        var progress = this.game.progress;
        var node1 = this.edge.getNode1();
        if(progress.edge && this.edge === progress.edge) {
            lines.push('Travelling to: ' + node1.title);
            lines.push(
                'Progress: ' + progress.edgeDist
                + ' / ' + progress.edge.getLen());
        } else {
            lines.push('Towards: ' + node1.title);
            lines.push('Distance: ' + this.edge.getLen());
        }

        this.addControls(lines);

        this.text = new Text(title, lines);
    }
    addControls(lines) {
        lines.push('');
        lines.push('Left/right: select branch');
    }
    setNode(node, edge_i) {
        this.node = node;
        this.edge_i = getDefault(edge_i, 0);
        this.updateEdge();
    }
    keyDown(keyCode) {
        if(keyCode === KEY_L) {
            this.edge_i--;
            this.updateEdge();
        } else if(keyCode === KEY_R) {
            this.edge_i++;
            this.updateEdge();
        }
    }
    render() {
        var canvas = this.game.canvas;
        var ctx = canvas.getContext('2d');

        this.text.render(this.game.canvas);

        var progress = this.game.progress;
        var map = progress.map;

        var progressPos = progress.getPos();
        var x0 = canvas.width / 2 - progressPos.x;
        var y0 = canvas.height / 2 - progressPos.y;

        for(var node of map.nodes) {
            var x = x0 + node.pos.x;
            var y = y0 + node.pos.y;
            var radius = node.radius;
            var strokeStyle = node.strokeStyle;
            var fillStyle = node.fillStyle;
            var lineWidth = 3;

            if(node === this.node) {
                strokeStyle = '#fff';
                lineWidth += 2;
            }

            ctx.strokeStyle = strokeStyle;
            ctx.fillStyle = fillStyle;
            ctx.lineWidth = lineWidth;
            renderCircle(ctx, x, y, 0, radius);

            for(var edge of node.edges) {
                var node2 = edge.node1;
                var x2 = x0 + node2.pos.x;
                var y2 = y0 + node2.pos.y;
                var strokeStyle = edge.strokeStyle;
                var lineWidth = 2;

                if(edge === this.edge.edge) {
                    strokeStyle = '#fff';
                    lineWidth += 2;
                }

                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = strokeStyle;

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.closePath();
                ctx.stroke();
            }
        }
    }
}

class TabMapMenu extends MapMenu {
    /* Menu player sees while holding tab (to view the entire map) */

    addControls(lines) {
        super.addControls(lines);
        lines.push('Up        : follow branch');
    }
    keyDown(keyCode) {
        if(keyCode === KEY_U) {
            this.setNode(this.edge.getNode1());
        } else {
            super.keyDown(keyCode);
        }
    }
}

class WarpMapMenu extends MapMenu {
    /* Menu player uses to choose where to warp to next */

    addControls(lines) {
        super.addControls(lines);
        lines.push('Enter     : finish warping');
    }
    keyDown(keyCode) {
        if(keyCode === KEY_ENTER) {
            var progress = this.game.progress;
            progress.setEdge(this.edge);
            progress.proceed();

            // We do this before calling game.warp(), because game.warp()
            // may call game.setMenu(ShopMenu)
            this.game.unsetMenu();

            this.game.warp();

            // HACK: we assume first player is who camera should be targeting.
            // The reason we have to do this is that finishWarp currently kills
            // the ship, so game.camera.target gets set to null, so game.warp()
            // has no way to know what the camera should be pointed at.
            this.game.camera.setTarget(this.game.players[0].entity);
        } else {
            super.keyDown(keyCode);
        }
    }
}

class Effect extends Entity {
    static name = 'Effect';
    fadeWithAge = true;
}

class WarpEffect extends Effect {
    radius = 2 * RADIUSMUL;
    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'rgba(0,255,255,.75)';
    circleFillStyle = 'transparent';

    velmul = .6;
    maxAge = 20;

    step() {
        this.radius += .5 * RADIUSMUL;
        super.step();
    }
}

class SmokeEffect extends Effect {
    radius = 7 * RADIUSMUL;
    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgba(200,200,200,.2)';
    velmul = 1;
    maxAge = 20;
}

class PickupEffect extends Effect {
    radius = 4 * RADIUSMUL;

    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgba(255,255,255,.3)';
    picture = Picture.newPolygon(4);

    velmul = .95;
    maxAge = 20;
}

class SnowflakeEffect extends Effect {
    radius = 4 * RADIUSMUL;

    circleStrokeStyle = 'rgb(255,255,255,.5)';

    picture = new Picture([
        new Shape([
            Point.unit(0 / 6),
            Point.unit(3 / 6),
        ], {fill: false}),
        new Shape([
            Point.unit(1 / 6),
            Point.unit(4 / 6),
        ], {fill: false}),
        new Shape([
            Point.unit(2 / 6),
            Point.unit(5 / 6),
        ], {fill: false}),
    ]);

    velmul = .85;
    maxAge = 20;
}

class FlameSmokeEffect extends SmokeEffect {
    radius = 4 * RADIUSMUL;
    circleFillStyle = 'rgba(75,75,50,.5)';
}

class ThrustEffect extends Effect {
    radius = 5 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(0,255,255,.7)';
    trailLineWidth = 3;
    maxAge = 20;
}

class SmokeThrustEffect extends SmokeEffect {
    radius = 3 * RADIUSMUL;
}

class SparkEffect extends Effect {
    radius = 3 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(255,255,0,.7)';
    trailLineWidth = 3;
    velmul = .95;
    maxAge = 20;
}

class Ship extends Entity {
    static maxhp = 100;

    static name = 'Ship';

    canEmitGold() {
        // Can be overridden by subclasses
        return true;
    }
    canPickup(pickup) {
        // Can be overridden by subclasses
        return true;
    }
    dieFromDamage() {
        if(
            this.canEmitGold() &&
            Math.random() < this.field.template.gold_chance
        ) {
            this.emitPickup(GoldPickup);
        }
        super.dieFromDamage();
    }
    die() {
        this.emitEffects(SmokeEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class FighterShip extends Ship {
    static name = 'Fighter';

    radius = 7 * RADIUSMUL;
    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .45;

    static maxhp = 100;

    shotClass = {
        x: DoubleShot,
        y: DoubleMissileShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {stroke: false}),
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {fill: false, close: false}),
    ]);
}

class ScoutShip extends Ship {
    static name = 'Scout';
    radius = 6 * RADIUSMUL;

    static maxhp = 100;
    wingsOut = true;

    shotClassWingsOut = {
        x: QuadrupleShot,
        y: null,
    };

    shotClassWingsIn = {
        x: RapidDoubleShot,
        y: null,
    };

    pictureWingsOut = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point( -.2,   -1.8),
            new Point( -.1,   -.75),
            new Point( 1.2,    0),
            new Point( -.1,    .75),
            new Point( -.2,    1.8),
        ]),
    ]);

    pictureWingsIn = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point(- .7,   -.75),
            new Point( 1.2,    0),
            new Point(- .7,    .75),
        ]),
    ]);

    constructor(field) {
        super(field);
        this._updateStats();
    }
    _updateStats() {
        if(this.wingsOut) {
            this.thrustSpeed = 2.25;
            this.reverseSpeed = 1.5;
            this.velmul = .85;
            this.rotspeed = Math.PI / 25;
            this.rotmul = .6;
            this.picture = this.pictureWingsOut;
            this.shotClass = this.shotClassWingsOut;
        } else {
            this.thrustSpeed = 2.75;
            this.reverseSpeed = 1.75;
            this.velmul = .95;
            this.rotspeed = Math.PI / 30;
            this.rotmul = .4;
            this.picture = this.pictureWingsIn;
            this.shotClass = this.shotClassWingsIn;
        }
    }
    step() {

        var keyname = 'y';
        var shotprops = this.shotprops[keyname];
        if(shotprops.cooldown === 0) {
            var wingsOut = !this.keys[keyname].wasDown;
            if(wingsOut != this.wingsOut) {
                this.wingsOut = wingsOut;
                this._updateStats();
                shotprops.cooldown += 5;
            }
        }

        super.step();
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .05) key.up();
        } else {
            super.stepCPUKey(key);
        }
    }
}

class RamShip extends Ship {
    static name = 'Ram';
    radius = 7 * RADIUSMUL;

    thrustSpeed = 1.5;
    reverseSpeed = .75;
    velmul = .97;
    rotspeed = Math.PI / 28;
    rotmul = .65;

    ramSpeed = 1.25;
    ramDamage = 35;
    minRamSpeed = 25;
    maxRamSpeed = 50;

    static maxhp = 100;

    shotClass = {
        x: ShortDoubleShot,
        y: null,
        extra1: ReverseFlameShot,
    };

    thrustEffects = 2;
    thrustEffectPosRot = Math.PI / 2;

    constructor(field) {
        super(field);

        this.shape_left = new Shape([
            new Point(-1.2, -.95),
            new Point( 1.2,    0),
            new Point(-1  ,    0),
        ]);
        this.shape_right = this.shape_left.clone().flip();
        this.shape_middle = Shape.newPolygon(4,
            {radiusmul: 0, rot: Math.PI / 4},
        ).mul(.2);
        this.picture = new Picture([
            this.shape_left,
            this.shape_right,
            this.shape_middle,
        ]);
    }
    isRamming() {
        return this.keys.y.wasDown && this.vel.dist() >= this.minRamSpeed;
    }
    fire(keyName) {
        if(keyName == 'x' && this.isRamming()) return;
        super.fire(keyName);
    }
    damage(hp) {
        if(this.isRamming()) {
            var hpmul = 1 - linear(0, .75, this.getRamPercent());
            hp *= hpmul;
        }
        super.damage(hp);
    }
    step() {
        super.step();

        var isRamming = this.isRamming();

        var ramPercent = this.getRamPercent();
        var ram_gap = .6 * ramPercent;
        if(isRamming) ram_gap *= 2;
        this.shape_left.pos.y = -ram_gap / 2;
        this.shape_right.pos.y = ram_gap / 2;
        this.shape_middle.radiusmul = ramPercent * (isRamming? 2: 1);

        if(isRamming) {
            this.shotClass.extra1 = RamFlameShot;
            this.fire('extra1');

            this.vel.addSpeed(this.ramSpeed, this.rot);
        } else {
            this.shotClass.extra1 = ReverseFlameShot;
            if(this.keys.y.wasDown) this.fire('extra1');
        }
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .001) key.up();
        } else if(key.name === 'u') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .001) key.up();
        } else if(key.name === 'l' || key.name === 'r' || key.name === 'd') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .05) key.up();
        } else {
            super.stepCPUKey(key);
        }
    }
    getRamPercent() {
        // Return number between 0 and 1, representing how far we are
        // to max ram speed, where 0 indicates we have just started
        // ramming (our velocity is just high enough that isRamming()
        // is true).
        var speed = this.vel.dist();
        if(speed <= this.minRamSpeed) return 0;
        if(speed >= this.maxRamSpeed) return 1;
        return (speed - this.minRamSpeed)
            / (this.maxRamSpeed - this.minRamSpeed);
    }
    handleCollision(other) {
        var isAlly = other instanceof Ship? other.isAlly(this): false;
        if(this.isRamming() && !isAlly) {
            var damagemul = this.getRamPercent();
            var damage = this.ramDamage * damagemul;
            other.damage(damage);

            var hitVelMul = .5;
            other.vel.addMul(this.vel, hitVelMul);

            var velmul = .5;
            this.vel.mul(velmul);

            // r0: number between 0 and 1
            //   0 -> this.radius is infinitely bigger than other.radius
            //  .5 -> this.radius and other.radius are same size
            //   1 -> other.radius is infinitely bigger than this.radius
            var r0 = this.radius / (this.radius + other.radius);

            // addx/addy: vector sending this.pos to the point where this
            // touches other
            var dx = other.pos.x - this.pos.x;
            var dy = other.pos.y - this.pos.y;
            var addx = dx * r0;
            var addy = dy * r0;

            this.emitEffects(SparkEffect, 4, {
                speed_min: 2,
                speed_max: 4,
                velmul: .75,
                addx: addx,
                addy: addy,
            });
        }

        super.handleCollision(other);
    }
}

class AssaultShip extends Ship {
    static name = 'Assault';
    radius = 12 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = .5;
    velmul = .95;
    rotspeed = Math.PI / 26;
    rotmul = .65;

    static maxhp = 100;

    shotClass = {
        x: TripleShot,
        y: BlasterShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-.9,    0),
            new Point(-.4, -.95),
            new Point( .9,    0),
            new Point(-.4,  .95),
        ]),
    ]);
}

class TorchShip extends Ship {
    static name = 'Torch';
    radius = 6 * RADIUSMUL;
    thrustSpeed = 1.45;
    reverseSpeed = 1;
    velmul = .95;
    rotspeed = Math.PI / 30;
    rotmul = .7;

    static maxhp = 80;

    shotClass = {
        x: DoubleFlameShot,
        y: MineShot,
    };

    thrustEffectClass = SmokeThrustEffect;
    thrustEffectVelMul = .2;
    thrustEffectEvery = 3;

    circleFillStyle = 'rgba(255,200,150,.35)';
    picture = new Picture([
        new Shape([
            new Point(-1.3,    0),
            new Point( 0  ,   -1),
            new Point( 1  ,    0),
            new Point( 0  ,    1),
        ]),
    ]);
}

class HunterShip extends Ship {
    static name = 'Hunter';
    radius = 10 * RADIUSMUL;
    thrustSpeed = 1;
    reverseSpeed = .5;
    velmul = .95;
    rotspeed = Math.PI / 26;
    rotmul = .65;

    static maxhp = 100;

    addhp = DEFAULT_ADDHP * 2;

    shotClass = {
        x: DoubleMiniBlasterShot,
        y: null,
    };

    picture = new Picture([
        new Shape([
            new Point(-.9, -.9 ),
            new Point( .8, -.45),
            new Point(-.9,  .9 ),
            new Point( .8,  .45),
        ], {radiusmul: 1.2}),
    ]);

    thrustEffects = 2;
    thrustEffectPosRot = Math.PI / 2;

    cloaked = false;

    constructor(field) {
        super(field);
        this.updateThrustEffects();
    }
    render(canvas, camera) {
        if(this.cloaked) return;
        super.render(canvas, camera);
    }
    updateThrustEffects() {
        if(this.cloaked) {
            this.thrustEffectClass = SmokeThrustEffect;
            this.thrustEffectVelMul = .2;
        } else {
            this.thrustEffectClass = ThrustEffect;
            this.thrustEffectVelMul = 1;
        }
    }
    fire(keyname) {
        if(this.cloaked) return;
        super.fire(keyname);
    }
    thrust(speed, rot, effect_opts) {
        if(this.cloaked) speed *= 2;
        super.thrust(speed, rot, effect_opts);
    }
    canWarp() {
        if(this.cloaked) return false;
        return super.canWarp();
    }
    step() {

        var keyname = 'y';
        var shotprops = this.shotprops[keyname];
        if(shotprops.cooldown === 0 && !this.is_warping) {
            var cloaked = this.keys[keyname].wasDown;
            if(cloaked != this.cloaked) {
                this.cloaked = cloaked;
                this.updateThrustEffects();
                this.emitEffects(SmokeEffect, 4, {
                    speed_min: 3,
                    speed_max: 6,
                    velmul: .65,
                });
                shotprops.cooldown += 5;
            }
        }

        super.step();

        if(this.cloaked) {
            this.damage(this.addhp + 1/20);
        }
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(this.hp < 15) {
                // Don't kill yourself by staying cloaked at low health
                key.up();
            } else if(key.isDown) {
                // Don't uncloak too soon
                if(Math.random() < .05) key.up();
            } else {
                // Don't cloak too often
                if(Math.random() < .05) key.down();
            }
        } else {
            super.stepCPUKey(key);
        }
    }
    _canCollide(other) {
        if(this.cloaked) return false;
        return super._canCollide(other);
    }
}

class BaseTurretShip extends Ship {
    flagship = null;

    remove() {
        if(this.flagship) this.flagship.removeTurret(this);
        super.remove();
    }
    canEmitGold() {
        return false;
    }
    getPlayer() {
        if(this.flagship) return this.flagship.getPlayer();
        return super.getPlayer();
    }
}

class HasTurretsShip extends Ship {
    max_turret_cooldown = 100;
    max_turrets = 1;
    turret_class = null; // should extend BaseTurretShip

    constructor(field) {
        super(field);

        this.turrets = [];
        this.turret_cooldown = this.max_turret_cooldown;
    }
    remove() {
        // We iterate over a copy of this.turrets, because when we kill
        // each turret, it removes itself from this.turrets, which would
        // mess up an iteration over this.turrets.
        var turrets = this.turrets.slice();
        for(var turret of turrets) turret.die();
        super.remove();
    }
    addTurret() {
        var turret = this.field.addShip(this.turret_class);
        turret.setTeam(this.team);
        turret.pos.copy(this.pos)
            .addSpeed(this.radius + turret.radius, this.rot);
        turret.vel.copy(this.vel);
        turret.flagship = this;

        this.turrets.push(turret);
        this.turret_cooldown = this.max_turret_cooldown;
        return turret;
    }
    removeTurret(turret) {
        var i = this.turrets.indexOf(turret);
        this.turrets.splice(i, 1);
        turret.flagship = null;
    }
    step() {
        super.step();
        if(this.turrets.length < this.max_turrets && !this.is_warping) {
            if(this.turret_cooldown) {
                this.turret_cooldown--;
            } else {
                this.addTurret();
            }
        }
    }
    beginWarp() {

        // Clone the array before iterating, since turret.die() calls
        // turret.remove() which removes the turret from this.turrets
        var turrets = this.turrets.slice();
        for(var turret of turrets) turret.die();

        super.beginWarp();
    }
    renderTurretLines(canvas, camera, addx, addy) {
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = 'rgba(0,200,200,.25)';
        ctx.lineWidth = 2;

        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        for(var turret of this.turrets) {
            var dx = moduloDiff(this.pos.x, turret.pos.x, fieldx);
            var dy = moduloDiff(this.pos.y, turret.pos.y, fieldy);
            var x1 = x0 + dx;
            var y1 = y0 + dy;

            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.closePath();
            ctx.stroke();
        }
    }
    renderPicture(canvas, camera, addx, addy) {
        this.renderTurretLines(canvas, camera, addx, addy);
        super.renderPicture(canvas, camera, addx, addy);
    }
}

class TurretShip extends BaseTurretShip {
    static name = 'Turret';
    radius = 6 * RADIUSMUL;
    thrustSpeed = .95;
    reverseSpeed = .55;
    velmul = .95;
    rotspeed = Math.PI / 40;
    rotmul = .7;

    static maxhp = 180;

    shotClass = {
        x: QuadrupleShot,
        y: QuadrupleMissileShot,
    };

    picture = new Picture([
        Shape.newPolygon(6),
        new Shape([
            new Point(0  , 0),
            new Point(1.2, 0),
        ], {fill: false, close: false}),
    ]);
}

class FlagTurretShip extends TurretShip {
    static maxhp = 60;
}

class FlagShip extends HasTurretsShip {
    static name = 'Flagship';
    radius = 10.5 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = 1.25;
    velmul = .9;
    rotspeed = Math.PI / 34;
    rotmul = .5;

    shotClass = {
        x: SingleShot,
        y: MissileShot,
    };

    static maxhp = 175;

    max_turret_cooldown = 100;
    max_turrets = 2;
    turret_class = FlagTurretShip;

    picture = new Picture([
        new Shape([
            new Point(-.9, -.3),
            new Point(-.7, -.5),
            new Point( .9, -.5),
            new Point( .9,  .5),
            new Point(-.7,  .5),
            new Point(-.9,  .3),
        ]),
    ], {radiusmul: 1.2});

    step() {
        super.step();
        for(var turret of this.turrets) {
            for(var keyname of 'xy') {
                var key = this.keys[keyname];
                turret.keys[keyname].copy(key);
            }
            for(var keyname of 'lrud') {
                turret.keys[keyname].up();
            }

            var tdist = 60 * RADIUSMUL;
            this.spring(turret, tdist,
                {mul: .02, push: false, r0: 1});

            var targetAngle = this.rot;
            turret.rot_vel += rotDiff(turret.rot, targetAngle) * .2;
        }
    }
}

class MoleShip extends Ship {
    static name = 'Mole';
    radius = 6 * RADIUSMUL;
    thrustSpeed = 2.05;
    reverseSpeed = 1.15;
    velmul = .95;
    rotspeed = Math.PI / 30;
    rotmul = .6;

    static maxhp = 60;

    shotClass = {
        x: ShortDoubleShot,
        y: null,
    };

    picture = new Picture([
        new Shape([
            new Point(-.7, -.3),
            new Point(-.4, -.9),
            new Point( .9, -.5),
            new Point(-.1,   0),
            new Point( .9,  .5),
            new Point(-.4,  .9),
            new Point(-.7,  .3),
        ]),
    ]);

    rock = null;

    remove() {
        if(this.rock) this.exitRock();
        super.remove();
    }
    step() {
        var rock = this.rock;
        if(rock) {
            var fieldx = this.field.size.x;
            var fieldy = this.field.size.y;

            var dx = moduloDiff(this.pos.x, rock.pos.x, fieldx);
            var dy = moduloDiff(this.pos.y, rock.pos.y, fieldy);

            this.addpos.x += dx * .2;
            this.addpos.y += dy * .2;
            this.vel.x += dx * .1;
            this.vel.y += dy * .1;

            rock.rot_vel *= .95;
            rock.vel.mul(this.velmul);

            rock.heal(1 / 20);
        }
        super.step();
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(this.rock) {
                // Usually don't exit your rock
                if(Math.random() < .001) key.down();
                else key.up();
            } else {
                // Try to enter rocks
                if(Math.random() < .5) key.down();
                else key.up();
            }
        } else {
            super.stepCPUKey(key);
        }
    }
    fire(keyname) {
        if(keyname === 'y') {
            var shotprops = this.shotprops[keyname];
            if(this.rock) {

                // NOTE: we add to this.pos, not this.addpos, otherwise
                // this ship will collide with its rock and get a ton of
                // velocity added to it this frame
                this.pos.addSpeed(this.rock.radius * .5, this.rot);

                this.exitRock();
                shotprops.cooldown += 10;
            } else {
                var foundRock = null;
                for(var rock of this.field.rocks) {
                    if(!this.colliding(rock)) continue;
                    if(rock.mole) continue;
                    foundRock = rock;
                    break;
                }
                if(foundRock) {
                    this.enterRock(foundRock);
                    shotprops.cooldown += 30;
                }
            }
        } else {
            super.fire(keyname);
        }
    }
    afterShot(shot) {
        super.afterShot(shot);

        var rock = this.rock;
        if(rock) {
            shot.addpos.addSpeed(rock.radius - this.radius, this.rot);
        }
    }
    thrust(speed, rot, effect_opts) {
        var rock = this.rock;
        if(rock) {
            var mul = DEFAULT_ROCK_RADIUS / rock.radius;
            if(mul > 1) mul = 1;
            rock.vel.addSpeed(speed * mul, rot);
        }
        super.thrust(speed, rot, effect_opts);
    }
    turn(rot) {
        var rock = this.rock;
        if(rock) {
            var mul = DEFAULT_ROCK_RADIUS / rock.radius;
            if(mul > 1) mul = 1;
            rock.rot_vel += rot * mul * .3;
        }
        super.turn(rot);
    }
    enterRock(rock) {
        rock.mole = this;
        this.rock = rock;
        this.emitEffects(SparkEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
    }
    exitRock() {
        this.rock.mole = null;
        this.rock = null;
    }
    canWarp() {
        if(this.rock) return false;
        return super.canWarp();
    }
    _canCollide(other) {
        if(other === this.rock) return false;
        return super._canCollide();
    }
    _isAlly(other) {
        if(other === this.rock) return true;
        return super._isAlly(other);
    }
}

class SuitShip extends Ship {
    static name = 'Suit';
    radius = 6 * RADIUSMUL;
    thrustSpeed = .5;
    reverseSpeed = .5;
    velmul = .995;
    rotspeed = Math.PI / 50;
    rotmul = .85;

    static maxhp = 85;

    thrustEffectClass = null;

    rock = null;

    // rockPos: our target position on the surface of this.rock
    // (We store this point on ourself just so we don't have to allocate
    // a fresh Point every frame... I don't know if that would actually
    // affect Javascript's performance. O_o I'm sure it doesn't matter.
    // Ah well, some habits from C die hard.)
    rockPos = new Point();

    step() {
        if(this.rock && this.rock.removed) this.unsetRock();

        super.step();

        if(this.rock) this.followRock();
    }
    setRock(rock) {
        this.rock = rock;

        if(this.pos.eq(rock.pos)) {
            this.rot = Random.randRotation();
        } else {
            this.rot = rock.pos.angle(this.pos, this.field.size);
        }

        this.emitEffects(SmokeEffect, 2, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.followRock();
    }
    unsetRock() {
        this.rock = null;
        this.emitEffects(SmokeEffect, 2, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
    }
    followRock() {
        var rock = this.rock;

        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;

        this.rockPos.copy(rock.pos)
            .addSpeed(rock.radius + this.radius / 2, this.rot);
        var dx = moduloDiff(this.pos.x, this.rockPos.x, fieldx);
        var dy = moduloDiff(this.pos.y, this.rockPos.y, fieldy);

        this.addpos.x += dx * .5;
        this.addpos.y += dy * .5;
        this.vel.x += dx * .2;
        this.vel.y += dy * .2;
    }
    fire(keyname) {
        if(keyname === 'y') {
            var shotprops = this.shotprops[keyname];
            if(this.rock) {
                super.fire(keyname);
            } else {
                var foundRock = null;
                for(var rock of this.field.rocks) {
                    if(!this.colliding(rock)) continue;
                    foundRock = rock;
                    break;
                }
                if(foundRock) {
                    this.setRock(foundRock);
                    shotprops.cooldown += 30;
                }
            }
        } else {
            super.fire(keyname);
        }
    }
    _handleKeys() {
        if(this.rock) {
            // Override Ship._handleKeys entirely

            if(this.keys.u.wasDown && this.shotprops['y'].cooldown === 0) {
                // Jump off this.rock
                this.vel.addSpeed(this.thrustSpeed * 5, this.rot);
                this.unsetRock();
                this.shotprops['y'].cooldown += 30;
                return;
            }

            // Turn slower when standing on bigger rocks
            // (because this.rot affects our position directly, and we want
            // to make sure we don't "move faster" when standing on bigger
            // rocks)
            var rotspeed = this.rotspeed * 1.5
                * (DEFAULT_ROCK_RADIUS / this.rock.radius);

            if(this.keys.l.wasDown) {
                this.turn(rotspeed);
            }
            if(this.keys.r.wasDown) {
                this.turn(-rotspeed);
            }
        } else {
            super._handleKeys();
        }
    }
    canWarp() {
        if(this.rock) return false;
        return super.canWarp();
    }
    _canCollide(other) {
        if(other === this.rock) return false;
        return super._canCollide();
    }
    _isAlly(other) {
        if(other === this.rock) return true;
        return super._isAlly(other);
    }
}

class MinerShip extends SuitShip {
    static name = 'Miner';

    shotClass = {
        x: ToolShot,
        y: null,
    };

    dig_cooldown = 30;

    // How much of a rock's radius we dig away from it
    dig_radius = 1 * RADIUSMUL;

    // How much "damage" we do to a rock's maxhp by digging it
    dig_damage = 10;

    picture = new Picture([
        // body
        Shape.newPolygon(3, {rot: Math.PI}).addxy(-.3, 0).mul(.9),
        // head
        Shape.newPolygon(3, {rot: Math.PI}).addxy(1.2, 0).mul(.5),
        // left arm
        Shape.newPolygon(4).mul(.2).addxy( .1, -1),
        // right arm
        Shape.newPolygon(4).mul(.2).addxy( .1,  1),
        // left leg
        Shape.newPolygon(4, {rot: Math.PI / 4}).mulxy(.6, .3).addxy(-1, -.6),
        // right leg
        Shape.newPolygon(4, {rot: Math.PI / 4}).mulxy(.6, .3).addxy(-1,  .6),
    ]);

    fire(keyname) {
        if(keyname === 'y' && this.rock && this.canDig(this.rock)) {
            this.dig(this.rock);
            var shotprops = this.shotprops[keyname];
            shotprops.cooldown += this.dig_cooldown;
        } else {
            super.fire(keyname);
        }
    }
    canPickup(pickup) {

        // Slightly hacky:
        // MinerShip can't pick up gold when standing on a rock.
        // (So that it doesn't immediately pick up gold it generates
        // by digging)
        if(this.rock && pickup instanceof GoldPickup) return false;

        return super.canPickup(pickup);
    }
    canDig(rock) {
        return (
            rock.radius - this.dig_radius >= MIN_ROCK_RADIUS &&
            rock.maxhp - this.dig_damage > 0
        );
    }
    dig(rock) {
        this.emitPickup(GoldPickup);

        rock.emitEffects(SmokeEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });

        rock.radius -= this.dig_radius;
        rock.setMaxHp(rock.maxhp - this.dig_damage);
    }
}

class EngineerShip extends SuitShip {
    static name = 'Engineer';

    shotClass = {
        x: ToolShot,
        y: RopeShot,
    };

    picture = new Picture([
        // body
        Shape.newPolygon(4, {rot: Math.PI / 4}).addxy(-.3, 0).mul(.9),
        // head
        Shape.newPolygon(4, {rot: Math.PI / 4}).addxy(1.2, 0).mul(.5),

        new Shape([
            // left arm
            new Point( .1, - .8),
            new Point( .1, -1.2),
        ]),
        new Shape([
            // right arm
            new Point( .1,   .8),
            new Point( .1,  1.2),
        ]),
        new Shape([
            // left leg
            new Point(- .9, -.5),
            new Point(-1.2, -.8),
        ]),
        new Shape([
            // right leg
            new Point(- .9,  .5),
            new Point(-1.2,  .8),
        ]),
    ]);

    ropeEnd = null;

    afterShot(shot) {
        super.afterShot(shot);
        if(shot instanceof RopeShot) {
            if(this.ropeEnd) {
                this.ropeEnd.addOtherEnd(shot);
                this.ropeEnd = null;
            } else {
                this.ropeEnd = shot;
            }
        }
    }
    step() {
        super.step();
        if(this.ropeEnd && this.ropeEnd.removed) this.ropeEnd = null;
    }
}

class TroopShip extends SuitShip {
    static name = 'Troop';
    radius = 7 * RADIUSMUL;

    static maxhp = 95;

    shotClass = {
        x: DoubleFlameShot,
        y: DoubleMissileShot,
    };

    picture = new Picture([
        // body
        Shape.newPolygon(5).addxy(-.3, 0).mul(.9),
        // head
        Shape.newPolygon(4, {rot: Math.PI / 4}).addxy(1.2, 0).mul(.5),

        // left arm
        Shape.newPolygon(3).mul(.3).addxy(.1, -1),

        // right arm
        Shape.newPolygon(3).mul(.3).addxy(.1,  1),

        new Shape([
            // left leg
            new Point(- .9, -.5),
            new Point(-1.2, -.8),
        ]),
        new Shape([
            // right leg
            new Point(- .9,  .5),
            new Point(-1.2,  .8),
        ]),
    ]);
}

class CrabShip extends Ship {
    static name = 'Crab';
    radius = 14 * RADIUSMUL;
    thrustSpeed = 3.25;
    reverseSpeed = 2.5;
    velmul = .85;
    rotspeed = Math.PI / 30;
    rotmul = .65;

    addhp = DEFAULT_ADDHP * 4;

    static maxhp = 250;

    shotClass = {
        x: ChompShot,
        y: null,
    };

    constructor(field) {
        super(field);

        this.chomp_thrust = this.thrustSpeed * 10;
        this.chomp_cooldown = 32;

        // Set up this.picture with Shapes assigned to properties of
        // this so that we can easily animate them
        this.left_arm = new Shape([
            new Point(  0, -.4),
            new Point( .2, -.9),
            new Point(  1, -.4),
        ]);
        this.right_arm = this.left_arm.clone().flip();
        this.picture = new Picture([
            new Shape([
                // Body
                new Point(  0, -.7),
                new Point(-.8,   0),
                new Point(  0,  .7),
            ]),
            this.left_arm,
            this.right_arm,
        ]);
    }
    step() {
        super.step();
        this.animate();
    }
    animate() {
        var i = this.shotprops.x.cooldown / this.chomp_cooldown;

        // NOTE: arm_addx, arm_addy seem to have less effect than I expected.
        // Bug in Picture.render?..
        var arm_addx = 1 * i;
        var arm_addy = .5 * i;

        var arm_rot = -Math.PI / 2 * i;

        this.left_arm.pos.set(arm_addx, arm_addy);
        this.left_arm.rot = arm_rot;

        this.right_arm.pos.set(arm_addx, -arm_addy);
        this.right_arm.rot = -arm_rot;
    }
    turn(rot) {

        // This is kind of cool, but doesn't quite feel right.
        //var speed = rot * this.thrustSpeed * 4;
        //this.vel.addSpeed(speed, this.rot + Math.PI / 2);

        super.turn(rot);
    }
    fire(keyname) {
        if(keyname === 'y') {
            this.thrust(this.chomp_thrust, this.rot, {cls: null});
            this.addThrustEffects(2, this.rot + Math.PI, {
                cls: FlameSmokeEffect,
                n_effects: 3,
                velmul: 0,
                posrot: Math.PI / 2,
            });

            var shotprops = this.shotprops[keyname];
            shotprops.cooldown += this.chomp_cooldown;
        } else {
            super.fire(keyname);
        }
    }
}

function _initSwarmShip(leader) {
    // Poor man's multiple inheritance...
    // SwarmShip inherits from HasTurretsShip, SwarmTurretShip inherits
    // from BaseTurretShip, but both classes need to share some common
    // initialization, so here we are.

    // Are we the leader of our swarm?..
    leader = getDefault(leader, false);

    this.thrustSpeed = 2.2;
    this.reverseSpeed = 1.9;
    this.velmul = .9;

    this.rotspeed = Math.PI / 45;
    this.rotmul = .75;

    if(leader) {
        // Leader is slower going forwards, but faster going backwards.
        // That helps him stay behind his swarm...
        this.thrustSpeed *= .8;
        this.reverseSpeed *= 1.3;
    }

    this.shotClass = {
        x: leader? BoldShortSingleShot: ShortSingleShot,
        y: null,
    };

    this.picture = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point(- .1,   -.5),
            new Point( 1.2,    0),
            new Point(- .1,    .5),
        ]),
    ]);
}

class SwarmTurretShip extends BaseTurretShip {
    static name = 'Swarm';
    radius = 5 * RADIUSMUL;

    thrustSpeed = .7;
    reverseSpeed = .4;
    velmul = .975;
    rotspeed = Math.PI / 45;
    rotmul = .85;

    static maxhp = 35;

    initSwarmShip = _initSwarmShip;

    constructor(field) {
        super(field);
        this.initSwarmShip();
    }
}

class SwarmShip extends HasTurretsShip {
    static name = 'Swarm';
    radius = 6 * RADIUSMUL;

    static maxhp = 60;

    circleLineWidth = 3;

    max_turret_cooldown = 25;
    max_turrets = 5;
    turret_class = SwarmTurretShip;

    initSwarmShip = _initSwarmShip;

    constructor(field) {
        super(field);
        this.initSwarmShip(true);
    }
    step() {
        var tightFormation = this.keys.y.isDown;

        var tdist = (tightFormation? 25: 65) * RADIUSMUL;
        var springmul = (tightFormation? .03: .02);
        for(var turret of this.turrets) {
            this.spring(turret, tdist,
                {mul: springmul, push: false, r0: .85});
        }

        super.step();

        for(var turret of this.turrets) {
            var targetAngle = this.rot;
            var rot_vel_mul = tightFormation? .2: .1;
            turret.rot_vel += rotDiff(turret.rot, targetAngle)
                * rot_vel_mul;

            for(var keyname of 'y') {
                turret.keys[keyname].up();
            }

            if(tightFormation) {
                for(var keyname of 'xud') {
                    var key = this.keys[keyname];
                    turret.keys[keyname].copy(key);
                }
                for(var keyname of 'lr') {
                    turret.keys[keyname].up();
                }
            } else {
                for(var keyname of 'x') {
                    var key = this.keys[keyname];
                    turret.keys[keyname].copy(key);
                }
                for(var keyname of 'lrud') {
                    if(Math.random() < .1) turret.keys[keyname].down();
                    if(Math.random() < .1) turret.keys[keyname].up();
                }
            }
        }
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .01) key.up();
        } else {
            super.stepCPUKey(key);
        }
    }
}

class BoreShip extends Ship {
    static name = 'Bore';

    radius = 7 * RADIUSMUL;
    thrustSpeed = 1.2;
    reverseSpeed = .9;
    velmul = .98;
    rotspeed = Math.PI / 25;
    rotmul = .45;

    static maxhp = 100;

    shotClass = {
        x: SingleShot,
        y: BoreShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-1  , -.75),
            new Point( 1  , -.75),
            new Point( 1  ,  .75),
            new Point(-1  ,  .75),
        ], {stroke: false}),
        new Shape([
            new Point(-1  , -.75),
            new Point( 1  , -.75),
            new Point( 1  ,  .75),
            new Point(-1  ,  .75),
        ], {fill: false, close: false}),
    ]);
}

class Shot extends Entity {
    static name = 'Shot';

    static initialShots = 1;
    static serialShots = 1;
    // "rot variance": difference in radians between the rot of first
    // and last Shot instance produced by firing this Shot type
    static initialRotVariance = 0;
    static serialRotVariance = 0;
    static randomRotVariance = 0;
    static initialPosRotVariance = 0;
    static serialPosRotVariance = 0;
    static randomPosRotVariance = 0;

    static isReverseShot = false;

    static initialSpeed = 20;
    static initialVelMul = 1;
    static randomSpeedVariance = 0;

    // Making player's gamepad rumble when they shoot
    static vibrateDuration = 0;
    static vibrateWeakMagnitude = 0;
    static vibrateStrongMagnitude = 0;

    // How hard we move things we hit
    hitVelMul = .1;

    // How much we transfer our rotational velocity to things we hit
    hitRotMul = .1;

    // How much damage we do
    hitDamage = 10;

    // If < 1, the amount of damage we do goes down over time
    hitDamageAgeMul = 1;

    hitEffectClass = SparkEffect;

    static cooldown = 4;

    constructor(field) {
        super(field);

        // The Ship who shot us out
        this.ship = null;
    }
    afterShotBy(entity) {
        // Bit of a hack, called by Entity.shoot, Entity.emitShots, etc.
        // Just lets subclasses of Shot customize themselves a bit based
        // on the entity which shot them.
    }
    step() {
        super.step();
        this.hitDamage *= this.hitDamageAgeMul;
    }
    hit(other) {
        other.vel.addMul(this.vel, this.hitVelMul);
        other.rot_vel += this.rot_vel * this.hitRotMul;
        other.damage(this.hitDamage);
        this.emitEffects(this.hitEffectClass, 2, {
            speed_min: 2,
            speed_max: 4,
            velmul: .75,
        });
        this.die();
    }
}

class SingleShot extends Shot {
    radius = 3 * RADIUSMUL;
    velmul = .95;
    static initialSpeed = 23;
    hitDamage = 10;
    hitDamageAgeMul = .95;
    shouldRenderTrail = true;
    static cooldown = 4;
    maxAge = 40;
    fadeWithAge = true;
}

class ShortSingleShot extends SingleShot {
    static initialSpeed = 17;
    static cooldown = 3;
}

class BoldShortSingleShot extends SingleShot {
    trailStrokeStyle = '#fa0';
    trailLineWidth = 3;
}

class RapidSingleShot extends SingleShot {
    radius = 4 * RADIUSMUL;
    static initialSpeed = 26;
    hitDamage = 6;
    hitDamageAgeMul = .98;
    static cooldown = 2;
    hitVelMul = .05;
    trailStrokeStyle = '#aaa';
    trailEnd = .3;
}

class RapidDoubleShot extends RapidSingleShot {
    static serialShots = 2;
    static serialPosRotVariance = Math.PI / 2;
}

class DoubleShot extends SingleShot {
    static serialShots = 2;
    static serialRotVariance = Math.PI / 18;
}

class ShortDoubleShot extends ShortSingleShot {
    static serialShots = 2;
    static serialRotVariance = Math.PI / 26;
    static serialPosRotVariance = Math.PI / 3;
}

class TripleShot extends SingleShot {
    static initialShots = 3;
    static serialShots = 1;
    static initialRotVariance = Math.PI / 13;
    static serialRotVariance = 0;
    static cooldown = 7;
}

class QuadrupleShot extends SingleShot {
    static serialShots = 4;
    static serialRotVariance = Math.PI / 20;
    static serialPosRotVariance = Math.PI;
    static cooldown = 2;
}

class MiniBlasterShot extends Shot {
    radius = 4 * RADIUSMUL;
    static initialSpeed = 18;
    static initialVelMul = 1;
    velmul = 1;

    hitVelMul = .05;
    hitDamage = 5;

    maxAge = 12;
    static cooldown = 8;

    static vibrateDuration = 200;
    static vibrateStrongMagnitude = .2;

    picture = Picture.newPolygon(6);

    die() {
        this.emitEffects(SmokeEffect, 1, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.emitShots(SingleShot, 2, {
            rot_variance: Math.PI / 4,
            speed_min: 10,
            speed_max: 10,
        });
        super.die();
    }
}

class DoubleMiniBlasterShot extends MiniBlasterShot {
    static serialShots = 2;
    static serialRotVariance = Math.PI / 26;
    static serialPosRotVariance = Math.PI / 3;
}

class BlasterShot extends Shot {
    radius = 10 * RADIUSMUL;
    static initialSpeed = 14;
    static initialVelMul = .7;
    velmul = 1;

    hitVelMul = .5;
    hitDamage = 15;

    maxAge = 20;
    static cooldown = 32;

    static vibrateDuration = 350;
    static vibrateWeakMagnitude = .2;
    static vibrateStrongMagnitude = .6;

    picture = Picture.newPolygon(6);

    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.emitShots(SingleShot, 5, {
            rot_variance: Math.PI / 4,
            speed_min: 10,
            speed_max: 10,
        });
        super.die();
    }
}

class MissileShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 10;
    static initialVelMul = .6;
    velmul = .9;

    thrustSpeed = 3;

    hitVelMul = .45;
    hitDamage = 10;

    maxAge = 30;
    fadeWithAge = false;
    static cooldown = 24;

    static vibrateDuration = 300;
    static vibrateWeakMagnitude = .2;
    static vibrateStrongMagnitude = .4;

    shouldRenderTrail = true;
    trailCamVel = 0;

    picture = new Picture([
        new Shape([
            new Point(-1.2, -.3),
            new Point( 1.2, -.3),
            new Point( 1.2,  .3),
            new Point(-1.2,  .3),
        ]),
    ]);

    step() {
        if(this.age < this.maxAge / 2) {
            this.vel.addSpeed(this.thrustSpeed, this.rot);
        } else {
            this.shouldRenderTrail = false;
        }
        super.step();
    }
    afterShotBy(entity) {
        super.afterShotBy(entity);
        this.rot_vel = rotDiff(this.rot, entity.rot) * 2;
    }
    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class DoubleMissileShot extends MissileShot {
    static initialShots = 2;
    static initialRotVariance = Math.PI / 9;
    static initialPosRotVariance = Math.PI / 3;
}

class QuadrupleMissileShot extends MissileShot {
    static serialShots = 4;
    static serialRotVariance = Math.PI / 4;
    static serialPosRotVariance = Math.PI;
    static cooldown = 8;
}

class FlameShot extends Shot {
    static randomRotVariance = Math.PI / 40;
    static randomPosRotVariance = Math.PI / 8;
    static randomSpeedVariance = 1.5;

    static initialSpeed = 10;
    static initialVelMul = .8;

    hitVelMul = 0;
    hitDamage = 3;
    hitDamageAgeMul = .975;
    hitEffectClass = FlameSmokeEffect;

    static cooldown = 1;

    radius = 3 * RADIUSMUL;
    velmul = .95;
    maxAge = 25;
    fadeWithAge = true;

    picture = new Picture([
        Shape.newPolygon(3, null, {stroke: false}),
        Shape.newPolygon(3, {rot: Math.PI * 2 / 6}, {stroke: false}),
    ]);
    circleFillStyle = 'rgba(255,180,0,.25)';

    constructor(field) {
        super(field);
        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    step() {
        super.step();
        this.radius += .2 * RADIUSMUL;
    }
}

class DoubleFlameShot extends FlameShot {
    static randomRotVariance = Math.PI / 20;
    static randomPosRotVariance = Math.PI / 4;

    static initialShots = 2;
    static initialRotVariance = Math.PI / 9;
}

class ReverseFlameShot extends FlameShot {
    static isReverseShot = true;

    hitDamage = 2;
    static cooldown = 2;
}

class RamFlameShot extends ReverseFlameShot {
    /* Ram's flames when it's ramming (when isRamming() is true) */
    radius = 5 * RADIUSMUL;
    circleFillStyle = 'rgba(255,200,0,.35)';
}

class MineShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 0;
    velmul = .9;

    hitDamage = 8;

    maxAge = 300;
    static cooldown = 32;

    picture = Picture.newPolygon(6);
    circleFillStyle = 'rgba(255,180,0,.4)';
    circleLineWidth = 3;

    die() {
        this.emitShots(FlameShot, 5, {
            rot_variance: Math.PI * 2,
            rand_rot_variance: Math.PI / 3,
            speed_min: 3,
            speed_max: 6,
        });

        super.die();
    }
}

class ChompShot extends Shot {
    radius = 10 * RADIUSMUL;
    static initialSpeed = 24;
    static initialVelMul = 1;
    velmul = .9;

    hitVelMul = .325;
    hitDamage = 10;

    maxAge = 5;
    static cooldown = 6;

    static vibrateDuration = 200;
    static vibrateWeakMagnitude = .35;

    circleStrokeStyle = 'rgba(255,150,0,.4)';
    inheritTeamColor = false;

    picture = new Picture([
        new Shape([
            new Point(-.4, -.85),
            new Point( .9,    0),
            new Point(-.4,  .85),
        ], {fill: false, close: false}),
    ]);

    hit(other) {
        var velmul = .35;
        var rot_velmul = .3;
        other.vel.mul(velmul);
        other.rot_vel *= rot_velmul;

        super.hit(other);
    }
}

class ToolShot extends Shot {
    radius = 4 * RADIUSMUL;
    static initialSpeed = 12;
    static initialVelMul = .8;
    velmul = .95;

    hitVelMul = .25;
    hitDamage = 10;

    maxAge = 25;
    static cooldown = 12;

    picture = new Picture([
        new Shape([
            Point.unit(0 / 4),
            Point.unit(2 / 4),
        ], {fill: false}),
        new Shape([
            Point.unit(1 / 4),
            Point.unit(3 / 4),
        ], {fill: false}),
    ]);
}

class RopeShot extends Shot {
    radius = 4 * RADIUSMUL;
    static initialSpeed = 32;
    static initialVelMul = .8;
    velmul = .99;

    hitVelMul = .45;
    hitDamage = 0;

    maxAge = 35;
    connectedMaxAge = 0;
    stuckMaxAge = 200;
    static cooldown = 23;

    picture = new Picture([
        new Shape([
            new Point(-1,  0),
            new Point( 1,  0),
        ], {fill: false}),
        new Shape([
            new Point( 0, -1),
            new Point( 0,  1),
        ], {fill: false}),
    ]);

    circleLineWidth = 3;
    circleStrokeStyle = 'rgba(100,255,255,.7)';
    inheritTeamColor = false;

    otherEnd = null;
    isFirstEnd = false;

    // ropeLen: set when two ends are connected (so, when otherEnd is set).
    // Only used by the end which isFirstEnd.
    ropeLen = 0;

    stickTarget = null;

    die() {
        // Do this first so that this.dead is true, preventing this.otherEnd
        // from trying to call this.die() again (and causing an infinite loop)
        super.die();

        // The two ends die together
        if(this.otherEnd && !this.otherEnd.dead) {
            this.otherEnd.die();
        }
    }
    hit(other) {

        // Don't try to stick to something if we're already sticking
        // to something
        if(this.stickTarget) return;

        // Don't try to stick to something this rope is already sticking to
        if(this.otherEnd && this.otherEnd.stickTarget === other) return;

        other.vel.addMul(this.vel, this.hitVelMul);
        other.damage(this.hitDamage);
        this.emitEffects(this.hitEffectClass, 2, {
            speed_min: 2,
            speed_max: 4,
            velmul: .75,
        });

        this.addStickTarget(other);
    }
    step() {
        if(this.stickTarget && this.stickTarget.removed) this.die();

        if(this.otherEnd && this.isFirstEnd) {
            var thisTarget = this.stickTarget? this.stickTarget: this;
            var otherTarget = this.otherEnd.stickTarget?
                this.otherEnd.stickTarget: this.otherEnd;
            thisTarget.spring(otherTarget, this.ropeLen, {mul: .05});
        }

        if(this.stickTarget) {
            this.pos.copy(this.stickTarget.pos);
            this.vel.copy(this.stickTarget.vel);
        }

        super.step();
    }
    addStickTarget(stickTarget) {
        this.stickTarget = stickTarget;
        this.addMaxAge(this.stuckMaxAge);
        if(this.otherEnd) {
            var firstEnd = this.isFirstEnd? this: this.otherEnd;
            firstEnd.ropeLen += stickTarget.radius;
        }
    }
    addMaxAge(n) {
        if(this.otherEnd && this.otherEnd.isFirstEnd) {
            // The "first end" is in control of aging for both ends.
            this.otherEnd.maxAge += n;
        } else {
            this.maxAge += n;
        }
    }
    addOtherEnd(other) {
        this.isFirstEnd = true;
        this.ropeLen = this.pos.dist(other.pos, this.field.size);

        this.otherEnd = other;
        other.otherEnd = this;

        // We take on other's maxAge, e.g. in case it has already been
        // stuck to something, which adds this.stuckMaxAge, and we don't
        // want to lose that when we set other.maxAge to -1 (see below).
        this.maxAge += other.maxAge;

        this.maxAge += this.connectedMaxAge;

        // this and other are now connected, and we'd like them both
        // to die at the exact same time.
        // So we set other.maxAge to -1, which means it will not die
        // from old age.
        // So "the first end" is "in charge" of both ends' ages, as it were.
        other.maxAge = -1;
    }
    renderRope(canvas, camera, addx, addy) {

        // Only one end needs to render the rope
        if(this.otherEnd && this.otherEnd.isFirstEnd) return;

        // maxFade: don't set fade lower than 1 - maxFade, that
        // would be too close to 0, so we wouldn't be able to see
        // the Entity
        var maxFade = .85;
        var fade = 1 - (this.age / this.maxAge) * maxFade;

        var strokeStyle = 'rgba(220,200,100,.75)';
        var lineWidth = 2;
        var otherEnd = this.ship;
        if(this.otherEnd) {
            lineWidth = 3;
            otherEnd = this.otherEnd;
        }

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;

        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;

        var dx = moduloDiff(this.pos.x, otherEnd.pos.x, fieldx);
        var dy = moduloDiff(this.pos.y, otherEnd.pos.y, fieldy);
        var x1 = x0 + dx;
        var y1 = y0 + dy;

        ctx.globalAlpha = fade;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.closePath();
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    renderPicture(canvas, camera, addx, addy) {
        this.renderRope(canvas, camera, addx, addy);
        super.renderPicture(canvas, camera, addx, addy);
    }
}

class BoreShot extends Shot {
    radius = 6 * RADIUSMUL;
    static initialSpeed = 14;
    static initialVelMul = .9;
    velmul = .95;

    hitVelMul = .5;
    hitDamage = 15;

    maxAge = 20;
    static cooldown = 50;

    static vibrateDuration = 350;
    static vibrateWeakMagnitude = .2;
    static vibrateStrongMagnitude = .6;

    picture = Picture.newPolygon(3);

    hit(other) {
        if(other instanceof Rock) {
            this.emitPickup(GoldPickup);
            other.dieFromDamage();
            this.die();
        } else {
            super.hit(other);
        }
    }
    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class Rock extends Entity {
    static name = 'Rock';

    circleStrokeStyle = '#987';
    velmul = 1;
    rotmul = 1;

    mole = null;

    constructor(field, radius) {
        super(field);

        radius = getDefault(radius, DEFAULT_ROCK_RADIUS);
        this.radius = radius;

        var default_hp = 30;
        this.hp = this.maxhp = parseInt(
            default_hp * radius / DEFAULT_ROCK_RADIUS);

        var n_points = Random.randIntInclusive(5, 10);
        this.picture = Picture.newPolygon(n_points,
            {rotVariance: .5, radiusVariance: .1});

        this.pos.setRandomWithin(field.size);

        var speed = Random.randNumber(3.5);
        this.vel.setSpeed(speed, Random.randRotation());

        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    damage(hp) {
        if(this.mole) hp /= 2;
        super.damage(hp);
    }
    remove() {
        if(this.mole) this.mole.exitRock();
        super.remove();
    }
    dieFromDamage() {
        if(this.radius >= MIN_ROCK_RADIUS) {
            var velmul = .75;
            var n_rocks = 2;
            var addposrot = Random.randRotation();
            for(var i = 0; i < n_rocks; i++) {
                var rock = this.field.addRock(
                    this.constructor, this.radius * .65);
                var posrot = (i / n_rocks) * Math.PI * 2 + addposrot;
                var posradius = this.radius;
                var radiusvelmul = .1;
                rock.pos.copy(this.pos)
                    .addSpeed(posradius, posrot);
                rock.vel.addMul(this.vel, velmul)
                    .addSpeed(posradius * radiusvelmul, posrot);
            }
        }
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });

        if(Math.random() < this.field.template.energy_chance) {
            this.emitPickup(EnergyPickup);
        }
        if(Math.random() < this.field.template.fuel_chance) {
            this.emitPickup(FuelPickup);
        }

        super.dieFromDamage();
    }
}

class Planet extends Entity {

    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgb(0,0,255)';

    velmul = 1;
    rotmul = 1;

    constructor(field) {
        super(field);

        this.radius = Random.randNumber(50,200);
        this.circleFillStyle = this.createFillGradient();

        this.pos.setRandomWithin(field.size);

        var speed = Random.randNumber(6,9) * VELMUL;
        this.vel.setSpeed(speed, Random.randRotation());

        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    createFillGradient() {
        var canvas = this.field.game.canvas;
        var ctx = canvas.getContext('2d');

        var innerPosSpeed = Random.randNumber(this.radius);
        var innerPos = new Point()
            .addSpeed(innerPosSpeed, Random.randRotation());

        var gradient = ctx.createRadialGradient(
            // x0, y0, r0
            innerPos.x, innerPos.y, 0,
            // x1, y1, r1
            0, 0, this.radius);

        var c0 = Random.randColor(50, 150);
        var c1 = Random.randColor(50, 100);
        var c2 = Random.randColor(100);

        gradient.addColorStop(.5, c0);
        gradient.addColorStop(.75, c1);
        gradient.addColorStop(1, c2);
        return gradient;
    }
}

class ShopItem {
    name = 'Item';
    price = 10;
    bought = false;

    cantBuy(player) {
        // To be overridden by subclasses
        // Returns false if player *CAN* buy this item, otherwise returns
        // a string (to be displayed to player) describing why they *CAN'T*.
        // Don't you dare question my design decisions.

        if(this.bought) {
            return 'Already bought!';
        }

        if(player.gold < this.price) {
            return 'Not enough gold!';
        }

        return null;
    }
    buy() {
        // To be overridden by subclasses
        // We assume this.cantBuy(player) has already been called successfully
        // (without throwing ShopItemBuyError)

        player.gold -= this.price;
        this.bought = true;
    }
}

class TrinketShopItem extends ShopItem {
    constructor(name, price, description) {
        super();
        this.name = name;
        this.price = price;
        this.description = description;
    }
    buy(player) {
        super.buy(player);

        var trinket = new Trinket(this.name, this.description);
        player.trinkets.push(trinket);
    }
}

class MaxEnergyShopItem extends ShopItem {
    constructor(energy) {
        super();
        this.energy = energy;
        this.name = '+' + String(energy) + ' Max Energy';
        this.price = 20 + energy * 2;
    }
    buy(player) {
        super.buy(player);
        player.addMaxHp(this.energy);
    }
}

class MaxFuelShopItem extends ShopItem {
    constructor(fuel) {
        super();
        this.fuel = fuel;
        this.name = '+' + String(fuel) + ' Max Fuel';
        this.price = 20 + fuel * 2;
    }
    buy(player) {
        super.buy(player);
        player.maxfuel += this.fuel;
    }
}

class ShipShopItem extends ShopItem {
    constructor(cls, price) {
        super();
        this.cls = cls;
        this.name = 'Ship: ' + cls.name;
        this.price = price;
    }
    cantBuy(player) {
        var value = super.cantBuy(player);
        if(value) return value;

        if(player.shipClasses.indexof(this.cls) >= 0) {
            return 'Already have ship: ' + this.cls.name;
        }
        return null;
    }
    buy(player) {
        super.buy(player);
        player.shipClasses.push(this.cls);
    }
}

class Shop {
    constructor(name, description, items) {
        this.name = name;
        this.description = description;

        // items: Array of ShopItem
        this.items = items;
    }
}


var SHIP_CLASSES = new OrderedDict()
    .set('fighter', FighterShip)
    .set('scout', ScoutShip)
    .set('assault', AssaultShip)
    .set('torch', TorchShip)
    .set('turret', TurretShip)
    .set('flag', FlagShip)
    .set('mole', MoleShip)
    .set('crab', CrabShip)
    .set('ram', RamShip)
    .set('hunter', HunterShip)
    .set('swarm', SwarmShip)
    .set('miner', MinerShip)
    .set('engineer', EngineerShip)
    .set('troop', TroopShip)
    .set('bore', BoreShip)
;


var canvas = document.getElementById('canvas');

var defaultMap = new function() {
    var map = new Map();

    function mkships(teamsMap) {
        var ships = new WeightedArray();
        for(var teamName in teamsMap) {
            var team = TEAMS.get(teamName);
            var shipsMap = teamsMap[teamName];
            for(var shipName in shipsMap) {
                var shipClass = SHIP_CLASSES.get(shipName);
                var weight = shipsMap[shipName];
                var shipTemplate = new ShipTemplate(shipClass, team);
                ships.addEntry(shipTemplate, weight);
            }
        }
        return ships;
    }

    function mktemplate(props) {
        props = props || {};
        props = Object.assign({}, props);

        if(props.width) props.width.mul(DEFAULT_FIELD_WIDTH);
        if(props.height) props.height.mul(DEFAULT_FIELD_HEIGHT);

        if(props.stars_per) props.stars_per.mul(DEFAULT_STARS_PER);
        if(props.rocks_per) props.rocks_per.mul(DEFAULT_ROCKS_PER);
        if(props.planets_per) props.planets_per.mul(DEFAULT_PLANETS_PER);
        if(props.ships_per) props.ships_per.mul(DEFAULT_SHIPS_PER);

        if(props.rock_radius) props.rock_radius.mul(DEFAULT_ROCK_RADIUS * RADIUSMUL);
        if(props.star_speed) props.star_speed.mul(DEFAULT_STAR_SPEED);

        return new FieldTemplate(props);
    }

    function mknodes(nodeMap) {
        var nodes = {};
        for(var nodeName in nodeMap) {
            var nodeProps = nodeMap[nodeName];
            var node = map.addNode(nodeProps.template, nodeProps.title);
            nodes[nodeName] = node;
        }
        for(var nodeName in nodeMap) {
            var node = nodes[nodeName];
            var nodeProps = nodeMap[nodeName];
            var edgeMap = nodeProps.edges;
            if(!edgeMap) continue;
            for(var node1Name in edgeMap) {
                var node1 = nodes[node1Name];
                var len = edgeMap[node1Name];
                node.addEdge(node1, len);
            }
        }
        return nodes;
    }

    function defnode(title, template, edges) {
        // "defnode" not "mknode" because we don't actually return
        // a MapNode.
        return {title: title, template: template, edges: edges};
    }

    /*
    fighter
    scout
    assault
    torch
    turret
    flag
    mole
    crab
    ram
    hunter
    swarm
    engineer
    troop

    Green team:
        Mostly fighter, scout, assault
        Often has low chance of flagship
    Yellow team:
        "utility" ships like mole, engineer?..
        Most common fighting ship is scout?..
    Blue team:
        They like asteroids. Miners?..
        Assault, hunter, swarm?..
    Red team:
        torch, ram, crab, troop?.. is the fire motif too obvious? :P

    Asteroid belt:
        Sweeps kind of northwest to southeast across the map
    */

    var nodes = mknodes({

        // INTRODUCTION
        // A series of fields, comprising the title screen and tutorial.
        intro0: defnode('Introduction',
            mktemplate({
                rocks_per: new MinMax(0),
                rocksText: 'SHIPteroids',
                energy_chance: 0,
                fuel_chance: 0,
                text: new Text('Welcome to space', [
                    'Try out your new ship.',
                    'Press W to warp to the next area.',
                    'Try not to hit things while warping.',
                ]),
            }), {intro1: 1}),
        intro1: defnode('Introduction',
            mktemplate({
                rocks_per: new MinMax(1),
                energy_chance: .5,
                fuel_chance: .5,
                text: new Text('Energy and fuel', [
                    'When your ship is damaged, it consumes energy.',
                    'When you warp, you consume fuel.',
                    'At the bottom of the screen, your energy',
                    'and fuel are shown as "E" and "F".',
                    'Shoot asteroids open to find more.',
                ]),
            }), {intro2: 1}),
        intro2: defnode('Introduction',
            mktemplate({
                rocks_per: new MinMax(2),
                ships_per: new MinMax(2),
                ships: mkships({
                    green: {fighter: 1},
                }),
                text: new Text('Friendly ships', [
                    '...are green, like you.',
                    'Don\'t worry, you can\'t damage each other.',
                ]),
            }), {intro3: 1}),
        intro3: defnode('Introduction',
            mktemplate({
                rocks_per: new MinMax(.4),
                gold_chance: 1,
                ships_per: new MinMax(.5),
                ships: mkships({
                    blue: {fighter: 1},
                }),
                text: new Text('Hostile ship!', [
                    'At the bottom of the screen, your gold',
                    'is shown as "G".',
                    'Destroy ships to find more.',
                    'You can always warp away instead of fighting.',
                ]),
            }), {intro4a: 1, intro4b: 1}),
        intro4a: defnode('Introduction',
            mktemplate({
                width: new MinMax(4),
                height: new MinMax(.3),
                rocks_per: new MinMax(3),
                planets_per: new MinMax(0),
                text: new Text('The map', [
                    'Did you notice how, when warping this time,',
                    'you were given a choice of branching paths?',
                    'This branch took you to a very wide area.',
                    'The other branch would have taken you to a',
                    'very tall area.',
                    '',
                    'Also... notice how space wraps around? Weird huh.',
                    'That\'s true in every area, it\'s just more obvious',
                    'in this one because it\'s so wide.',
                ]),
            }), {intro5: 1}),
        intro4b: defnode('Introduction',
            mktemplate({
                width: new MinMax(.3),
                height: new MinMax(4),
                rocks_per: new MinMax(3),
                planets_per: new MinMax(0),
                text: new Text('The map', [
                    'Did you notice how, when warping this time,',
                    'you were given a choice of branching paths?',
                    'This branch took you to a very tall area.',
                    'The other branch would have taken you to a',
                    'very wide area.',
                    '',
                    'Also... notice how space wraps around? Weird huh.',
                    'That\'s true in every area, it\'s just more obvious',
                    'in this one because it\'s so tall.',
                ]),
            }), {intro5: 1}),
        intro5: defnode('Introduction',
            mktemplate({
                rocks_per: new MinMax(3),
                energy_chance: 0,
                fuel_chance: .75,
                text: new Text('Long warps', [
                    'Some areas on the map are farther apart.',
                    'Travelling between them takes multiple warps.',
                    'It will take 2 warps to get to the next area,',
                    'so stock up on fuel here.',
                ]),
            }), {intro6: 2}),
        intro6: defnode('Shop',
            mktemplate({
                rocks_per: new MinMax(0),
                shop: new Shop('Introductory Shop',
                    [
                        'There are shops in space!',
                        'And the only currency they accept is, uh, gold pieces.',
                    ],
                    [
                        new TrinketShopItem('Useless Trinket', 5,
                            "It may not be very useful, but it's *yours*."),
                        Object.assign(new MaxEnergyShopItem(10), {
                            description:
                                "This would be really useful, " +
                                "if you could afford it."
                        }),
                    ]),
            }), {basic0: 1}),

        // BASIC TRAINING
        // A circular set of fields, introducing you to the most common
        // types of ship.
        basic0: defnode('Basic Training',
            mktemplate({
                ships_per: new MinMax(.5),
                ships: mkships({
                    blue: {fighter: 1},
                }),
            }), {basic1: 1}),
        basic1: defnode('Basic Training',
            mktemplate({
                ships_per: new MinMax(.5),
                ships: mkships({
                    blue: {fighter: 1},
                }),
            }), {basic2: 2}),
        basic2: defnode('Basic Training',
            mktemplate({ships: mkships({
                green: {fighter: .5, assault: 1, flag: .5},
                yellow: {fighter: 2, scout: 1, mole: .5},
            })}), {basic3: 2}),
        basic3: defnode('Basic Training',
            mktemplate({ships: mkships({
                green: {assault: 1, scout: 1},
                yellow: {fighter: 1, mole: 1},
                red: {torch: 1},
            })}), {basic0: 2, fire0: 4, corridor0: 2}),

        // FIRE
        // A place full of torches and rams. Presumably red team's home base.
        fire0: defnode('Fire',
            mktemplate({
                height: new MinMax(3),
                rocks_per: new MinMax(.5),
                rock_radius: new MinMax(.15, .75),
                ships_per: new MinMax(2),
                ships: mkships({red: {ram: 1, torch: .25}}),
            }), {fire1: 2}),
        fire1: defnode('Fire',
            mktemplate({
                height: new MinMax(3),
                rocks_per: new MinMax(10,30),
                rock_radius: new MinMax(.15, .75),
                ships_per: new MinMax(2),
                ships: mkships({red: {torch: 1}}),
            }), {basic2: 1}),

        // CORRIDOR
        // A series of wide fields, with not many rocks, stars, or planets.
        // Mostly blue team (assault+hunter), with some red (crab+hunter).
        // Maybe the first time you meet hunters?..
        corridor0: defnode('Corridor',
            mktemplate({
                width: new MinMax(1, 2),
                height: new MinMax(.5, 1),
                rocks_per: new MinMax(.7),
                rock_radius: new MinMax(1, 2),
                stars_per: new MinMax(.2),
                planets_per: new MinMax(.2),
                ships: mkships({
                    green: {fighter: 1},
                    blue: {assault: 1, hunter: .5},
                    red: {crab: 1},
                }),
            }), {corridor1: 4}),
        corridor1: defnode('Corridor',
            mktemplate({
                width: new MinMax(2, 3),
                height: new MinMax(1),
                rocks_per: new MinMax(.7),
                rock_radius: new MinMax(1, 3),
                ships_per: new MinMax(.8),
                stars_per: new MinMax(.2),
                planets_per: new MinMax(.2),
                ships: mkships({
                    blue: {assault: 1, hunter: .5},
                    red: {crab: 1, hunter: .5},
                }),
            }), {corridor2: 4}),
        corridor2: defnode('Corridor',
            mktemplate({
                width: new MinMax(2, 3),
                height: new MinMax(1, 2),
                rocks_per: new MinMax(.5),
                rock_radius: new MinMax(1, 3),
                ships_per: new MinMax(.8),
                stars_per: new MinMax(.2),
                planets_per: new MinMax(.2),
                ships: mkships({
                    blue: {assault: 1, hunter: .5, flag: .5},
                    red: {crab: 1, hunter: .5, ram: 1},
                }),
            }), {rock0: 3}),

        // ROCK
        // A big field, full of rocks, bit of every team, lots of moles & suits.
        rock0: defnode('Rock',
            mktemplate({
                width: new MinMax(2),
                rocks_per: new MinMax(10),
                rock_radius: new MinMax(.7, 3.2),
                ships_per: new MinMax(2),
                ships: mkships({
                    green: {mole: 1, troop: 1},
                    blue: {mole: 1, troop: 1},
                    yellow: {mole: 1, engineer: 1},
                    red: {crab: 1},
                }),
            }), {rock1: 2}),
        rock1: defnode('Rock',
            mktemplate({
                width: new MinMax(2),
                rocks_per: new MinMax(20),
                rock_radius: new MinMax(.5, 1.5),
                ships_per: new MinMax(2),
                ships: mkships({
                    green: {fighter: 1, mole: .5, engineer: .5, troop: .5},
                    blue: {assault: 1, mole: 1, troop: 1},
                    yellow: {scout: 1, mole: 1, engineer: 1},
                    red: {mole: .5, troop: 2},
                }),
            }), {basic1: 2}),
    });

    var startNodeName = getParam('start_node');
    map.startNode = startNodeName? nodes[startNodeName]: null;

    return {
        map: map,
        nodes: nodes,
    };
};
var game = new Game(canvas, new MapProgress(defaultMap.map));

var player = game.addPlayer();
game.mapKey(player.keys.u, KEY_U);
game.mapKey(player.keys.d, KEY_D);
game.mapKey(player.keys.l, KEY_L);
game.mapKey(player.keys.r, KEY_R);
game.mapKey(player.keys.x, KEY_SPACE);
game.mapKey(player.keys.y, KEY_SHIFT);

if(game.field.shop) game.setMenu(ShopMenu);
game.setMenu(ChooseShipMenu);

game.play();
canvas.style.border = 'none';
canvas.focus();


</script>
</body>
</html>