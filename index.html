<html>
<head>
<title>Shipteroids!</title>
<style>
body {
    color: #fff;
    background-color: #000;
}
.canvas {
    display: inline; /* So we can center it with text-align: center */
}
.controls {
    width: 22em;
    text-align: center;
}
.controls-table {
    margin: auto;
}
</style>
</head>
<body>
<table>
<tr>
<td>
<div id="controls" class="controls">
    <h2>&#x25BC; DEFAULT CONTROLS &#x25BC;</h2>
    <h3>Player 1</h3>
    <table class="controls-table">
        <tr><td><b>Left / right</b></td><td>Turn left / right</td></tr>
        <tr><td><b>Up / down</b></td><td>Thrust / reverse</td></tr>
        <tr><td><b>Spacebar</b></td><td>Fire weapon / use ability #1</td></tr>
        <tr><td><b>Shift</b></td><td>Fire weapon / use ability #2</td></tr>
        <tr><td><b>Backspace</b></td><td>Attempt to warp to next area</td></tr>
        <tr><td><b>Tab</b></td><td>Hold to view map</td></tr>
        <tr><td><b>Enter</b></td><td>Open the menu &amp; make selections</td></tr>
    </table>
    <h3>Player 2</h3>
    <table class="controls-table">
        <tr><td><b>A / D</b></td><td>Turn left / right</td></tr>
        <tr><td><b>W / S</b></td><td>Thrust / reverse</td></tr>
        <tr><td><b>V</b></td><td>Fire weapon / use ability #1</td></tr>
        <tr><td><b>B</b></td><td>Fire weapon / use ability #2</td></tr>
        <tr><td><b>Y</b></td><td>Attempt to warp to next area</td></tr>
        <tr><td><b>N</b></td><td>Hold to view map</td></tr>
        <tr><td><b>H</b></td><td>Open the menu &amp; make selections</td></tr>
    </table>
    <br>
    If the controls don't seem to work, you may need to click on the game area to focus it.
</div>
</td>
<td>
<div id="canvas-container" tabindex=-1>
Loading...
</div>
</td>
</tr>
</table>
</div>

<script>

'use strict';


/******************************
* IDEAS:
*
* Really big ship (MotherShip) with "gravity"
*
* "Ball and chain" ship (hold attack to send out chain on spring, release
* to have it come back to you)
* Each ball & chain is a separate projectile.
* So, hold 'x' to fire it out; it has a max length & springiness while you
* continue to hold 'x'; but once you release, the spring disappears and the
* ball carries on.
*
* "Snake" ship
*
* Slightly better AI: each CPUPlayer can have 1 target, which is rendered
* as a line. By default, when cpu player is hit, it targets the shot's ship.
* cpu should probably understand the range of its weapons.
* (E.g. crab had better try to get close, others should try to stay within
* a certain range but not too close, etc)
* Some ships override the default behaviour, e.g. Torch tries to lay mines
* within a small area and stay out of trouble.
* It should be possible for cpu to target rocks, but idunno when they would.
* (Moles and Suits should know to try and get into/onto a rock, so they
* target them but don't shoot when targeting a rock.)
*
* Story: you start off with your warp drive broken.
* You need to fix it by shooting open one of the asteroids, exiting your ship,
* flying over to the thing you shot out of the asteroid, collecting it,
* bringing it back to your ship, and fixing the warp drive. (Too much?..)
* Then, you warp.
* You meet somebody. You've come to Deep Space, which is like its own country.
* There are political factions (the different colours of "team").
* Your ship was originally uncoloured, but the person you meet is from the
* green faction. They describe the local gov't situation. You join green team.
* Some people live on asteroids, some on planets.
* Implement little people running around, little households & towns & cities.
* You do various jobs, meet various people, eventually change factions &
* have to come back through areas you had been through before, but this
* time you're on a different team so it's more difficult (areas which had
* been full of allies are now full of enemies).
*
*
* TODO:
*
* Fixing current "Choose Ship" menu, where you can always get a free ship
* at full health, what if we make it so whenever warping into an area,
* you can choose a ship to use?
* And each ship has persistent hp, and... maybe separate upgrades?..
* So if one of your ships "explodes", you actually still have it, but
* at 0 hp (so you can't warp in with it???) and have to go pay for it
* to be repaired. And then either pay to get it to full hp, or maybe
* after repair it has like 10 hp and you need to go farm rocks for hp.
*
* Improve "AI"
* avoidTarget is currently pretty lame, no shooting so easy to hunt
* them down; better (for most ships) to back away on an angle while shooting.
* Let's have multiple behaviours of various types, e.g. "default", "fearful",
* "aggro".
* Different ship classes use different ones (or perhaps use each with
* different probabilities).
* Some ships stay aggro when low hp, or even go "kamikaze". E.g. Assault is
* bad at running away.
* Others are super fearful, e.g. mole when not in a rock, maybe Torch?
*
* Saving/loading
*
* When a Field is populated, we should make sure things don't overlap,
* otherwise everything will start immediately rocketing around the screen.
*
* Better instructions, "story"...
* Collectables which affect the map. ("switches"? "keys"?)
* Warping is fiddly, so start game with it disabled.
* So first area, you first must prove that you've learned how to fly around,
* shoot, etc.
* So maybe something like, aside from the "SHIPteroids" rocks in first area,
* there is also some kind of switch thing. Which has no velocity, even if
* rocks hit it. So that you must fly to it, not just get lucky that it
* floats by.
* And you must fly to it and shoot it.
* And that... opens a portal?.. or just like... results in warping being
* unlocked? O_o
*
******************************/


// an empty Object (do not modify!!)
var EMPTY = {};


// query params
var PARAMS = new URLSearchParams(window.location.search);
function getParam(name, default_value) {
    var value = PARAMS.get(name);
    return value === null? default_value: value;
}
function getBoolParam(name, default_value) {
    default_value = getDefault(default_value, false);
    return Boolean(getParam(name, default_value));
}
function getIntParam(name, default_value) {
    default_value = getDefault(default_value, 0);
    return parseInt(getParam(name, default_value));
}
function getFloatParam(name, default_value) {
    default_value = getDefault(default_value, 0);
    return parseFloat(getParam(name, default_value));
}

// debug stuff
var CANVAS_WIDTH = getIntParam('scw', 700);
var CANVAS_HEIGHT = getIntParam('sch', 700);
var DEBUG = getBoolParam('debug');
var ALL_SHIPS = getBoolParam('all_ships');
var RICH = getBoolParam('rich');
var SHOT_LEVEL = getIntParam('shotlevel');
var X_SHOT_LEVEL = getIntParam('xshotlevel', SHOT_LEVEL);
var Y_SHOT_LEVEL = getIntParam('yshotlevel', SHOT_LEVEL);
var PICKUP_MAGNET = getIntParam('magnet');
var TIMING = getBoolParam('timing');
var RENDER_CIRCLES = getBoolParam('render_circles');
var RENDER_BOUNDARY = getBoolParam('render_boundary');
var HIDE_TEXT = getBoolParam('hide_text');
var NODAMAGE = getBoolParam('nodamage');
var VIBRATE = !getBoolParam('novibrate');
var N_PLAYERS = getIntParam('players', 1);
var MAX_PLAYERS = 2;

// physics tweaking stuff
var VELMUL = getFloatParam('velmul', .7); // multiplier for vel when being added to pos
var ADDVELMUL = getFloatParam('addvelmul', 0); // number between 0 and 1, increases velmul towards 1
var SHIP_ADDVELMUL = getFloatParam('ship_addvelmul', 0); // number between 0 and 1, increases ships' velmul towards 1
var MAXSPEED = getFloatParam('maxspeed', 80);
var ROTVELMUL = getFloatParam('rotvelmul', .5);
var RADIUSMUL = getFloatParam('radiusmul', 2);
var DAMAGEMUL = getFloatParam('damagemul', 1);
var DEFAULT_ROCK_RADIUS = 10 * RADIUSMUL;
var MIN_ROCK_RADIUS = 9 * RADIUSMUL;
var WARP_AFTER_STEPS = getIntParam('warp_after', 35);
var MAX_ROT_VEL = Math.PI / 5;
var DEFAULT_ADDHP = getFloatParam('addhp', 1 / 40);
var DEFAULT_ADDFUEL = getFloatParam('addfuel', 1 / 80);
var DEFAULT_MAXFUEL = 100;
var MAXGOLD = 999;
var WARP_COLLISION_DAMAGE = getFloatParam('warp_collision_damage', 10);
var WARP_FUEL = getFloatParam('warp_fuel', 10);
var MIN_MAP_NODE_RADIUS = 5;
var MAX_MAP_NODE_RADIUS = 20;
var MAX_SHOT_LEVEL = getIntParam('max_shot_level', 3);
var MAX_PICKUP_MAGNET = getIntParam('max_pickup_magnet', 2);

var SLOMO = getFloatParam('slomo', 0); // number between 0 and 1, slows down physics
VELMUL = linear(VELMUL, 0, SLOMO);
ADDVELMUL = linear(ADDVELMUL, 1, SLOMO);

if(DEBUG) {
    RICH = true;
    ALL_SHIPS = true;
    PICKUP_MAGNET = MAX_PICKUP_MAGNET;
    X_SHOT_LEVEL = MAX_SHOT_LEVEL;
    Y_SHOT_LEVEL = MAX_SHOT_LEVEL;
}

// Game/field default options
var DEFAULT_FIELD_WIDTH  = 1000;
var DEFAULT_FIELD_HEIGHT = 1000;
var DEFAULT_STARS_PER    = 1 /    5000;
var DEFAULT_ROCKS_PER    = 1 /  300000;
var DEFAULT_PLANETS_PER  = 1 / 1000000;
var DEFAULT_SHIPS_PER    = 1 /  500000;
var DEFAULT_STAR_SPEED = 3;
var DEFAULT_ENERGY_CHANCE = .08;
var DEFAULT_FUEL_CHANCE = .12;
var DEFAULT_GOLD_CHANCE = 1;

// keyCode values
var KEYS = {
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    h: 72,
    i: 73,
    k: 75,
    l: 76,
    n: 78,
    o: 79,
    s: 83,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,

    8: 56,
    9: 57,

    up: 38,
    down: 40,
    left: 37,
    right: 39,
    enter: 13,
    space: 32,
    shift: 16,
    backspace: 8,
    tab: 9,
};

// Player keymappings
var DEFAULT_PLAYER_KEYMAPPINGS = {
    0: {
        u:     KEYS.up,
        d:     KEYS.down,
        l:     KEYS.left,
        r:     KEYS.right,
        x:     KEYS.space,
        y:     KEYS.shift,
        warp:  KEYS.backspace,
        tab:   KEYS.tab,
        enter: KEYS.enter,
    },
    1: {
        u:     KEYS.w,
        d:     KEYS.s,
        l:     KEYS.a,
        r:     KEYS.d,
        x:     KEYS.v,
        y:     KEYS.b,
        warp:  KEYS.y,
        tab:   KEYS.n,
        enter: KEYS.h,
    },

    // These players have juuust enough keys set that they can
    // open the menu and set up their controls...
    2: {
        u:     KEYS.i,
        d:     KEYS.k,
        enter: KEYS[8],
    },
    3: {
        u:     KEYS.o,
        d:     KEYS.l,
        enter: KEYS[9],
    },
};

// Gamepad button indices for HTML5 Gamepad.buttons
// (Assumes the "standard mapping",
// see: https://w3c.github.io/gamepad/#remapping
// and in particular: https://w3c.github.io/gamepad/standard_gamepad.svg)
var GAMEPAD_BUTTONS = {
    12: 'u',
    13: 'd',
    14: 'l',
    15: 'r',
     0: 'u',
     2: 'd',
     5: 'x',
     7: 'x',
     4: 'y',
     6: 'y',
     8: 'tab',
     9: 'enter',
     3: 'warp',
};

// Axis threshold: value between 0 and 1, past which we
// consider an HTML5 Gamepad axis (e.g. joystick) to be
// "pressed".
// That is, each value in Gamepad.axes can be between -1 and 1,
// but we want to convert that into boolean key presses for "left",
// "right", "up", "down".
var GAMEPAD_AXIS_THRESHOLD = .5;


class OrderedDictEntry {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
class OrderedDict {
    entries = []; // Array of OrderedDictEntry

    size() {
        return this.entries.length;
    }
    set(key, value) {
        var entry = this.getEntry(key);
        if(entry) {
            entry.value = value;
        } else {
            var entry = new OrderedDictEntry(key, value);
            this.entries.push(entry);
        }
        return this;
    }
    indexOf(value) {
        for(var i = 0; i < this.entries.length; i++) {
            var entry = this.entries[i];
            if(entry.value === value) return i;
        }
        return -1;
    }
    getEntry(key) {
        for(var entry of this.entries) {
            if(entry.key === key) return entry;
        }
        return null;
    }
    get(key) {
        var entry = this.getEntry(key);
        if(entry) return entry.value;
        return null;
    }
    getAt(i) {
        var entry = this.entries[i];
        if(entry) return entry.value;
        return null;
    }
    getKeys() {
        return this.entries.map(entry => entry.key);
    }
    getValues() {
        return this.entries.map(entry => entry.value);
    }
}

// teams
class Team {
    constructor(name, color) {
        this.name = name;
        this.color = color;
    }
}
var TEAMS = new OrderedDict()
    .set('green', new Team('Green', '#0f0'))
    .set('red', new Team('Red', '#f33'))
    .set('blue', new Team('Blue', '#33f'))
    .set('yellow', new Team('Yellow', '#ff0'))
;


function linear(x0, x1, n) {
    /* Assumes: 0 <= n <= 1 */
    return x0 + (x1 - x0) * n;
}

function getDefault(value, default_value) {
    return value === undefined? default_value: value;
}

function removeArrayElem(arr, elem) {
    var i = arr.indexOf(elem);
    if(i >= 0) arr.splice(i, 1);
}

function range(a, b) {
    if(b === undefined) {
        b = a;
        a = 0;
    }
    var values = [];
    for(var i = a; i < b; i++) values.push(i);
    return values;
}

function modulo(x, n) {
    /* Returns the modulus of x / n.
    Expects n > 0.

    Example:

         x | n | modulo(x, n)
        ---+---+--------------
         -3| 3 | 0
         -2| 3 | 1
         -1| 3 | 2
          0| 3 | 0
          1| 3 | 1
          2| 3 | 2
          3| 3 | 0
    */
    return ((x % n) + n) % n;
}

function getRotVariance(i, n) {
    // rotVariance: number between -.5 and .5
    if(n <= 1) return 0;
    return i / (n - 1) - .5;
}

function moduloDiff(x0, x1, w) {
    /* Difference between two numbers on the "wrapped" interval between
    0 and w.
    (Distance from x0 to x1.) */
    x0 = modulo(x0, w);
    x1 = modulo(x1, w);
    var diff = x1 - x0;

    if(diff < -w/2)return diff + w;
    else if(diff > w/2)return diff - w;
    else return diff;
}

function rotDiff(r0, r1) {
    return moduloDiff(r0, r1, Math.PI * 2);
}

function renderCircle(ctx, x0, y0, rot, radius, opts) {
    opts = opts || EMPTY;
    var scale = getDefault(opts.scale, 1);
    var scalex = getDefault(opts.scalex, scale);
    var scaley = getDefault(opts.scaley, scale);
    ctx.save();
    {
        ctx.translate(x0, y0);
        ctx.scale(scalex, scaley);
        ctx.rotate(rot);
        ctx.beginPath();
        ctx.arc(0, 0, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fill();
    }
    ctx.restore();
}

class Text {
    /* Text which can be rendered onto a canvas. */

    constructor(title, lines) {
        this.title = title;
        this.lines = lines;
    }
    clone() {
        return new this.constructor(this.title, this.lines.slice());
    }
    render(canvas) {
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'left';

        var x = 16;
        var y = 20;

        ctx.font = 'normal bold 24px sans-serif';
        ctx.fillText(this.title, x, y);
        y += 26;

        ctx.font = 'normal 18px monospace';
        for(var line of this.lines) {
            ctx.fillText(line, x, y);
            y += 18;
        }
    }
}

class Random {
    /* Utility functions for producing random values */

    static randNumber(a, b) {
        if(b === undefined) {
            b = a;
            a = 0;
        }
        return a + Math.random() * (b - a);
    }
    static randInt(a, b) {
        return Math.floor(this.randNumber(a, b));
    }
    static randIntInclusive(a, b) {
        return this.randInt(a, b + 1);
    }
    static choice(choices) {
        return choices[this.randInt(choices.length)];
    }
    static randRotation() {
        return this.randNumber(Math.PI * 2);
    }
    static randColor(min, max, alpha) {
        if(max === undefined) {
            max = min;
            min = 0;
        }
        if(max === undefined) max = 256;

        var r = this.randInt(min, max);
        var g = this.randInt(min, max);
        var b = this.randInt(min, max);
        return alpha === undefined? Color.rgb(r, g, b):
            Color.rgba(r, g, b, alpha);
    }
}

class Color {
    /* Helper functions for creating CSS colours */
    static rgb(r, g, b) {
        return 'rgb(' + r + ',' + g + ',' + b + ')';
    }
    static rgba(r, g, b, a) {
        return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    }
}

class Point {
    /* A 2-dimensional point.
    Can also be used to represent the width+height of a rectangle,
    and/or represent the rectangle between (0,0) and (this.x,this.y). */

    constructor(x, y) {
        this.x = getDefault(x, 0);
        this.y = getDefault(y, 0);
    }
    clone() {
        return new Point(this.x, this.y);
    }
    set(x, y) {
        this.x = getDefault(x, 0);
        this.y = getDefault(y, 0);
        return this;
    }
    linear(other, m) {
        this.x = linear(this.x, other.x, m);
        this.y = linear(this.y, other.y, m);
        return this;
    }
    area() {
        return this.x * this.y;
    }
    dist(other, modulo) {
        var x0 = this.x;
        var y0 = this.y;
        var x1 = other? other.x: 0;
        var y1 = other? other.y: 0;

        var dx = Math.abs(x1 - x0);
        var dy = Math.abs(y1 - y0);
        if(modulo) {
            // If modulo is provided, it should be a Point representing
            // a rectangle representing a torus within which this and other
            // are contained.
            if(dx > modulo.x / 2) dx = modulo.x - dx;
            if(dy > modulo.y / 2) dy = modulo.y - dy;
        }
        return Math.sqrt(dx * dx + dy * dy);
    }
    angle(other, modulo) {
        var dx, dy;
        if(other) {
            if(modulo) {
                dx = moduloDiff(this.x, other.x, modulo.x);
                dy = moduloDiff(this.y, other.y, modulo.y);
            } else {
                dx = other.x - this.x;
                dy = other.y - this.y;
            }
        } else {
            dx = this.x;
            dy = this.y;
        }
        if(!dx && !dy) throw new Error("No angle between equal points");
        return Math.atan2(-dy, dx);
    }
    copy(other) {
        this.x = other.x;
        this.y = other.y;
        return this;
    }
    setMidpoint(other) {
        /* Sets this to the midpoint of the a rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = other.x / 2;
        this.y = other.y / 2;
        return this;
    }
    setRandomWithin(other) {
        /* Sets this to a random point within the rectangle formed between
        (0,0) and (other.x,other.y). */
        this.x = Random.randNumber(other.x);
        this.y = Random.randNumber(other.y);
        return this;
    }
    eq(other) {
        return this.x === other.x && this.y === other.y;
    }
    flip() {
        this.y = -this.y;
        return this;
    }
    addxy(x, y) {
        this.x += getDefault(x, 0);
        this.y += getDefault(y, 0);
        return this;
    }
    add(other) {
        this.x += other.x;
        this.y += other.y;
        return this;
    }
    addMul(other, mul) {
        this.x += other.x * mul;
        this.y += other.y * mul;
        return this;
    }
    mul(n) {
        this.x *= n;
        this.y *= n;
        return this;
    }
    mulxy(x, y) {
        this.x *= getDefault(x, 1);
        this.y *= getDefault(y, 1);
        return this;
    }
    modulo(other) {
        /* Returns this Point modulo the rectangle between (0,0) and
        (other.x, other.y).
        You can think of this as constraining this Point within the
        torus defined by the rectangle defined by other.
        If you're into that kind of thing. O_o */
        this.x = modulo(this.x, other.x);
        this.y = modulo(this.y, other.y);
        return this;
    }
    rotate(rot) {
        /*
            for(var i = 0; i < 4; i++) {
                var p = new Point(1).rotate(Math.PI * i / 2);
                console.log(p);
            }
            // {x:  1, y:  0}
            // {x:  0, y: -1}
            // {x: -1, y:  0}
            // {x:  0, y:  1}
        */
        var sin = Math.sin(rot);
        var cos = Math.cos(rot);
        var x =  this.x;
        var y = -this.y;
        this.x =  (x * cos - y * sin);
        this.y = -(x * sin + y * cos);
        return this;
    }
    static unit(rotmul) {
        return new this(1).rotate(Math.PI * 2 * rotmul);
    }
    static units(len, array) {
        /* Bit of a wacky function. Basically just used by
        rockWriter. */

        var points = [];
        for(var elem of array) {
            if(typeof elem === 'number') {
                points.push(this.unit(elem / len));
            } else if(elem instanceof Point) {
                points.push(elem.clone());
            } else {
                console.log('Invalid array element', elem);
                throw new Error('Invalid array element');
            }
        }
        return points;
    }
    static mirror(points) {
        var i0 = points.length - 1;
        for(var i = i0; i >= 0; i--) {
            var point = points[i];
            points.push(point.clone().flip());
        }
        return points;
    }
    setSpeed(speed, rot) {
        return this.set(speed).rotate(rot);
    }
    addSpeed(speed, rot) {
        var x = this.x;
        var y = this.y;
        this.setSpeed(speed, rot);
        this.x += x;
        this.y += y;
        return this;
    }
}

class Particle {
    /* Represents a thing with position and velocity. */

    radius = 1;

    modulo = null; // subclasses may override this

    constructor() {
        this.pos = new Point();
        this.vel = new Point();
    }
    stepPhysics() {
        this.pos.add(this.vel);
    }
    repel(other, opts) {
        opts = opts || EMPTY;
        var mul = getDefault(opts.mul, 1);

        var dx, dy;
        if(this.modulo) {
            dx = moduloDiff(this.pos.x, other.pos.x, this.modulo.x);
            dy = moduloDiff(this.pos.y, other.pos.y, this.modulo.y);
        } else {
            dx = other.pos.x - this.pos.x;
            dy = other.pos.y - this.pos.y;
        }

        var dist = this.pos.dist(other.pos, this.modulo);

        // Just say no to dividing by zero!
        if(!dist) {
            dist = .01;
            var p = new Point().addSpeed(dist, Random.randRotation());
            dx += p.x;
            dy += p.y;
        }

        var m = -mul / (dist * dist);
        this.vel.x += dx * m;
        this.vel.y += dy * m;
        other.vel.x -= dx * m;
        other.vel.y -= dy * m;
    }
    spring(other, tdist, opts) {
        // tdist: target distance (target spring length)

        opts = opts || EMPTY;
        var mul = getDefault(opts.mul, 1);
        var push = getDefault(opts.push, true);

        var dx, dy;
        if(this.modulo) {
            dx = moduloDiff(this.pos.x, other.pos.x, this.modulo.x);
            dy = moduloDiff(this.pos.y, other.pos.y, this.modulo.y);
        } else {
            dx = other.pos.x - this.pos.x;
            dy = other.pos.y - this.pos.y;
        }

        var dist = this.pos.dist(other.pos, this.modulo);

        // Early exit if we're already within target distance, and caller
        // said we shouldn't "push"
        if(!push && dist <= tdist) return;

        // Just say no to dividing by zero!
        if(!dist) {
            dist = .01;
            var p = new Point().addSpeed(dist, Random.randRotation());
            dx += p.x;
            dy += p.y;
        }

        // Vector which would move this to where dist between
        // this and other would be tdist
        var mx = dx / dist * (dist - tdist);
        var my = dy / dist * (dist - tdist);

        // r0, r1: relative "weights" of this and other.
        //    r0 is 0:   only other moves
        //    r0 is 1/2: this & other each move just as much
        //    r0 is 1:   only this moves
        var r0 = getDefault(opts.r0,
            this.radius / (this.radius + other.radius));
        var r1 = 1 - r0;

        this.vel.x += mx * r1 * mul;
        this.vel.y += my * r1 * mul;
        other.vel.x -= mx * r0 * mul;
        other.vel.y -= my * r0 * mul;
    }
}

class MinMax {
    /* Represents a range of numbers, min..max.
    Used for e.g. generating random values within a range. */

    constructor(min, max) {
        this.min = getDefault(min, 0);
        this.max = getDefault(max, this.min);
    }
    clone() {
        return new this.constructor(this.min, this.max);
    }
    getAverage() {
        return (this.min + this.max) / 2;
    }
    getRand() {
        return Random.randNumber(this.min, this.max);
    }
    add(n) {
        this.min += n;
        this.max += n;
        return this;
    }
    mul(n) {
        this.min *= n;
        this.max *= n;
        return this;
    }
    createInterpolated(other, m) {
        return new MinMax(
            linear(this.min, other.min, m),
            linear(this.max, other.max, m));
    }
}

class WeightedArrayEntry {
    /* An entry of a WeightedArray */

    constructor(value, weight) {
        this.value = value;
        this.weight = weight;
    }
}

class WeightedArray {
    /* An Array whose values each have a "weight", used when e.g.
    choosing a value at random. */

    constructor(defaultValue, entries) {
        defaultValue = getDefault(defaultValue, null);
        entries = getDefault(entries, []);

        if(!(entries instanceof Array)) {
            throw new Error('Entries not an instance of Array');
        }
        for(var entry of entries) {
            if(!(entry instanceof WeightedArrayEntry)) {
                console.log(defaultValue, entries, entry);
                throw new Error(
                    'Entry is not an instance of WeightedArrayEntry');
            }
        }

        this.defaultValue = defaultValue;

        // entries: Array of WeightedArrayEntry
        this.entries = entries;
    }
    static from(values, defaultValue) {
        var a = new this(defaultValue);
        for(var value of values) a.addEntry(value, 1);
        return a;
    }
    static fromEntries(entries, defaultValue) {
        var a = new this(defaultValue);
        for(var entry of entries) a.addEntry(entry.value, entry.weight);
        return a;
    }
    addEntry(value, weight) {
        weight = getDefault(weight, 1);
        var entry = new WeightedArrayEntry(value, weight);
        this.entries.push(entry);
        return this;
    }
    getTotalWeight() {
        var totalWeight = 0;
        for(var entry of this.entries) totalWeight += entry.weight;
        return totalWeight;
    }
    normalize(targetTotalWeight) {
        targetTotalWeight = getDefault(targetTotalWeight, 1);

        var totalWeight = this.getTotalWeight();
        for(var entry of this.entries) {
            entry.weight = entry.weight / totalWeight * targetTotalWeight;
        }
        return this;
    }
    clone() {
        return WeightedArray.fromEntries(this.entries, this.defaultValue);
    }
    getEntry(value) {
        for(var entry of this.entries) {
            if(entry.value === value) return entry;
        }
        return null;
    }
    mul(m) {
        for(var entry of this.entries) entry.weight *= m;
    }
    add(other, m) {
        // m: number between 0 and 1, used to weight this and other.
        // That is, if m === 0 then all weights are equal to this's weights.
        // If m === 1 then all weights are equal to other's weights.
        // If m === .5 then this and other are equally weighted.
        m = getDefault(m, .5);

        this.mul(1 - m);

        for(var otherEntry of other.entries) {
            var thisEntry = this.getEntry(otherEntry.value);
            if(thisEntry) {
                thisEntry.weight += otherEntry.weight * m;
            } else {
                this.addEntry(otherEntry.value, otherEntry.weight * m);
            }
        }
        return this;
    }
    addNormalized(other, m) {
        var otherTotalWeight = other.getTotalWeight();
        if(otherTotalWeight) {
            this.normalize(otherTotalWeight);
            return this.add(other, m);
        }
        return this;
    }
    randValue() {
        var totalWeight = this.getTotalWeight();
        var r = Random.randNumber(totalWeight);
        for(var entry of this.entries) {
            r -= entry.weight;
            if(r < 0) return entry.value;
        }

        // If e.g. this.entries was empty, or totalWeight is 0:
        return this.defaultValue;
    }
}

class ShipTemplate {
    /* Blueprint for creating a Ship */

    constructor(cls, team) {
        this.cls = cls;
        this.team = team;
    }
}
class FieldTemplate {
    /* Blueprint for creating a Field and populating it with entities (stars,
    rocks, ships, etc). */

    text = null;
    rocksText = null;
    shop = null;

    width = new MinMax(DEFAULT_FIELD_WIDTH);
    height = new MinMax(DEFAULT_FIELD_HEIGHT);

    stars_per = new MinMax(DEFAULT_STARS_PER);
    rocks_per = new MinMax(DEFAULT_ROCKS_PER);
    planets_per = new MinMax(DEFAULT_PLANETS_PER);
    ships_per = new MinMax(DEFAULT_SHIPS_PER);

    rock_radius = new MinMax(7, 32).mul(RADIUSMUL);
    star_speed = new MinMax(
        DEFAULT_STAR_SPEED - 1.6, DEFAULT_STAR_SPEED + 1.5);

    energy_chance = DEFAULT_ENERGY_CHANCE;
    fuel_chance = DEFAULT_FUEL_CHANCE;
    gold_chance = DEFAULT_GOLD_CHANCE;

    ships = new WeightedArray();

    constructor(props) {
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    getSize() {
        return new Point(this.width.getRand(), this.height.getRand());
    }
    clone(props) {
        props = props || {};
        for(var name in this) {
            if(name in props) continue;

            var thisProp = this[name];
            if(thisProp instanceof MinMax) {
                props[name] = thisProp.clone();
            } else if(thisProp instanceof Shop) {
                props[name] = thisProp;
            } else if(thisProp instanceof WeightedArray) {
                props[name] = thisProp.clone();
            } else if(thisProp instanceof Text) {
                props[name] = thisProp.clone();
            } else if(typeof thisProp !== 'object' || thisProp === null) {
                // number, string, null
                props[name] = thisProp;
            } else {
                console.log(this);
                console.log(thisProp);
                throw new Error('Dunno what to do with property: ' + name);
            }
        }
        return new this.constructor(props);
    }
    createInterpolated(other, m) {
        // We create & return a new FieldTemplate whose values are linear
        // interpolations of those in this and other.
        // m: number between 0 and 1 (inclusive).
        // If m is 0, new FieldTemplate's values are exactly this's values.
        // If m is 1, new FieldTemplate's values are exactly other's values.
        // If m is .5, new FieldTemplate's values are halfway between this's
        // and other's values.
        // ...etc.

        var props = {};
        for(var name in this) {
            var thisProp = this[name];
            var otherProp = other[name];
            if(thisProp instanceof MinMax) {
                props[name] = thisProp.createInterpolated(otherProp, m);
            } else if(thisProp instanceof WeightedArray) {
                props[name] = thisProp.clone().addNormalized(otherProp, m);
            } else if(typeof thisProp === 'number') {
                props[name] = linear(thisProp, otherProp, m);
            } else if(
                thisProp instanceof Text ||
                otherProp instanceof Text ||
                thisProp instanceof Shop ||
                otherProp instanceof Shop ||
                typeof thisProp === 'string' ||
                typeof otherProp === 'string'
            ) {
                if(m === 0) props[name] = thisProp;
                else if(m === 1) props[name] = otherProp;
                else if(thisProp === otherProp) props[name] = thisProp;
                else {
                    // Don't bother trying to "interpolate"
                }
            } else if(thisProp === null || otherProp === null) {
                props[name] = null;
            } else {
                console.log(this, other);
                console.log(thisProp, otherProp);
                throw new Error('Dunno what to do with property: ' + name);
            }
        }
        return new FieldTemplate(props);
    }
}

class MapNode extends Particle {
    /* A node of the graph represented by class Map. */

    constructor(map, template, title, description) {
        super();

        description = getDefault(description, []);

        this.map = map;
        this.template = template;
        this.title = title;

        // description: Array of string
        this.description = description;

        this.edges = [];
        this.backedges = [];

        this.field = null;

        // radius, pos, vel: don't affect anything, only used for rendering the
        // Map and its nodes/edges as a graph with "springy physics"
        // (also apparently known as a "force-directed graph")
        var speed = Random.randNumber(250);
        var rot = Random.randRotation();
        this.pos.addSpeed(speed, rot);
        this.radius = Random.randNumber(MIN_MAP_NODE_RADIUS, MAX_MAP_NODE_RADIUS);

        this.strokeStyle = Random.randColor(80, 256, .75);
        this.fillStyle = 'rgba(255,255,255,.25)';
    }
    unsetField() {
        this.field = null;
    }
    setField(field) {
        this.field = field;
    }
    getField() {
        return this.field;
    }
    addEdge(other, len) {
        var edge = new MapEdge(this, other, len);
        this.edges.push(edge);
        other.backedges.push(edge);
        return edge;
    }
    numEdges(includeBackedges) {
        includeBackedges = getDefault(includeBackedges, false);
        return includeBackedges?
            this.edges.length + this.backedges.length:
            this.edges.length;
    }
    getEdgeIndex(edge) {
        var i = this.edges.indexOf(edge.edge);
        if(i < 0) {
            i = this.backedges.indexOf(edge.edge);
            if(i < 0) {
                console.log(this, edge);
                throw new Error('Couldn\'t find edge');
            }
            i += this.edges.length;
        }
        return i;
    }
    getEdge(i) {
        return (i < this.edges.length)?
            this.edges[i].forwardEdge:
            this.backedges[i - this.edges.length].backEdge;
    }
    step() {
        this.pos.add(this.vel);
    }
}

class MapEdge {
    /* Connects one MapNode (this.node0) to another (this.node1).
    Has a length (this.len), an integer representing the number of
    warps you need to make in order to travel between this.node0 and
    this.node1. */

    constructor(node0, node1, len) {
        this.node0 = node0;
        this.node1 = node1;
        this.len = getDefault(len, 1);

        this.forwardEdge = new DirectedMapEdge(this, false);
        this.backEdge = new DirectedMapEdge(this, true);

        this.strokeStyle = Random.randColor(40, 200, .75);
    }
}

class DirectedMapEdge {
    /* Wraps a MapEdge, representing an arrow pointing along it in either
    direction (that is, either from node0 to node1, or vice versa). */

    constructor(edge, isBackEdge) {
        this.edge = edge;
        this.isBackEdge = isBackEdge;

        // Object mapping integers (0 < i < this.len) to Fields
        this.fields = {};
    }
    unsetField(i) {
        delete this.fields[i];
    }
    setField(i, field) {
        this.fields[i] = field;
    }
    getField(i) {
        return getDefault(this.fields[i], null);
    }
    getReversed() {
        return this.isBackEdge? this.edge.forwardEdge: this.edge.backEdge;
    }
    getLen() {
        return this.edge.len;
    }
    getNode0() {
        return this.isBackEdge? this.edge.node1: this.edge.node0;
    }
    getNode1() {
        return this.isBackEdge? this.edge.node0: this.edge.node1;
    }
}

class Map {
    /* A directed graph of MapNodes and MapEdges, each of which have an
    associated FieldTemplate. */

    // Array of MapNode
    nodes = [];

    // MapNode or null
    startNode = null;

    getStartNode() {
        if(this.startNode) return this.startNode;
        if(this.nodes.length) return this.nodes[0];
        return null;
    }
    addNode(template, title, description) {
        var node = new MapNode(this, template, title, description);
        this.nodes.push(node);
        return node;
    }
    step() {
        for(var i = 0; i < this.nodes.length; i++) {
            var node = this.nodes[i];

            var velmul = .95;
            node.vel.mul(velmul);

            // Nodes repel
            for(var j = i + 1; j < this.nodes.length; j++) {
                var other = this.nodes[j];
                node.repel(other, {mul: 5});
            }

            // Multiplier, converts edge.len into a length in pixels
            var lenmul = 50;

            // Edges act like springs
            for(var edge of node.edges) {
                var other = edge.node1;

                // Target distance (edge's length in pixels)
                var tdist = edge.len * lenmul;
                node.spring(other, tdist, {mul: .02});
            }
        }
        for(var node of this.nodes) node.step();
    }
}

class MapProgress {
    /* Represents players' "progress" across a Map.
    For instance, the MapNode at which they are currently located, and
    the MapEdge along which they are travelling (if applicable). */

    // edgeDist: how far we've travelled along this.edge.
    // It should always be the case that:
    //
    //   edgeDist >= 0 && edgeDist < edge.getLen()
    //
    edgeDist = 0;

    template = null;

    constructor(map, startNode) {
        if(!map.nodes.length) throw new Error('Map has no nodes');

        this.map = map;

        // MapNode
        this.node = getDefault(startNode, map.getStartNode());

        // DirectedMapEdge
        this.edge = null;

        this.updateTemplate();
    }
    getPos() {
        if(this.edge) {
            var pos0 = this.node.pos;
            var pos1 = this.edge.getNode1().pos;
            var m = this.edgeDist / this.edge.getLen();
            return pos0.clone().linear(pos1, m);
        } else {
            return this.node.pos;
        }
    }
    setEdge(edge) {
        if(this.edge) {
            throw new Error("Can't set edge yet, it's already set");
        }
        if(this.node !== edge.getNode0()) {
            console.log(this.node, edge);
            throw new Error("Edge does not start at current node");
        }
        this.edge = edge;
        this.edgeDist = 0;
        this.proceed();
        this.updateTemplate();
    }
    canProceed() {
        if(this.edge) return true;
        return this.node.numEdges() <= 1;
    }
    proceed() {
        if(!this.canProceed()) {
            throw new Error("Can't proceed yet, must set edge first");
        }

        if(this.edge) {
            if(this.edgeDist < this.edge.getLen() - 1) {
                this.edgeDist++;
            } else {
                this.node = this.edge.getNode1();
                this.edge = null;
            }
            this.updateTemplate();
        } else if(this.node.numEdges() === 1) {
            var edge = this.node.getEdge(0);
            this.setEdge(edge);
        } else {
            console.log(this.node);
            throw new Error(
                "Node doesn't have exactly 1 edge! "
                + "It has " + this.node.numEdges());
        }
    }
    unsetField(field) {
        if(this.edge) this.edge.unsetField(this.edgeDist);
        else this.node.unsetField();
    }
    setField(field) {
        if(this.edge) this.edge.setField(this.edgeDist, field);
        else this.node.setField(field);
    }
    getField() {
        if(this.edge) return this.edge.getField(this.edgeDist);
        else return this.node.getField();
    }
    updateTemplate() {
        if(!this.edge) {
            this.template = this.node.template;
            return;
        }

        var m = this.edgeDist / this.edge.getLen();
        var node0 = this.edge.getNode0();
        var node1 = this.edge.getNode1();
        this.template = node0.template
            .createInterpolated(node1.template, m);
    }
}

class Field {
    /* Think of "field" in the sense of "playing field".
    It's basically a rectangle within which sprites can fly around.
    The edges of the rectangle "wrap around" (or you can say it's a
    "torus" if you prefer). */

    constructor(game, size) {
        this.game = game;
        this.size = size;

        this.stars = [];

        this.entityArrays = [];
        this.planets = this.addEntityArray();
        this.ships = this.addEntityArray();
        this.shots = this.addEntityArray();
        this.effects = this.addEntityArray();
        this.rocks = this.addEntityArray();
        this.pickups = this.addEntityArray();

        this.template = null;
        this.shop = null;

        this.cpus = [];
        this.players = [];
        this.cameras = [];

        /* Create a canvas for rendering this Field.
        This canvas is never attached to a parent element, we only
        use it for drawing, then copy its image onto another canvas. */
        this.innerCanvas = document.createElement('canvas');
        this.innerCanvas.width = this.size.x;
        this.innerCanvas.height = this.size.y;
    }
    populate(template) {
        this.template = template;

        this.shop = template.shop;

        var area = this.size.area();
        var n_stars = area * template.stars_per.getRand();
        var n_rocks = area * template.rocks_per.getRand();
        var n_planets = area * template.planets_per.getRand();
        var n_ships = area * template.ships_per.getRand();

        /* Add some random stars */
        var star_vel_rot = Random.randRotation();
        var star_speed = template.star_speed.getRand();
        for(var i = 0; i < n_stars; i++) {
            var star = new Star(this);
            this.stars.push(star);

            star.pos.setRandomWithin(this.size);

            /* Each star has a random "distance", as in, how far away it
            is.
            Distance is a number between 0 and 1, with higher numbers
            meaning "further away".
            Stars which are "further away" are darker and move slower,
            to give a bit of parallax-ish effect. */
            var distance = Random.randNumber(0.25, 0.75);
            var color_component = Math.floor(255 * distance);
            star.trailStrokeStyle = 'rgb('
                + color_component + ','
                + color_component + ','
                + color_component + ')';
            star.vel.setSpeed(star_speed * distance, star_vel_rot);
            star.distance = distance;
        }

        /* Sort this.stars by "distance" so that when we iterate over
        it in render(), more distant stars are rendered first, and
        therefore "painted over" by closer stars. */
        this.stars.sort((s1, s2) => Math.sign(s2.distance - s1.distance));

        // Add rocks
        for(var i = 0; i < n_rocks; i++) {
            var radius = template.rock_radius.getRand();
            var rock = this.addRock(Rock, radius);
        }

        // Add planets
        for(var i = 0; i < n_planets; i++) {
            var planet = this.addPlanet(Planet);
        }

        // Add ships
        for(var i = 0; i < n_ships; i++) {
            var ship_template = template.ships.randValue();
            if(!ship_template) continue;

            var player = this.addCPUPlayer();
            player.setTeam(ship_template.team);
            player.createShip(ship_template.cls);
        }

        // Maybe add rocks which spell out some text
        if(template.rocksText) {
            this.addRocksText(template.rocksText);
        }
    }
    addPlayer(player) {
        this.players.push(player);
    }
    removePlayer(player) {
        removeArrayElem(this.players, player);
        this.removeCamera(player.camera);
    }
    addCPUPlayer() {
        var player = new CPUPlayer(this.game, this);
        this.cpus.push(player);
        return player;
    }
    addCamera() {
        var camera = new Camera(this);
        this.cameras.push(camera);
        return camera;
    }
    removeCamera(camera) {
        removeArrayElem(this.cameras, camera);
    }
    addEntityArray() {
        // Create an Array used to store Entity instances
        // (E.g. Game.ships, Game.rocks, etc)
        var entityArray = [];

        // Add a pending Array of things to be added to the Array at the
        // start of next Field.step
        entityArray.pending = [];

        this.entityArrays.push(entityArray);
        return entityArray;
    }
    cleanup() {
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.cleanup();
        }
    }
    addShip(cls) {
        var entity = new cls(this);
        this.ships.pending.push(entity);
        return entity;
    }
    addShot(cls) {
        var entity = new cls(this);
        this.shots.pending.push(entity);
        return entity;
    }
    addEffect(cls) {
        var entity = new cls(this);
        this.effects.pending.push(entity);
        return entity;
    }
    addRock(cls, radius) {
        radius = getDefault(radius, DEFAULT_ROCK_RADIUS);
        var entity = new cls(this, radius);
        this.rocks.pending.push(entity);
        return entity;
    }
    addPickup(cls) {
        var entity = new cls(this);
        this.pickups.pending.push(entity);
        return entity;
    }
    addPlanet(cls) {
        var entity = new cls(this);
        this.planets.pending.push(entity);
        return entity;
    }
    addPendingEntities(entityArray) {
        if(!entityArray.pending.length) return;
        for(var entity of entityArray.pending) entityArray.push(entity);
        entityArray.pending.length = 0;
    }
    addRocksText(text) {
        if(!text.length) return;

        var radiusmul = 1.2;

        var pictures = rockWriter.getPictures(text);
        var radius = DEFAULT_ROCK_RADIUS * radiusmul;
        var x0 = this.size.x / 2;
        var y0 = this.size.y / 2 - radius * 2.5;

        var padWidth = 0;
        var w = text.length * (radius * 2) + (text.length - 1) * padWidth;
        var x = x0 - w / 2;
        var y = y0;
        var dx = radius * 2 + padWidth;

        for(var picture of pictures) {

            // Kind of a hack: turn picture.radiusmul into a multiplier for
            // rock's radius, instead of for picture's radius.
            var thisRadius = radius * picture.radiusmul;
            picture.mul = 1;

            var rock = this.addRock(Rock, thisRadius);
            rock.pos.set(x, y);
            rock.vel.set();
            rock.picture = picture;
            rock.rot = 0;
            rock.rot_vel = 0;

            x += dx;
        }
    }
    step() {
        for(var entityArray of this.entityArrays) {
            this.addPendingEntities(entityArray);
        }

        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.step();
        }

        for(var shot of this.shots) {
            for(var ship of this.ships) {
                if(shot.ship && ship.isAlly(shot.ship)) continue;
                if(shot.colliding(ship)) shot.hit(ship);
                // Don't bother calling handleCollision() with Shots
                // (We might want to in future, though...)
            }
            for(var rock of this.rocks) {
                if(shot.ship && rock.isAlly(shot.ship)) continue;
                if(shot.colliding(rock)) shot.hit(rock);
                // Don't bother calling handleCollision() with Shots
                // (We might want to in future, though...)
            }
        }

        for(var i = 0; i < this.rocks.length; i++) {
            var rock = this.rocks[i];
            for(var j = i + 1; j < this.rocks.length; j++) {
                var other = this.rocks[j];
                if(rock.colliding(other)) {
                    rock.handleCollision(other);
                    other.handleCollision(rock);
                    rock.handleCollisionPhysics(other);
                }
            }
            for(var ship of this.ships) {
                if(rock.colliding(ship)) {
                    rock.handleCollision(ship);
                    ship.handleCollision(rock);
                    rock.handleCollisionPhysics(ship);
                }
            }
            for(var pickup of this.pickups) {
                if(rock.colliding(pickup)) {
                    rock.handleCollision(pickup);
                    pickup.handleCollision(rock);
                    rock.handleCollisionPhysics(pickup);
                }
            }
        }

        for(var i = 0; i < this.ships.length; i++) {
            var ship = this.ships[i];
            for(var j = i + 1; j < this.ships.length; j++) {
                var other = this.ships[j];
                if(ship.colliding(other)) {
                    ship.handleCollision(other);
                    other.handleCollision(ship);
                    ship.handleCollisionPhysics(other);
                }
            }
            for(var pickup of this.pickups) {
                if(ship.pickupMagnet && ship.canPickup(pickup)) {
                    var d = ship.dist(pickup) - ship.radius - pickup.radius;
                    if(d <= 50 * RADIUSMUL * ship.pickupMagnet) {
                        pickup.vel.addSpeed(.2 + .2 * ship.pickupMagnet,
                            pickup.angle(ship));
                    }
                }
                if(ship.colliding(pickup)) {
                    ship.handleCollision(pickup);
                    pickup.handleCollision(ship);
                }
            }
        }

        for(var i = 0; i < this.pickups.length; i++) {
            var pickup = this.pickups[i];
            for(var j = i + 1; j < this.pickups.length; j++) {
                var other = this.pickups[j];
                if(pickup.colliding(other)) {
                    pickup.handleCollisionPhysics(other);
                }
            }
        }

        for(var i = 0; i < this.planets.length; i++) {
            var planet = this.planets[i];
            for(var j = i + 1; j < this.planets.length; j++) {
                var other = this.planets[j];
                if(planet.colliding(other)) {
                    planet.handleCollisionPhysics(other);
                    // Don't bother calling handleCollision() with Planets
                }
            }
        }

        for(var entityArray of this.entityArrays) {
            this.removeEntities(entityArray);
        }

        for(var star of this.stars) star.stepPhysics();
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.stepPhysics();
        }
    }
    removeEntities(entityArray) {
        for(var i = 0; i < entityArray.length; i++) {
            var entity = entityArray[i];
            if(entity._shouldRemove) {
                entity.removed = true;
                entity.cleanup();
                entityArray.splice(i, 1);
                i--;
            }
        }
    }
    innerRender(camera) {
        var canvas = this.innerCanvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if(RENDER_BOUNDARY) this.renderBoundary(canvas);

        for(var star of this.stars) star.render(canvas, camera);
        for(var entityArray of this.entityArrays) {
            for(var entity of entityArray) entity.render(canvas, camera);
        }
    }
    renderBoundary(canvas) {
        /* Draw a box around the field */
        var ctx = canvas.getContext('2d');
        var w = this.size.x;
        var h = this.size.y;
        ctx.strokeStyle = '#800';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(w, 0);
        ctx.lineTo(w, h);
        ctx.lineTo(0, h);
        ctx.closePath();
        ctx.stroke();
    }
    render(canvas, camera) {
        this.innerRender(camera);
        var innerCanvas = this.innerCanvas;

        var ctx = canvas.getContext('2d');
        var x0 = canvas.width  / 2 - camera.pos.x;
        var y0 = canvas.height / 2 - camera.pos.y;

        x0 = modulo(x0, innerCanvas.width);
        if(x0 > 0) x0 -= innerCanvas.width;
        y0 = modulo(y0, innerCanvas.height);
        if(y0 > 0) y0 -= innerCanvas.height;

        for(var x = x0; x < canvas.width; x += innerCanvas.width) {
            for(var y = y0; y < canvas.height; y += innerCanvas.height) {
                ctx.drawImage(this.innerCanvas, x, y);
            }
        }
    }
}

class FieldParticle extends Particle {
    /* A particle which lives on a field. */

    radius = 10 * RADIUSMUL;

    constructor(field) {
        super();
        this.field = field;
        this.modulo = field.size;
    }
    dist(other) {
        return this.pos.dist(other.pos, this.field.size);
    }
    angle(other) {
        return this.pos.angle(other.pos, this.field.size);
    }
    stepPhysics() {
        // Make sure we don't go too gast
        var maxspeed = MAXSPEED;
        var speed = this.vel.dist();
        if(speed > maxspeed) this.vel.mul(maxspeed / speed);

        this.pos.addMul(this.vel, VELMUL).modulo(this.field.size);
    }
}

class Shape {
    /* Specifies a polygon to draw on a canvas.
    Each Picture can have multiple Shapes. */

    stroke = true;
    fill = true;
    close = true;

    pos = new Point();
    rot = 0;
    radiusmul = 1;

    points = null; // Array of Point

    constructor(points, props) {
        if(points) this.points = points;
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    static newRect(x0, y0, x1, y1) {
        return new this([
            new Point(x0, y0),
            new Point(x1, y0),
            new Point(x1, y1),
            new Point(x0, y1),
        ]);
    }
    static newPolygon(n_points, opts, props) {
        opts = opts || EMPTY;
        var rotVariance = getDefault(opts.rotVariance, 0);
        var radiusVariance = getDefault(opts.radiusVariance, 0);
        var rot = getDefault(opts.rot, 0);

        var points = [];
        for(var i = 0; i < n_points; i++) {
            var i_varied = i + Random.randNumber(-rotVariance, rotVariance);
            var point_rot = (Math.PI * 2) * i_varied / n_points + rot;
            var radius = 1 + Random.randNumber(-.5, .5) * radiusVariance;
            var point = new Point().addSpeed(radius, point_rot);
            points.push(point);
        }
        return new this(points, props);
    }
    clone() {
        var points = this.points.map(p => p.clone());
        var shape = new this.constructor(points);
        shape.pos.copy(this.pos);
        for(var key in this) {
            if(typeof this[key] !== 'object') {
                shape[key] = this[key];
            }
        }
        return shape;
    }
    flip() {
        for(var point of this.points) point.flip();
        return this;
    }
    add(other_point) {
        for(var point of this.points) point.add(other_point);
        return this;
    }
    addxy(x, y) {
        for(var point of this.points) point.addxy(x, y);
        return this;
    }
    mul(n) {
        for(var point of this.points) point.mul(n);
        return this;
    }
    mulxy(x, y) {
        for(var point of this.points) point.mulxy(x, y);
        return this;
    }
}

class Picture {
    radiusmul = 1;

    constructor(shapes, props) {
        this.shapes = shapes || [];
        if(props) for(var name in props) {
            if(name in this) this[name] = props[name];
        }
    }
    clone() {
        var shapes = this.shapes.map(shape => shape.clone());
        var picture = new this.constructor(shapes);
        for(var key in this) {
            if(typeof this[key] !== 'object') {
                picture[key] = this[key];
            }
        }
        return picture;
    }
    static newPolygon(n_points, opts, props) {
        var shape = Shape.newPolygon(n_points, opts);
        return new this([shape], props);
    }
    render(canvas, x0, y0, rot, radius_x, radius_y, opts) {
        opts = opts || EMPTY;
        var strokeStyle = getDefault(opts.strokeStyle, 'rgb(255,255,255)');
        var lineWidth = getDefault(opts.lineWidth, 1);
        var fillStyle = getDefault(opts.fillStyle, 'rgba(255,255,255,.25)');

        // Point used for calculations
        var p = new Point();

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;
        ctx.fillStyle = fillStyle;

        for(var shape of this.shapes) {
            var firstPoint = true;
            ctx.beginPath();
            for(var point of shape.points) {
                p.copy(point)
                    .rotate(shape.rot)
                    .add(shape.pos)
                    .rotate(rot)
                    .mulxy(radius_x, radius_y)
                    .mul(shape.radiusmul)
                    .addxy(x0, y0);
                if(firstPoint) {
                    ctx.moveTo(p.x, p.y);
                    firstPoint = false;
                } else {
                    ctx.lineTo(p.x, p.y);
                }
            }
            if(shape.close) ctx.closePath();
            if(shape.stroke) ctx.stroke();
            if(shape.fill) ctx.fill();
        }

    }
    renderEntity(entity, canvas, camera, addx, addy) {
        var x0 = entity.pos.x + addx;
        var y0 = entity.pos.y + addy;
        var rot = entity.rot;
        var radius = entity.radius * this.radiusmul;

        this.render(canvas, x0, y0, rot, radius, radius, {
            strokeStyle: entity.circleStrokeStyle,
            lineWidth: entity.circleLineWidth,
            fillStyle: entity.circleFillStyle,
        });
    }
}

class Writer {
    /* Utility class which converts strings of text into Arrays of
    Picture. */

    constructor(pictures_by_letter) {
        // pictures_by_letter: Object mapping letters (single-character
        // strings) to instances of Picture.
        this.pictures_by_letter = pictures_by_letter;
    }
    getPicture(letter) {
        var picture = this.pictures_by_letter[letter];
        if(!picture) {
            throw new Error(
                'No picture defined for letter: ' + letter);
        }
        return picture;
    }
    getPictures(text) {
        var pictures = [];
        for(var letter of text) {
            var picture = this.getPicture(letter);
            pictures.push(picture.clone());
        }
        return pictures;
    }
}

var rockWriter = new Writer({
    // I dare you to make sense of the following.
    // (Hint: we're basically chipping each letter out of a decahedron.
    // The points of the decahedron are represented by the numbers 0 through
    // 9, and we use the Point.unit and Point.units helper functions to turn
    // those numbers into points.)

    ' ': new Picture(),
    S: new Picture([new Shape(Point.units(10, [
        new Point(0, -.5), 1, 2, 3, 4,
        new Point(0,  .5), 6, 7, 8, 9,
    ])).mulxy(1, 1.3)]),
    H: new Picture([new Shape(Point.units(10, [
        0, 1, 2,
        Point.unit(2 / 10).addxy(0,  .5),
        Point.unit(3 / 10).addxy(0,  .5), 3, 4,

        5, 6, 7,
        Point.unit(7 / 10).addxy(0, -.5),
        Point.unit(8 / 10).addxy(0, -.5), 8, 9,
    ]))]),
    I: new Picture([new Shape(Point.units(10, [1, 2, 3,  6, 7, 8]), {radiusmul: .9})]),
    P: new Picture([new Shape(Point.units(10, [0, 1, 2, 3, 4,  7, 8,
        Point.unit(0 / 10).addxy(-.6, .2)]))]),
    t: new Picture([new Shape(Point.units(10, [
        Point.unit(1 / 10).addxy(-.2), 2, 3,
        Point.unit(4 / 10).addxy( .2), 4, 5,
        Point.unit(5 / 10).addxy( .5), 7, 8,
        Point.unit(0 / 10).addxy(-.5), 0, 1,
    ]), {radiusmul: 1})]),
    e: new Picture([new Shape(Point.units(10, [0, 1, 2, 3, 4, 5, 6, 7, 8,
        new Point(-.25)]), {radiusmul: .85})]),
    r: new Picture([new Shape(Point.units(10, [0, 1, 2, 3, 4,  6, 7,
        new Point(-.25), new Point(.2, -.2)]), {radiusmul: .85})]),
    o: new Picture([Shape.newPolygon(10, {}, {radiusmul: 1.1})]),
    i: new Picture([new Shape(Point.units(10, [
        Point.unit(6 / 10).addxy(0, -.75), 6, 7, 8, 9,
        Point.unit(9 / 10).addxy(0, -.75),
        new Point(0, -.25), 2, 3,
        new Point(0, -.25),
    ]), {radiusmul: .85}).mulxy(.9, 1.2)]),
    d: new Picture([new Shape(Point.units(10, [
        2, 3,
        Point.unit(3 / 10).addxy(0, .75), 5, 6, 7, 8,
    ]), {radiusmul: 1})]),
    s: new Picture([new Shape(Point.units(10, [
        new Point( .25, -.25), 1, 2, 3, 4,
        new Point(-.25,  .25), 6, 7, 8, 9,
    ])).mulxy(.9, .8)]),
});

class BlockyDigits {
    /* Maps digits (single-character strings, e.g. '0') onto Pictures */

    constructor() {
        /* THE "PARTS":

              BBBB
            AA    CC
            AA    CC
              DDDD
            EE    GG
            EE    GG
              FFFF
        */
        this.shapes_by_part = {
            A: Shape.newRect(-1 , -1 , -.5,  0 ),
            B: Shape.newRect(-.5, -1 ,  .5, -.7),
            C: Shape.newRect( .5, -1 ,  1 ,  0 ),

            D: Shape.newRect(-.5, -.2,  .5,  .2),

            E: Shape.newRect(-1 ,  0 , -.5,  1 ),
            F: Shape.newRect(-.5,  .7,  .5,  1 ),
            G: Shape.newRect( .5,  0 ,  1 ,  1 ),
        };
        this.pictures_by_digit = {
            0: this.makePicture('ABCEFG'),
            1: this.makePicture('CG'),
            2: this.makePicture('BCDEF'),
            3: this.makePicture('BCDGF'),
            4: this.makePicture('ACDG'),
            5: this.makePicture('BADGF'),
            6: this.makePicture('BADEFG'),
            7: this.makePicture('BCG'),
            8: this.makePicture('ABCDEFG'),
            9: this.makePicture('BACDG'),
            '[': this.makePicture('BAEF'),
            ']': this.makePicture('BCGF'),
        };
    }
    makePicture(parts) {
        var shapes = [];
        for(var part of parts) {
            var shape = this.shapes_by_part[part];
            if(!shape) throw new Error('Part not found: ' + part);
            shapes.push(shape);
        }
        return new Picture(shapes);
    }
    getPicture(digit) {
        var picture = this.pictures_by_digit[digit];
        if(!picture) {
            throw new Error(
                'No picture defined for digit: ' + digit);
        }
        return picture;
    }
}

var blockyDigits = new BlockyDigits();

var blockyWriter = new Writer({
    E: new Picture([new Shape([
        // Top
        new Point(-1 , -1 ),
        new Point( 1 , -1 ),
        new Point( 1 , -.7),
        new Point(-.5, -.7),

        // Middle
        new Point(-.5, -.2),
        new Point( .5, -.2),
        new Point( .5,  .2),
        new Point(-.5,  .2),

        // Bottom
        new Point(-.5,  .7),
        new Point( 1 ,  .7),
        new Point( 1 ,  1 ),
        new Point(-1 ,  1 ),
    ])]),
    F: new Picture([new Shape([
        // Top
        new Point(-1 , -1 ),
        new Point( 1 , -1 ),
        new Point( 1 , -.7),
        new Point(-.5, -.7),

        // Middle
        new Point(-.5, -.2),
        new Point( .5, -.2),
        new Point( .5,  .2),
        new Point(-.5,  .2),

        // Bottom
        new Point(-.5,  1 ),
        new Point(-1 ,  1 ),
    ])]),
    G: new Picture([new Shape([
        // Top
        new Point( 1 , -.7),
        new Point( .5, -1 ),
        new Point(-.5, -1 ),
        new Point(-1 , -.7),

        // Bottom
        new Point(-1 ,  .7),
        new Point(-.5,  1 ),
        new Point( .5,  1 ),
        new Point( 1 ,  .7),

        // Middle
        new Point( 1 , -.2),
        new Point( 0 , -.2),
        new Point( 0 ,  .2),
        new Point( .5,  .2),
        new Point( .5,  .7),
        new Point(-.5,  .7),
        new Point(-.5, -.7),
    ])]),

    ' ': new Picture(),
    ':': new Picture([
        Shape.newRect(-.25, -.7,  .25, -.2),
        Shape.newRect(-.25,  .2,  .25,  .7),
    ]),
    '/': new Picture([new Shape([
        new Point(-1 ,  1 ),
        new Point(-.8,  1 ),
        new Point( .8, -1 ),
        new Point( 1 , -1 ),
    ])]),

    0: blockyDigits.getPicture('0'),
    1: blockyDigits.getPicture('1'),
    2: blockyDigits.getPicture('2'),
    3: blockyDigits.getPicture('3'),
    4: blockyDigits.getPicture('4'),
    5: blockyDigits.getPicture('5'),
    6: blockyDigits.getPicture('6'),
    7: blockyDigits.getPicture('7'),
    8: blockyDigits.getPicture('8'),
    9: blockyDigits.getPicture('9'),
    '[': blockyDigits.getPicture('['),
    ']': blockyDigits.getPicture(']'),
});

var ENERGY_PICTURE = blockyWriter.getPicture('E');
var ENERGY_COLOR = 'rgb(80,200,200)';
var FUEL_PICTURE = blockyWriter.getPicture('F');
var FUEL_COLOR = 'rgb(180,65,0)';
var GOLD_PICTURE = blockyWriter.getPicture('G');
var GOLD_COLOR = 'rgb(255,165,50)';

class Sprite extends FieldParticle {
    /* Represents a Particle which can be drawn onto a <canvas>. */

    shouldRenderCircle = false;
    shouldRenderCircleLine = true;
    circleStrokeStyle = 'rgb(0,200,0)';
    circleFillStyle   = 'rgba(255,255,255,.15)';
    circleLineWidth = 2;

    shouldRenderTrail = false;
    trailStart = 0;
    trailEnd   = 1;
    trailCamVel = 1;
    trailStrokeStyle = 'rgba(255,150,0,25)';
    trailLineWidth = 2;

    picture = null; /* instanceof Picture */

    render(canvas, camera) {
        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var addx0 = this.pos.x < fieldx / 2? 0: -fieldx;
        var addy0 = this.pos.y < fieldy / 2? 0: -fieldy;

        for(var addx = addx0; addx <= addx0 + fieldx; addx += fieldx) {
            for(var addy = addy0; addy <= addy0 + fieldy; addy += fieldy) {
                this._render(canvas, camera, addx, addy);
            }
        }
    }
    _render(canvas, camera, addx, addy) {
        if(this.shouldRenderTrail) {
            this.renderTrail(canvas, camera, addx, addy);
        }
        if(this.shouldRenderCircle || RENDER_CIRCLES) {
            this.renderCircle(canvas, camera, addx, addy);
        }
        if(this.picture) {
            this.renderPicture(canvas, camera, addx, addy);
        }
    }
    renderPicture(canvas, camera, addx, addy) {
        this.picture.renderEntity(this, canvas, camera, addx, addy);
    }
    renderTrail(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var x1 = x0 - this.vel.x + camera.vel.x * this.trailCamVel;
        var y1 = y0 - this.vel.y + camera.vel.y * this.trailCamVel;
        var trail_x0 = linear(x0, x1, this.trailStart);
        var trail_y0 = linear(y0, y1, this.trailStart);
        var trail_x1 = linear(x0, x1, this.trailEnd);
        var trail_y1 = linear(y0, y1, this.trailEnd);

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.trailStrokeStyle;
        ctx.lineWidth = this.trailLineWidth;
        ctx.beginPath();
        ctx.moveTo(trail_x0, trail_y0);
        ctx.lineTo(trail_x1, trail_y1);
        ctx.stroke();
    }
    renderCircle(canvas, camera, addx, addy) {
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var ctx = canvas.getContext('2d');

        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.fillStyle = this.circleFillStyle;
        renderCircle(ctx, x0, y0, this.rot, this.radius);
    }
    renderLineTo(canvas, camera, addx, addy, other, strokeStyle, lineWidth, alpha) {
        strokeStyle = getDefault(strokeStyle, 'rgb(255,255,255)');
        lineWidth = getDefault(lineWidth, 1);
        alpha = getDefault(alpha, 1);

        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = lineWidth;

        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;

        var dx = moduloDiff(this.pos.x, other.pos.x, fieldx);
        var dy = moduloDiff(this.pos.y, other.pos.y, fieldy);
        var x1 = x0 + dx;
        var y1 = y0 + dy;

        ctx.globalAlpha = alpha;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.closePath();
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
}

class Star extends Sprite {
    radius = 3 * RADIUSMUL;
    shouldRenderTrail = true;
    trailLineWidth = 1;
    trailCamVel = 1;
}

class KeyInfo {
    constructor(name, title, description) {
        this.name = name;
        this.title = title;
        this.description = getDefault(description, null);
    }
}

var KEYINFOS = [
    new KeyInfo('u',     'Up'),
    new KeyInfo('d',     'Down'),
    new KeyInfo('l',     'Left'),
    new KeyInfo('r',     'Right'),
    new KeyInfo('x',     'Weapon/ability #1'),
    new KeyInfo('y',     'Weapon/ability #2'),
    new KeyInfo('warp',  'Warp'),
    new KeyInfo('tab',   'View map'),
    new KeyInfo('enter', 'Open menu / make selection'),
];
var KEYNAMES = KEYINFOS.map(keyinfo => keyinfo.name);

class Key {
    /* Represents the state of a key on the keyboard */

    constructor(name) {
        this.name = name;
        this.isDown = false;
        this.wasDown = false;
    }
    static createKeys() {
        var keys = {};
        for(var keyname of KEYNAMES) {
            keys[keyname] = new this(keyname);
        }
        return keys;
    }
    static copyKeys(fromKeys, toKeys) {
        for(var keyname of KEYNAMES) {
            toKeys[keyname].copy(fromKeys[keyname]);
        }
    }
    static cloneKeys(keys) {
        var newKeys = this.createKeys();
        Key.copyKeys(keys, newKeys);
        return newKeys;
    }
    copy(other) {
        this.isDown = other.isDown;
        this.wasDown = other.wasDown;
        return this;
    }
    union(other) {
        // The state of this becomes the "union" of this and other.
        // So think "boolean OR".
        if(other.isDown) this.isDown = true;
        if(other.wasDown) this.wasDown = true;
        return this;
    }
    down() {
        this.isDown = this.wasDown = true;
    }
    up() {
        this.isDown = false;
    }
    set(isDown) {
        if(isDown) this.down();
        else this.up();
    }
    step() {
        this.wasDown = this.isDown;
    }
}

class Shotprops {
    /* The "properties" of an Entity's shots for a given keyname,
    e.g. 'x' or 'y'. */

    cooldown = 0; // how long till another shot can be fired
    n_shots = 0; // how many shots have been fired
    level = 0; // as level increases, weapon is more powerful

    step() {
        if(this.cooldown > 0) this.cooldown--;
    }
}

class Entity extends Sprite {
    /* An Entity is a sprite with "volition" -- it has virtual keys which
    can be pressed, and based on their state, it can move itself. */

    static name = 'Entity';

    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .5;

    maxAge = -1;
    fadeWithAge = false;

    team = null;
    inheritTeamColor = true;

    shotClass = {
        x: null,
        y: null,
        extra1: null, // No key for this one
    };

    thrustEffectClass = ThrustEffect;
    thrustEffectSpeedMul = 2;
    thrustEffectVelMul = 1;
    thrustEffectEvery = 3;
    thrustEffects = 1;
    thrustEffectPosRot = 0;

    // Set to thrustEffectEvery each time a thrust Effect is created
    thrustEffectCooldown = 0;

    is_warping = false;
    warping_counter = 0;

    static maxhp = -1;

    addhp = DEFAULT_ADDHP;

    // How much of a rock's radius we dig away from it
    dig_radius = 2 * RADIUSMUL;

    // Chance of producing gold when we dig a rock
    dig_gold_chance = 1;

    // How much damage we do to a rock's hp and maxhp by digging it
    dig_maxhp_damage = 10;

    constructor(field) {
        super(field);

        this.hp = this.maxhp = this.constructor.maxhp;

        // addpos: entities can add to each others' addpos during step(),
        // and then addpos is added to pos during stepPhysics().
        // The purpose of this is to avoid modifying pos during step(),
        // because it's used in many calculations, so if it's modified
        // then the interactions between entities would be subtly different
        // depending on the order in which entities' step() is called...
        // Hope you get what I mean.
        this.addpos = new Point();

        this.rot = 0;
        this.rot_vel = 0;

        this.shotprops = {};
        for(var keyname in this.shotClass) {
            this.shotprops[keyname] = new Shotprops();
        };

        this.keys = Key.createKeys();

        this.age = 0;
        this.dead = false;
        this._shouldRemove = false;

        // removed: used by other entities with references to this one,
        // so they know they should stop referencing it
        this.removed = false;
    }
    getVelMul() {
        // May be overridden by subclasses
        return linear(this.velmul, 1, ADDVELMUL);
    }
    getShip() {
        // Return the ship to which we "belong", e.g. this if this
        // is a Ship, or the ship which shot this if this is a Shot,
        // or the mole which is commandeering this if this is a Rock.
        // (To be overridden by subclasses)
        return null;
    }
    getPlayer(includeCPUs) {
        includeCPUs = getDefault(includeCPUs, false);

        for(var player of this.field.players) {
            if(player.entity === this) return player;
        }
        if(includeCPUs) for(var player of this.field.cpus) {
            if(player.entity === this) return player;
        }
        return null;
    }
    setTeam(team) {
        this.team = team;
        if(team && this.inheritTeamColor) {
            this.lineStrokeStyle = team.color;
            this.circleStrokeStyle = team.color;
        }
    }
    isAlly(other) {
        if(this === other) return true;
        if(this.team && this.team === other.team) return true;
        return this._isAlly(other) || other._isAlly(this);
    }
    _isAlly(other) {
        // May be overridden by subclasses
        return false;
    }
    setMaxHp(maxhp) {
        this.maxhp = maxhp;
        if(this.hp > this.maxhp) this.hp = this.maxhp;
    }
    setHp(hp) {
        this.hp = hp > this.maxhp? this.maxhp: hp;
    }
    heal(addhp) {
        if((this.hp += addhp) > this.maxhp) this.hp = this.maxhp;
    }
    damage(hp, other) {
        // hp < 0: this thing is invincible
        if(this.hp < 0) return;

        // hp === 0: this thing is already dead
        // (This check is important so we don't call this.die() multiple
        // times on the same thing, which can e.g. result in a LOT of rocks
        // being generated when this is a Rock)
        if(this.hp === 0) return;

        // IF WE GOT THIS FAR, WE ARE ACTUALLY TAKING DAMAGE

        var m = Math.min(hp / 35, 1);
        this.vibrate(Math.max(1000 * m, 200), m, m/4);

        // Let our player know we took some damage
        var ship = this.getShip();
        var player = ship? ship.getPlayer(true): null;
        if(player && other) {
            var otherShip = other.getShip();
            if(otherShip) player.tookDamage(otherShip);
        }

        if(this instanceof Ship && NODAMAGE) return;

        this.hp -= hp * DAMAGEMUL;
        if(this.hp < 0) this.hp = 0;
        if(!this.hp) {
            this.dieFromDamage();
        }
    }
    dieFromDamage() {
        // Subclasses may want to override this
        this.vibrate(1500, .2, .5);
        this.die();
    }
    die() {
        this.dead = true;
        this.remove();
    }
    remove() {
        this._shouldRemove = true;
    }
    cleanup() {
    }
    step() {
        for(var keyname in this.shotClass) {
            var shotprops = this.shotprops[keyname];
            shotprops.step();
        }

        if(this.thrustEffectCooldown > 0) this.thrustEffectCooldown--;

        if(this.is_warping) {
            var speed = this.thrustSpeed * 2 / Math.pow(this.getVelMul(), 3);
            this.thrust(speed, this.rot, {cls: null});
            if(this.age % 3 === 0) {
                this.addThrustEffects(speed, this.rot + Math.PI, {
                    cls: WarpEffect,
                    n_effects: 1,
                    velmul: 0,
                    posrot: Math.PI / 2,
                });
            }

            this.warping_counter++;
            if(this.warping_counter > WARP_AFTER_STEPS) {
                this.finishWarp();
            }
        }

        this.handleKeys();
        for(var keyname of KEYNAMES) {
            this.keys[keyname].step();
        }

        this.heal(this.addhp);

        this.age++;
        if(this.maxAge >= 0 && this.age >= this.maxAge) {
            this.die();
        }
    }
    stepPhysics() {
        if(this.rot_vel < -MAX_ROT_VEL) this.rot_vel = -MAX_ROT_VEL;
        if(this.rot_vel > MAX_ROT_VEL) this.rot_vel = MAX_ROT_VEL;

        this.vel.mul(this.getVelMul());
        this.rot += this.rot_vel * ROTVELMUL;
        this.rot_vel *= this.rotmul;

        super.stepPhysics();

        // Add addpos to pos, then reset addpos
        this.pos.add(this.addpos);
        this.addpos.set();
    }
    handleKeys() {
        this._handleKeys();
        this.handleShotKeys();
    }
    _handleKeys() {
        // May be overridden entirely, see SuitShip
        if(this.keys.u.wasDown && !this.is_warping) {
            this.thrust(this.thrustSpeed, this.rot);
        }
        if(this.keys.d.wasDown && !this.is_warping) {
            this.thrust(this.reverseSpeed, this.rot + Math.PI);
        }
        if(this.keys.l.wasDown) {
            this.turn(this.rotspeed);
        }
        if(this.keys.r.wasDown) {
            this.turn(-this.rotspeed);
        }
        if(this.keys.warp.wasDown) {
            if(this.canWarp()) {
                var player = this.getPlayer();
                if(player && player.canWarp()) {
                    player.beginWarp();
                }
            }
        }
    }
    handleShotKeys() {
        for(var keyname in this.shotClass) {
            var shotprops = this.shotprops[keyname];
            if(!this.keys[keyname]) continue; // e.g. 'extra1'
            if(this.keys[keyname].wasDown && shotprops.cooldown === 0) {
                this.fire(keyname);
            }
        }
    }
    stepCPUKeys(keys) {
        // Do one step of a CPU player deciding which keys to press/release.
        // NOTE: This is for use when player is not targeting any particular
        // entity, i.e. ship is just kind of flying around aimlessly
        // NOTE: keys is player.keys (presumably this.getPlayer().keys)
        for(var keyname in keys) {
            var key = keys[keyname];
            this.stepCPUKey(key);
        }
    }
    stepCPUKey(key) {
        // Handle CPU player's decision of whether to press/release given key
        if(Math.random() < .1) key.down();
        if(Math.random() < .1) key.up();
    }
    avoidTarget(target, keys) {
        // Attempt to avoid target entity
        // NOTE: keys is player.keys (presumably this.getPlayer().keys)

        keys.u.down();
        keys.d.up();
        keys.l.up();
        keys.r.up();
        keys.x.up();
        keys.y.up();

        var angle = this.angle(target);
        var rot_diff = rotDiff(this.rot, angle) - Math.PI;
        if(rot_diff > 0) {
            // target is to our left
            // Attempt to keep rot_diff at -Math.PI / 2, that is,
            // keep target 90 degrees to our left
            if(rot_diff < Math.PI / 2) keys.r.down();
            else keys.l.down();
        } else {
            // target is to our right
            // Attempt to keep rot_diff at Math.PI / 2, that is,
            // keep target 90 degrees to our right
            if(rot_diff > -Math.PI / 2) keys.l.down();
            else keys.r.down();
        }
    }
    aimForTarget(target, keys) {
        // Attempt to chase & shoot down target entity
        // NOTE: keys is player.keys (presumably this.getPlayer().keys)

        keys.u.up();
        keys.d.up();
        keys.l.up();
        keys.r.up();

        for(var keyname of 'xy') {
            var shotClass = this.shotClass[keyname];

            // If this is a "standard" shot (as in, it goes forwards and
            // does damage), then shoot it.
            keys[keyname].set(shotClass && shotClass.isStandardShot);
        }

        var dist = this.dist(target);
        var tdist = this.idealTargetDist;
        if(dist < tdist) keys.d.down();
        if(dist > tdist) keys.u.down();

        var angle = this.angle(target);
        var rot_diff = rotDiff(this.rot, angle);
        if(rot_diff > 0) {
            // target is to our left
            keys.l.down();
        } else if(rot_diff < 0) {
            // target is to our right
            keys.r.down();
        }
    }
    turn(rot) {
        this.rot_vel += rot;
    }
    thrust(speed, rot, effect_opts) {
        this.vel.addSpeed(speed, rot);
        if(this.thrustEffectCooldown === 0) {
            this.addThrustEffects(speed, rot + Math.PI, effect_opts);
            this.thrustEffectCooldown += this.thrustEffectEvery;
        }
    }
    addThrustEffects(speed, rot, opts) {
        opts = opts || EMPTY;
        var cls = getDefault(opts.cls, this.thrustEffectClass);
        var n_effects = getDefault(opts.n_effects, this.thrustEffects);
        var velmul = getDefault(opts.velmul, this.thrustEffectVelMul);
        var speedmul = getDefault(opts.speedmul, this.thrustEffectSpeedMul);
        var posrot = getDefault(opts.posrot, this.thrustEffectPosRot);

        if(!cls) return;

        for(var i = 0; i < n_effects; i++) {
            var effect = this.field.addEffect(cls);

            var addrot = getRotVariance(i, n_effects) * posrot;
            effect.pos.copy(this.pos).addSpeed(this.radius, rot + addrot);

            effect.vel.copy(this.vel)
                .mul(velmul)
                .addSpeed(speed * speedmul, rot);

            effect.rot = rot;
        }
    }
    emitPickup(cls, opts) {
        opts = opts || EMPTY;
        var speed_min = getDefault(opts.speed_min, 2);
        var speed_max = getDefault(opts.speed_max, 5);
        var velmul = getDefault(opts.velmul, .75);

        var pickup = this.field.addPickup(cls);
        pickup.rot = this.rot;
        pickup.pos.copy(this.pos);
        var speed = Random.randNumber(speed_min, speed_max);
        pickup.vel.copy(this.vel).mul(velmul)
            .addSpeed(speed, Random.randRotation());

        return pickup;
    }
    emitEffects(cls, n_effects, opts) {
        opts = opts || EMPTY;
        var speed_min = getDefault(opts.speed_min, 0);
        var speed_max = getDefault(opts.speed_max, 0);
        var velmul = getDefault(opts.velmul, 0);
        var addx = getDefault(opts.addx, 0);
        var addy = getDefault(opts.addy, 0);

        for(var i = 0; i < n_effects; i++) {
            var effect = this.field.addEffect(cls);
            effect.rot = this.rot;
            effect.pos.copy(this.pos).addxy(addx, addy);
            var speed = Random.randNumber(speed_min, speed_max);
            effect.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, Random.randRotation());
        }
    }
    fire(keyname) {
        var shotprops = this.shotprops[keyname];
        var cls = this.shotClass[keyname];
        if(!cls) return;

        var serial_i = shotprops.n_shots % cls.serialShots;
        for(var i = 0; i < cls.initialShots; i++) {
            var shot = this.shoot(cls, i, serial_i, shotprops);
            this.afterShot(shot);
        }

        if(cls.vibrateDuration) {
            this.vibrate(cls.vibrateDuration,
                cls.vibrateWeakMagnitude,
                cls.vibrateStrongMagnitude);
        }

        shotprops.cooldown += cls.cooldown;
        shotprops.n_shots++;
    }
    afterShot(shot) {
        // Subclasses may add special behaviour...
        shot.afterShotBy(this);
    }
    _shoot(cls) {
        var shot = this.field.addShot(cls);
        shot.ship = this;
        shot.setTeam(this.team);
        shot.pos.copy(this.pos);
        shot.rot = this.rot;
        return shot;
    }
    shoot(cls, shot_i, serial_shot_i, shotprops) {
        // shot_i: index of this shot. E.g. if 3 are being fired at once,
        // this one might be 0, 1, or 2.

        var shot = this._shoot(cls);
        shot.applyPowerup(shotprops.level);

        shot.rot = this.rot
            + getRotVariance(shot_i, cls.initialShots)
                * shot.initialRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * shot.serialRotVariance
            + Random.randNumber(-.5, .5)
                * shot.randomRotVariance;

        var posrot = 0
            + getRotVariance(shot_i, cls.initialShots)
                * shot.initialPosRotVariance
            + getRotVariance(serial_shot_i, cls.serialShots)
                * shot.serialPosRotVariance
            + Random.randNumber(-.5, .5)
                * shot.randomPosRotVariance;

        var speed = shot.initialSpeed
            + Random.randNumber(-.5, 5)
                * shot.randomSpeedVariance;

        var addpos = this.radius;

        if(shot.isReverseShot) {
            addpos = -addpos;
            speed = -speed;
        }

        shot.pos.addSpeed(addpos, shot.rot + posrot);
        shot.vel.copy(this.vel)
            .mul(shot.initialVelMul)
            .addSpeed(speed, shot.rot);
        return shot;
    }
    canCollide(other) {
        if(this === other) return false;
        return this._canCollide(other) && other._canCollide(this);
    }
    _canCollide(other) {
        // Can be overridden by subclasses
        return true;
    }
    colliding(other) {
        if(!this.canCollide(other)) return;
        var d = this.pos.dist(other.pos, this.field.size);
        return d < this.radius + other.radius;
    }
    handleCollision(other) {
        /* We collided with another Entity! Now what?
        (Subclasses are free to answer that question in various ways...) */

        if(this.is_warping && !this.isAlly(other)) {
            this.damage(WARP_COLLISION_DAMAGE);

            // ???...
            // If we don't do this, we could take warp_damage every frame
            // we're touching other...
            other.die();

            other.emitEffects(SmokeEffect, 4, {
                speed_min: 3,
                speed_max: 6,
                velmul: .65,
            });
            other.emitEffects(SparkEffect, 4, {
                speed_min: 3,
                speed_max: 6,
                velmul: .65,
            });
        }
    }
    handleCollisionPhysics(other) {
        /* We collided with another Entity!
        We are both pushed away, and take on some of each others
        velocity.
        NOTE: unlike handleCollision, this method is only called once
        per step for any given pair of entities.
        Subclasses should not override this method. */

        /* r0: number between 0 and 1.
        The closer it is to 1, the larger this.radius is than other.radius.
        If .5, they are equal. */
        var r0 = this.radius / (this.radius + other.radius);
        var r1 = 1 - r0;

        /* Distance between this and other */
        var dist = this.pos.dist(other.pos, this.field.size);

        /* Vibrate players' controllers?? */
        var vib_m = 1 - Math.min(dist / (this.radius + other.radius), 1);
        this.vibrate(Math.max(1000 * vib_m, 200), vib_m * .5 * r1, 0);
        other.vibrate(Math.max(1000 * vib_m, 200), vib_m * .5 * r0, 0);

        /* Avoid div by zero, eh */
        if(dist < .1) {
            dist = .1;
            var p = new Point().addSpeed(dist, Random.randRotation());
            dx += p.x;
            dy += p.y;
        }

        /* Target distance: this and other are just barely touching */
        var tdist = this.radius + other.radius;

        /* dx, dy: shortest vector from this to other, on the torus
        represented by this.field.size */
        var dx = moduloDiff(this.pos.x, other.pos.x, this.field.size.x);
        var dy = moduloDiff(this.pos.y, other.pos.y, this.field.size.y);

        /* mx, my: vector which would move this away from other, to where
        they are just barely touching */
        var mx = dx / dist * (dist - tdist);
        var my = dy / dist * (dist - tdist);

        /* Update addpos */
        var posmul = .5;
        this.addpos.x  += mx * r1 * posmul;
        this.addpos.y  += my * r1 * posmul;
        other.addpos.x -= mx * r0 * posmul;
        other.addpos.y -= my * r0 * posmul;

        /* Update vel */
        var velmul = .7;
        this.vel.x  += mx * r1 * velmul;
        this.vel.y  += my * r1 * velmul;
        other.vel.x -= mx * r0 * velmul;
        other.vel.y -= my * r0 * velmul;

        if(
            /* We are both instances of Ship or Rock */
            (this instanceof Ship || this instanceof Rock) &&
            (other instanceof Ship || other instanceof Rock) &&

            /* We are not BOTH rocks
            (because then we'll just cause each other to spin more
            and more... because rocks always have rotmul = 1) */
            !(this instanceof Rock && other instanceof Rock)
        ) {
            /* Update rot_vel */
            var rot_velmul = .15;
            this.rot_vel  += other.rot_vel * r1 * rot_velmul;
            other.rot_vel += this.rot_vel  * r0 * rot_velmul;
        }
    }
    canDig(rock) {
        return (
            rock.radius - this.dig_radius >= MIN_ROCK_RADIUS &&
            rock.maxhp - this.dig_maxhp_damage > 0
        );
    }
    dig(rock) {
        // NOTE: we assume that this.canDig(rock) was just called, and
        // returned true

        if(Math.random() < this.dig_gold_chance) this.emitPickup(GoldPickup);

        rock.emitEffects(SmokeEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });

        rock.radius -= this.dig_radius;

        // Reduce rock's *maximum* hp, so we can't just dig and then
        // wait for rock's hp to regenerate...
        rock.setMaxHp(rock.maxhp - this.dig_maxhp_damage);

        // Damage rock with 0 damage, basically just so that if it has
        // a mole controlled by a CPU player, then CPU player will be
        // alerted that it "took damage" from us, so it will target us.
        rock.damage(0, this);
    }
    canWarp() {
        // May be overridden by subclasses
        return !this.is_warping;
    }
    beginWarp() {
        this.is_warping = true;
        this.vel.addSpeed(this.thrustSpeed * 5, this.rot);
    }
    finishWarp() {
        var player = this.getPlayer();
        player.useFuel(WARP_FUEL);
        player.shipHp = this.hp;

        if(player.canWarpImmediately()) {
            // Immediately warp to next area
            player.warp();
        } else {
            // Pop up a menu, so player can choose where to warp to next
            player.setMenu(WarpMapMenu);
        }

        this.die();
    }
    render(canvas, camera) {
        var fade = 1;
        if(this.fadeWithAge && this.maxAge > 0) {
            // maxFade: don't set fade lower than 1 - maxFade, that
            // would be too close to 0, so we wouldn't be able to see
            // the Entity
            var maxFade = .85;
            fade = 1 - (this.age / this.maxAge) * maxFade;
        }

        var ctx = canvas.getContext('2d');
        ctx.globalAlpha = fade;
        super.render(canvas, camera);
        ctx.globalAlpha = 1;
    }
    _render(canvas, camera, addx, addy) {
        super._render(canvas, camera, addx, addy);
        var player = this.getPlayer(true);
        if(player) player.renderEntity(canvas, camera, addx, addy);
    }
    renderCircle(canvas, camera, addx, addy) {
        super.renderCircle(canvas, camera, addx, addy);
        if(this.shouldRenderCircleLine) {
            this.renderCircleLine(canvas, camera, addx, addy);
        }
    }
    renderCircleLine(canvas, camera, addx, addy) {
        /* Render a little line indicating this.rot */
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        var p = new Point(this.radius).rotate(this.rot);
        var x1 = x0 + p.x;
        var y1 = y0 + p.y;
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = this.circleStrokeStyle;
        ctx.lineWidth = this.circleLineWidth;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.stroke();
    }
    vibrate(duration, weakMagnitude, strongMagnitude) {
        if(!VIBRATE) return;
        var player = this.getPlayer();
        if(!player) return;
        if(player.gamepad && player.gamepad.vibrationActuator) {
            player.gamepad.vibrationActuator.playEffect("dual-rumble", {
              startDelay: 0,
              duration: duration,
              weakMagnitude: weakMagnitude,
              strongMagnitude: strongMagnitude,
            });
        }
    }
}

class Camera extends FieldParticle {
    velmul = .7;
    springmul = .1;

    // target: Entity or null
    target = null;

    constructor(field, target) {
        super(field);

        target = getDefault(target, null);

        if(target) this.setTarget(target);
        else this.pos.setMidpoint(field.size);
    }
    setTarget(target) {
        this.target = target;
        this.initFromTarget();
    }
    unsetTarget() {
        this.target = null;
    }
    initFromTarget() {
        if(!this.target) return;
        this.pos.copy(this.target.pos);
    }
    step() {
        this.vel.mul(this.velmul);

        if(this.target && this.target.removed) this.unsetTarget();

        if(this.target) {
            var x0 = this.pos.x;
            var y0 = this.pos.y;
            var x1 = this.target.pos.x;
            var y1 = this.target.pos.y;
            this.vel.x += moduloDiff(x0, x1, this.field.size.x)
                * this.springmul;
            this.vel.y += moduloDiff(y0, y1, this.field.size.y)
                * this.springmul;
        }
    }
}

class Pickup extends Entity {
    static name = 'Pickup';

    radius = 6 * RADIUSMUL;
    velmul = .95;

    circleStrokeStyle = 'rgb(255,255,255,.75)';
    circleFillStyle   = 'rgba(255,255,255,.15)';
    circleLineWidth = 2;

    picture = Picture.newPolygon(3);

    constructor(field) {
        super(field);

        var r = Random.randInt(3);
        this.radius = (4 + r * 1.25) * RADIUSMUL;
        this.pickupAmount = 5 + r * 5;
    }
    handleCollision(other) {
        if(other instanceof Ship && other.canPickup(this)) {
            this.handlePickedUp(other);
        }
        super.handleCollision(other);
    }
    handlePickedUp(other) {
        this.die();
    }
    die() {
        this.emitEffects(PickupEffect, 6, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class EnergyPickup extends Pickup {
    static name = 'Energy';

    circleStrokeStyle = ENERGY_COLOR;
    picture = ENERGY_PICTURE;

    handlePickedUp(other) {
        other.heal(this.pickupAmount);
        super.handlePickedUp(other);
    }
}

class FuelPickup extends Pickup {
    static name = 'Fuel';

    circleStrokeStyle = FUEL_COLOR;
    picture = FUEL_PICTURE;

    handlePickedUp(other) {
        var player = other.getPlayer();
        if(player) {
            player.addFuel(this.pickupAmount);
        }
        super.handlePickedUp(other);
    }
}

class GoldPickup extends Pickup {
    static name = 'Gold';

    circleStrokeStyle = GOLD_COLOR;
    picture = GOLD_PICTURE;

    handlePickedUp(other) {
        var player = other.getPlayer();
        if(player) {
            player.addGold(this.pickupAmount);
        }
        super.handlePickedUp(other);
    }
}


class Trinket {
    /* Something with no particular use, which players can obtain */

    constructor(name, description) {
        this.name = name;
        this.description = description;
    }
}

class Player {
    /* Base class for human and CPU players */

    shipClass = null;

    constructor(game) {
        this.game = game;
        this.entity = null;
        this.team = TEAMS.get('green');
        this.keys = Key.createKeys();
    }
    cleanup() {
        if(this.entity) this.entity.die();
    }
    setTeam(team) {
        this.team = team;
        if(this.entity) this.entity.setTeam(team);
    }
    setEntity(entity) {
        this.unsetEntity();
        this.entity = entity;
        entity.setTeam(this.team);
    }
    unsetEntity() {
        if(!this.entity) return;
        this.entity = null;
    }
    getField() {
        throw new Error('Subclasses should override this method');
    }
    createShip(cls) {
        cls = cls || this.shipClass;
        this.shipClass = cls;

        var field = this.getField();

        var ship = field.addShip(cls);
        ship.pos.setRandomWithin(field.size);
        ship.rot = Random.randRotation();
        this.setEntity(ship);
        return ship;
    }
    _beforeStep() {
        if(this.entity && this.entity.removed) this.entity = null;
    }
    _updateEntityKeys(keys) {
        if(this.entity) Key.copyKeys(keys, this.entity.keys);
    }
    _stepKeys() {
        for(var keyname of KEYNAMES) {
            var key = this.keys[keyname];
            key.step();
        }
    }
    step() {
        this._beforeStep();
        this._updateEntityKeys(this.keys);
        this._stepKeys();
    }
    renderEntity(canvas, camera, addx, addy) {
        // Render any extra stuff around our entity (who has just been
        // rendered).
        // (To be overridden by subclasses)
    }
    tookDamage(other) {
        // What do we do when our entity takes damage from another?
        // (To be overridden by subclasses)
    }
}

class HumanPlayer extends Player {
    /* A human player */

    // trinkets: Array of Trinket
    trinkets = [];

    // shipHp: saved between areas when warping.
    // MAYBE TODO: make a new class, StuffToSave or whatever, so we can
    // save more than just hp?..
    shipHp = null;

    // addmaxhp: whenever a new ship is created for us, add this much to its
    // max hp.
    addmaxhp = 0;

    // increase(Thrust|Reverse|Rot)Speed: integers which, when increased, add
    // a small multiplier to ship's thrustSpeed, reverseSpeed, or rotspeed
    increaseThrustSpeed = 0;
    increaseReverseSpeed = 0;
    increaseRotSpeed = 0;

    // pickupMagnet: integer indicating how strong player's ship's pull on
    // nearby pickups is
    pickupMagnet = PICKUP_MAGNET;

    // (x|y)ShotLevel: integer powerup level for the indicated shot
    // ('x' or 'y').
    // Is used to set Shotprops.level.
    xShotLevel = X_SHOT_LEVEL;
    yShotLevel = Y_SHOT_LEVEL;

    maxfuel = DEFAULT_MAXFUEL;
    fuel = DEFAULT_MAXFUEL / 2;

    maxgold = MAXGOLD;
    gold = RICH? MAXGOLD: 0;

    shipClasses = ALL_SHIPS? SHIP_CLASSES.getValues():
        [FighterShip, ScoutShip, AssaultShip];

    // gamepad_index: index into navigator.getGamepads(), or -1
    gamepad_index = -1;

    // gamepad: an HTML5 Gamepad instance, or null
    // (not really a persistent value, rather it's stored onto player at
    // the start of each step)
    gamepad = null;

    // Slightly hacky, lets us detect keydown events by comparing
    // this.keys.enter.wasDown against this.prevEnterWasDown (key's
    // wasDown value from previous step).
    prevEnterWasDown = false;

    menu = null;

    camera = null;

    constructor(game, canvas, progress) {
        super(game);
        this.canvas = canvas;
        this.progress = progress;

        // gamepad_keys: set directly each step based on gamepad state,
        // as opposed to being manipulated in response to events.
        this.gamepad_keys = Key.createKeys();

        // combined_keys: this.keys unioned with this.gamepad_keys
        this.combined_keys = Key.createKeys();

        this._getOrCreateField();
    }
    cleanup() {
        this._removeFromField();
        this.menu.cleanup();
        canvas_container.removeChild(this.canvas);

        super.cleanup();
    }
    _removeFromField() {
        /* Removes this player from their current field (if any) */

        var field = this.progress.getField();
        if(!field) return;

        field.removePlayer(this);
        if(!field.players.length) {
            // If we were the last player in field, remove the field from the map
            this.progress.unsetField();
        }
    }
    _getOrCreateField() {
        /* Finds or creates the field for player.progress, and adds player
        to it. */

        var field = this.progress.getField();
        if(!field) {
            var template = this.progress.template;
            var size = template.getSize();

            field = new Field(this.game, size);
            field.populate(template);

            // add field to game.fields *next* step -- not *this* step,
            // because we're probably iterating over game.fields right now!
            this.game.pendingFields.push(field);

            // Store field in this.progress.map
            this.progress.setField(field);
        }

        this.camera = field.addCamera();

        field.addPlayer(this);
        return field;
    }
    getField() {
        /* Overrides Player.getField */
        return this.progress.getField();
    }
    getIndex() {
        // HACK: we assume all players have consistent indices in the
        // game.players Array.
        // That's... probably fine?..
        return this.game.players.indexOf(this);
    }
    addFuel(fuel) {
        this.fuel += fuel;
        if(this.fuel > this.maxfuel) this.fuel = this.maxfuel;
    }
    useFuel(fuel) {
        this.fuel -= fuel;
        if(this.fuel < 0) this.fuel = 0;
    }
    addGold(gold) {
        this.gold += gold;
        if(this.gold > this.maxgold) this.gold = this.maxgold;
    }
    useGold(gold) {
        this.gold -= gold;
        if(this.gold < 0) this.gold = 0;
    }
    canWarp() {
         return this.fuel >= WARP_FUEL;
    }
    beginWarp() {
        this.entity.beginWarp();
    }
    canWarpImmediately() {
        return this.progress.canProceed();
    }
    warp(edge) {
        /* Warp to the next Field */

        edge = getDefault(edge, null);

        this._removeFromField();
        if(edge) {
            // Proceed directly to given edge
            this.progress.setEdge(edge);
        } else {
            // Proceed to next field
            this.progress.proceed();
        }
        var field = this._getOrCreateField();

        if(field.shop) {
            // Do *NOT* "revive" player until they are done shopping!..
            // ShopMenu will handle that when it is closed.
            // That way, player's ship is created with the proper upgrades.
            this.setMenu(ShopMenu);
        } else {
            // "Revive" (create) player's ship after warping.
            this.reviveShip();
        }
    }
    createShip(cls) {
        var ship = super.createShip(cls);
        this.addShipBuffs(ship);
        this.camera.setTarget(ship);
        return ship;
    }
    addShipBuffs(ship) {
        // Tweak ship's properties based on items player has bought

        ship.maxhp += this.addmaxhp;
        ship.hp += this.addmaxhp;

        ship.pickupMagnet += this.pickupMagnet;

        ship.thrustSpeed *= (1 + .65 * this.increaseThrustSpeed);
        ship.reverseSpeed *= (1 + .65 * this.increaseReverseSpeed);
        ship.rotspeed *= (1 + .2 * this.increaseRotSpeed);

        for(var keyname of 'xy') {
            ship.shotprops[keyname].level += this[keyname + 'ShotLevel'];
        }

        // Allow ship to tweak itself based on the buffs, in particular
        // Shotprops.level.
        ship.afterAddShipBuffs();
    }
    reviveShip() {
        // "Revive" the ship "killed" when you warped from previous area
        var ship = this.createShip();
        if(this.shipHp !== null) ship.setHp(this.shipHp);

        return ship;
    }
    setMenu(cls) {
        var previous = this.menu;
        this.menu = new cls(this);
        this.menu.previous = previous;

        Key.copyKeys(this.combined_keys, this.menu.keys);
        Key.copyKeys(this.combined_keys, this.menu.prevKeys);

        // Unpress all keys so our ship doesn't fly in circles
        // or whatever while menu is open
        if(this.entity) {
            for(var keyname of KEYNAMES) this.entity.keys[keyname].up();
        }
    }
    unsetMenu() {
        if(!this.menu) return;
        this.menu.cleanup();
        this.menu = this.menu.previous;
    }
    step() {
        this._beforeStep();

        if(this.entity && this.fuel < WARP_FUEL) {
            this.addFuel(DEFAULT_ADDFUEL);
        }

        if(this.gamepad) {
            // If a gamepad is connected for this player, update
            // this.gamepad_keys based on gamepad's input
            this.handleGamepadInput();
        } else {
            // Reset gamepad keys if no gamepad is connected
            for(var keyname of KEYNAMES) {
                var gamepad_key = this.gamepad_keys[keyname];
                gamepad_key.up();
            }
        }

        for(var keyname of KEYNAMES) {
            var key = this.keys[keyname];
            var gamepad_key = this.gamepad_keys[keyname];
            this.combined_keys[keyname].copy(key).union(gamepad_key);
            gamepad_key.step();
        }

        // Slightly hacky: figure out whether a keydown event happened for our
        // "enter" key
        var enterWentDown = (
            !this.prevEnterWasDown && this.combined_keys.enter.wasDown);
        this.prevEnterWasDown = this.combined_keys.enter.wasDown;

        if(this.menu) {
            if(this.menu instanceof TabMapMenu && !this.combined_keys.tab.isDown) {
                this.unsetMenu();
            } else {
                Key.copyKeys(this.combined_keys, this.menu.keys);
                this.menu.step();
            }
        } else if(enterWentDown) {
            this.setMenu(MainMenu);
        } else if(this.combined_keys.tab.isDown) {
            this.setMenu(TabMapMenu);
        } else {
            this._updateEntityKeys(this.combined_keys);
        }

        this._stepKeys();
    }
    handleGamepadInput() {
        var gamepad = this.gamepad;

        for(var button_index in GAMEPAD_BUTTONS) {
            var keyname = GAMEPAD_BUTTONS[button_index];
            var key = this.gamepad_keys[keyname];
            var button = gamepad.buttons[button_index];
            if(button.pressed) key.down();
            else key.up();
        }

        var x_axis = gamepad.axes[0];
        var y_axis = gamepad.axes[1];
        this.gamepad_keys.l.set(x_axis < -GAMEPAD_AXIS_THRESHOLD);
        this.gamepad_keys.r.set(x_axis >  GAMEPAD_AXIS_THRESHOLD);
        this.gamepad_keys.u.set(y_axis < -GAMEPAD_AXIS_THRESHOLD);
        this.gamepad_keys.d.set(y_axis >  GAMEPAD_AXIS_THRESHOLD);
    }
}

class CPUPlayer extends Player {

    // The Entity we're currently interested in, or null.
    target = null;

    constructor(game, field) {
        super(game);

        this.field = field;

        // Distance past which we lose interest in our target
        this.max_target_dist = Random.randNumber(150, 300) * RADIUSMUL;

        // fear_hp_percent: hp below which we fear this.target
        this.fear_hp_percent = Random.randNumber(.15, .9);
    }
    getField() {
        /* Overrides Player.getField */
        return this.field;
    }
    getFearHp() {
        return this.fear_hp_percent * this.entity.maxhp;
    }
    isFearful() {
        return this.entity.hp < this.getFearHp();
    }
    getTargetDist() {
        // Distance between our entity and our target
        // (Assumes they both exist)
        return Math.max(0, this.entity.dist(this.target)
            - this.entity.radius - this.target.radius);
    }
    step() {
        this._beforeStep();

        if(this.target && this.target.removed) this.target = null;
        if(this.entity && this.target) {
            var targetDist = this.getTargetDist();
            if(targetDist > this.max_target_dist) this.target = null;
        }

        // Press/release keys
        if(this.entity && this.target) {
            // Bit hacky, this
            if(this.isFearful()) {
                this.entity.avoidTarget(this.target, this.keys);
            } else {
                this.entity.aimForTarget(this.target, this.keys);
            }
        } else if(this.entity) {

            // Entity decides which keys to press/release
            // (Basically so each subclass of Ship can override the default
            // "press random keys" implementation and maybe do something
            // slightly smarter for its shotClasses.
            // TODO: so maybe it's better to implement CPU stuff in CPUPlayer,
            // by switching on entity's shotClasses?..)
            this.entity.stepCPUKeys(this.keys);

        } else {
            for(var keyname in this.keys) {
                var key = this.keys[keyname];
                key.up();
            }
        }

        super.step();
    }
    renderEntity(canvas, camera, addx, addy) {
        super.renderEntity(canvas, camera, addx, addy);

        if(this.entity && this.target) {
            var targetDist = this.getTargetDist();

            var strokeStyle = 'rgba(255,200,255,.5)';
            var lineWidth = 2;
            if(this.isFearful()) {
                strokeStyle = 'rgba(200,0,200,.5)';
            }

            var fade = Math.max(.25, 1 - targetDist / this.max_target_dist);
            this.entity.renderLineTo(canvas, camera, addx, addy, this.target,
                strokeStyle, lineWidth, fade);
        }
    }
    tookDamage(other) {
        super.tookDamage(other);
        if(this.entity && other && !this.entity.isAlly(other)) {
            this.target = other;
        }
    }
}

class Game {

    constructor(map) {
        this.map = map;

        canvas_container.addEventListener('keydown', this.onKeyDown.bind(this));
        canvas_container.addEventListener('keyup', this.onKeyUp.bind(this));

        window.addEventListener('gamepadconnected',
            this.onGamepadActivity.bind(this));
        window.addEventListener('gamepaddisconnected',
            this.onGamepadActivity.bind(this));

        this.intervalId = 0;
        this.players = [];

        this.fields = [];
        this.pendingFields = [];

        // Whether to bother polling for gamepads
        this.gamepadsConnected = false;

        // HTML5 GamepadList or null
        this.gamepads = null;

        /* Hashmap from keyCode values to Key instances belonging to
        HumanPlayer instances in this.players */
        this.keysByCode = {};

        this.tick = 0;
    }
    onKeyDown(event) {
        if(!event.repeat) this.keyDown(event.keyCode);
        event.preventDefault();
    }
    onKeyUp(event) {
        if(!event.repeat) this.keyUp(event.keyCode);
        event.preventDefault();
    }
    onGamepadActivity(event) {
        // This handler is for either of these events:
        //   'gamepadconnected'
        //   'gamepaddisconnected'
        // ...why? Well you see:
        // Apparently the Gamepad API can be a bit wonky, and fire
        // 'gamepaddisconnected' when gamepads are connected.
        // Also, I've found that holding onto a Gamepad object is no
        // good -- its buttons are never updated.
        // So we need to call navigator.getGamepads() ever frame anyway.
        // SOOOO, instead of trying to detect when gamepads are
        // connected/disconnected, we just listen for either event, and
        // in either case *somebody was touching a gamepad at some point*,
        // so we flip a flag which tells us to bother polling
        // navigator.getGamepads() every frame.
        // Make sense?
        // Hahahahaha sure
        this.gamepadsConnected = true;
    }
    mapKey(key, keyCode) {
        this.keysByCode[keyCode] = key;
    }
    mapKeys(keys, keymap) {
        for(var keyname in keymap) {
            this.mapKey(keys[keyname], keymap[keyname]);
        }
    }
    getKeyCode(findKey) {
        for(var keyCode in this.keysByCode) {
            if(this.keysByCode[keyCode] === findKey) return keyCode;
        }
        return -1;
    }
    getKeyByCode(findKeyCode) {
        for(var keyCode in this.keysByCode) {
            if(keyCode === findKeyCode) return this.keysByCode[keyCode];
        }
        return null;
    }
    remapKey(key, keyCode) {
        var oldKeyCode = this.getKeyCode(key);
        if(oldKeyCode !== -1) delete this.keysByCode[oldKeyCode];
        this.mapKey(key, keyCode);
    }
    keyDown(keyCode) {
        var key = this.keysByCode[keyCode];
        if(key) key.down();
    }
    keyUp(keyCode) {
        var key = this.keysByCode[keyCode];
        if(key) key.up();
    }
    addPlayer() {
        var canvas = document.createElement('canvas');
        canvas.className = 'canvas';
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        canvas_container.appendChild(canvas);
        this._updateCanvasWidths(this.players.length + 1);

        var player = this._addPlayer(canvas);
        var field = player.getField();

        if(field.shop) player.setMenu(ShopMenu);
        else player.setMenu(ChooseShipMenu);

        var keymapping = getDefault(
            DEFAULT_PLAYER_KEYMAPPINGS[player.getIndex()], null);
        if(keymapping) this.mapKeys(player.keys, keymapping);

        return player;
    }
    _addPlayer(canvas, progress) {
        if(!progress) progress = new MapProgress(this.map);

        var player = new HumanPlayer(this, canvas, progress);
        this.players.push(player);

        // Slight hack: setting this here, instead of HumanPlayer's
        // constructor, so that getIndex returns correct value
        player.gamepad_index = player.getIndex();

        return player;
    }
    _updateCanvasWidths(n_players) {
        n_players = getDefault(n_players, this.players.length);
        var canvases = document.getElementsByClassName('canvas');
        for(var canvas of canvases) {
            var players_per_row = Math.min(n_players, 2);
            canvas.style.maxWidth = String(
                Math.floor(100 / players_per_row)) + '%';
        }

        if(n_players > 1) {
            // HACKY MULTIPLAYER INTERFACE... just remove the controls :P
            controls.style.display = 'none';
        } else {
            controls.style.display = '';
        }
    }
    removePlayer() {
        // NOTE: you can only remove the last player, not an arbitrary
        // one. That's because we rely on players' indices into game.players,
        // see HumanPlayer.getIndex().

        if(this.players.length <= 1) throw new Error("Can't have no players");

        var player = this.players[this.players.length - 1];
        player.cleanup();
        this.players.pop();
        this._updateCanvasWidths();
    }
    step() {

        // Unset player.gamepad for all players.
        for(var player of this.players) player.gamepad = null;

        // Maybe poll for gamepads, and set player.gamepad for players
        // with a connected gamepad.
        if(this.gamepadsConnected) {
            var gamepads = navigator.getGamepads();
            for(var player of this.players) {
                player.gamepad =
                    getDefault(gamepads[player.gamepad_index], null);
            }
        }

        this.map.step();

        for(var player of this.players) player.step();

        if(this.pendingFields.length) {
            for(var field of this.pendingFields) this.fields.push(field);
            this.pendingFields.length = 0;
        }

        for(var i = 0; i < this.fields.length; i++) {
            var field = this.fields[i];
            for(var player of field.cpus) player.step();

            field.step();
            if(!field.players.length) {
                // Remove fields which have no remaining references to them
                // (i.e. all players have warped out)
                field.cleanup();
                removeArrayElem(this.fields, field);
                i--;
                continue;
            }

            for(var camera of field.cameras) {
                camera.step();
                camera.stepPhysics();
            }
        }

        this.tick++;
    }
    renderPlayer(player) {
        var canvas = player.canvas;
        var ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        var field = player.getField();
        field.render(canvas, player.camera);

        if(player.menu) {
            player.menu.render(canvas);
        } else {
            var text = player.progress.template.text;
            if(text && !HIDE_TEXT) text.render(canvas);
        }

        this.renderPlayerStats(player);
    }
    renderTextPictures(canvas, text, writer, x0, y0, letterWidth, letterHeight, padWidth, padHeight, render_opts) {
        writer = getDefault(writer, blockyWriter);
        x0 = getDefault(x0, 0);
        y0 = getDefault(y0, 0);
        letterWidth = getDefault(letterWidth, 14);
        letterHeight = getDefault(letterHeight, 12);
        padWidth = getDefault(padWidth, 4);
        padHeight = getDefault(padHeight, 4);

        var x = x0;
        var y = y0;

        // "radius" x and y are just half the width * height.
        // Weird nomenclature, but anyway they are ultimately used as
        // multipliers of picture's points' x and y positions.
        var radius_x = letterWidth / 2;
        var radius_y = letterHeight / 2;

        var pictures = writer.getPictures(text);
        for(var picture of pictures) {

            // NOTE: we add radius_x/y (that is, half letter's width/height)
            // to x and y, because the letters' origins are in their centers,
            // but for rendering text we want to treat their top-left
            // corners as their origins.
            picture.render(canvas,
                x + radius_x, y + radius_y,
                0, radius_x, radius_y, render_opts);

            x += letterWidth + padWidth;
        }
    }
    renderPlayerStats(player) {
        var canvas = player.canvas;
        var ctx = canvas.getContext('2d');

        // Arguments to this.renderTextPictures:
        var writer = blockyWriter;
        var letterWidth = 20;
        var letterHeight = 24;
        var padWidth = 4;
        var padHeight = 4;

        // Number of lines of text we plan to render (bit of a hack, this)
        var n_lines = 3;

        var x0 = padWidth * 2;
        var y0 = canvas.height
            - letterHeight * n_lines
            - padHeight * (n_lines - 1)
            - padHeight * 2;
        var x = x0;
        var y = y0;
        var dx = letterWidth + padWidth;
        var dy = letterHeight + padHeight;

        var game = this;
        function renderText(text, strokeStyle) {
            var is_colored = strokeStyle !== undefined;
            strokeStyle = getDefault(strokeStyle, 'rgb(255,255,255)');
            var render_opts = {
                lineWidth: 2,
                strokeStyle: strokeStyle,
                fillStyle: is_colored? 'rgba(255,255,255,.25)':
                    'rgb(255,255,255)',
            };
            game.renderTextPictures(canvas, text, writer, x, y,
                letterWidth, letterHeight, padWidth, padHeight, render_opts);
            x += dx;
        }
        function newline() {
            x = x0;
            y += dy;
        }
        var parseAmount = amount =>
            parseInt(amount).toString().padStart(3, ' ');

        var entity = player.entity;
        if(entity) {
            renderText('E', ENERGY_COLOR);
            var text = ': ' + parseAmount(entity.hp)
                + ' / ' + parseAmount(entity.maxhp);
            if(entity.rock) {
                var rock = entity.rock;
                text += ' [' + parseAmount(rock.hp)
                    + ' / ' + parseAmount(rock.maxhp) + ']';
            }
            renderText(text);
        }
        newline();

        renderText('F', FUEL_COLOR);
        renderText(': ' + parseAmount(player.fuel)
            + ' / ' + parseAmount(player.maxfuel));
        newline();

        renderText('G', GOLD_COLOR);
        renderText(': ' + parseAmount(player.gold));
        newline();
    }
    renderTitle(canvas, title, subtitles) {
        var ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';

        var x = canvas.width / 2;
        var y = canvas.height / 4;

        ctx.font = 'normal bold 40px sans-serif';
        ctx.fillText(title, x, y);
        y += 40;

        if(subtitles) for(var subtitle of subtitles) {
            ctx.font = 'normal bold 20px sans-serif';
            ctx.fillText(subtitle, x, y);
            y += 20;
        }
    }
    intervalCallback() {
        /* Callback for use with setInterval */
        if(TIMING) var t0 = new Date();
        try {
            this.step();
            for(var player of this.players) this.renderPlayer(player);
        } catch(ex) {
            // Stop the same error from throwing repeatedly.
            // Don't set this.intervalId to 0 though, for debugging
            // purposes.
            clearInterval(this.intervalId);

            throw ex;
        }
        if(TIMING) {
            var t1 = new Date();
            console.log('TIMING: ' + String(t1 - t0));
        }
    }
    play(millis) {
        millis = getDefault(millis, 30);
        if(this.intervalId) clearInterval(this.intervalId);
        var callback = this.intervalCallback.bind(this);
        this.intervalId = setInterval(callback, millis);
    }
    pause() {
        if(!this.intervalId) return;
        clearInterval(this.intervalId);
        this.intervalId = 0;
    }
}

class Menu {
    constructor(player) {
        this.player = player;
        this.game = player.game;

        // keys: updated by this.player before this.step() is called
        this.keys = Key.createKeys();

        // prevKeys: the values of this.keys from previous step
        this.prevKeys = Key.createKeys();

        // previous: Menu instance or null.
        // (The Menu to return to when this one is closed)
        this.previous = null;
    }
    cleanup() {
    }
    step() {
        for(var keyname of KEYNAMES) {
            var prevKey = this.prevKeys[keyname];
            var key = this.keys[keyname];
            if(!prevKey.wasDown && key.wasDown) {
                this.keyDown(keyname);
            }
        }

        Key.copyKeys(this.keys, this.prevKeys);
    }
    keyDown(keyname) {
    }
    render(canvas) {
    }
}

class MenuOption {
    /* An option of OptionsMenu */

    constructor(title, value, description) {
        this.title = title;

        // The type of value depends on the subclass of OptionsMenu
        this.value = value;

        this.description = getDefault(description, null);
    }
}

class OptionsMenu extends Menu {
    /* A menu which displays a list of options to be selected. */

    title = "??? Menu";

    // String displayed for the option to exit this menu
    finish_text = 'Leave menu';

    // Array of string
    description = [];

    // option_i: index into this.options, or -1 for "go back"
    option_i = -1;

    // options: Array of MenuOption
    // (to be overridden by subclasses)
    options = null;

    // Array of string, set by this.update()
    subtitles = null;

    initOptions() {
        // To be called at the end of subclasses' constructors,
        // after they've set this.options.

        if(this.options.length) this.option_i = 0;
        this.update();
    }
    getSelectedOption() {
        if(!this.options.length) return null;
        if(this.option_i < 0) return null;
        return this.options[this.option_i];
    }
    update() {
        this.subtitles = this.description.slice();
        this.subtitles.push('');

        var LBRACKET = '> ';
        var RBRACKET = ' <';

        if(!this.options.length) {
            this.subtitles.push('...no options!');
            this.subtitles.push('');
        }

        var selected_option = this.getSelectedOption();

        for(var i = 0; i < this.options.length; i++) {
            var option = this.options[i];

            var subtitle = this.getOptionTitle(option);
            if(option === selected_option) {
                subtitle = LBRACKET + subtitle + RBRACKET;
            }
            this.subtitles.push(subtitle);
        }

        var MDASH = '\u2014';
        var HLINE = MDASH.repeat(20);
        this.subtitles.push(HLINE);

        var subtitle = this.finish_text;
        if(this.option_i === -1) {
            subtitle = LBRACKET + subtitle + RBRACKET;
        }
        this.subtitles.push(subtitle);

        if(selected_option && selected_option.decription) {
            this.subtitles.push('');
            this.subtitles.push(selected_option.description);
        }
    }
    getOptionTitle(option) {
        // May be overridden by subclasses
        return option.title;
    }
    keyDown(keyname) {
        if(keyname === 'u') {
            this.option_i--;
            if(this.option_i < -1) {
                this.option_i = this.options.length - 1;
            }
            this.update();
        } else if(keyname === 'd') {
            this.option_i++;
            if(this.option_i >= this.options.length) {
                this.option_i = -1;
            }
            this.update();
        } else if(keyname === 'enter') {
            if(this.option_i === -1) {
                this.finish();
            } else {
                var option = this.getSelectedOption();
                if(option) this.select(option);
            }
        }
    }
    select(option) {
        // To be overridden by subclasses
        this.update();
    }
    finish() {
        this.player.unsetMenu();
    }
    render(canvas) {
        this.game.renderTitle(canvas, this.title, this.subtitles);
    }
}

class BranchMenuOption extends MenuOption {
    /* An option whose value is a subclass of Menu */

    constructor(title, value, description, closeCallingMenu) {
        super(title, value, description);

        // Whether the calling menu closes itself before opening
        // the sub-menu (so that leaving the sub-menu doesn't take you
        // back to the calling menu)
        this.closeCallingMenu = getDefault(closeCallingMenu, false);
    }
}

class RunnableMenuOption extends MenuOption {
    /* An option whose value is a function to be called when the option
    is selected.
    The function takes one argument: the selected RunnableMenuOption.
    The function's "this" is the calling Menu.
    The function's return value is ignored. */
}

class BranchingMenu extends OptionsMenu {
    /* A menu whose purpose is to list submenus (i.e. branches).
    NOTE: this.options[i] should be a BranchMenuOption or a
    RunnableMenuOption */

    select(option) {
        if(option instanceof BranchMenuOption) {
            if(option.closeCallingMenu) this.player.unsetMenu();
            this.player.setMenu(option.value);
        } else if(option instanceof RunnableMenuOption) {
            option.value.call(this, option);
        } else {
            console.log(this, option);
            throw new Error(
                "Expected BranchMenuOption or RunnableMenuOption, got: "
                + option.constructor.toString());
        }
        super.select(option);
    }
}

class MainMenu extends BranchingMenu {
    title = "Main menu";

    options = [
        new BranchMenuOption("Choose ship", ChooseShipMenu, undefined, true),
        new BranchMenuOption("Set keyboard controls", KeyboardControlsMenu),
        new BranchMenuOption("Set gamepad controls", GamepadControlsMenu),
        new RunnableMenuOption("Add player", function(option) {
            if(this.game.players.length < MAX_PLAYERS) this.game.addPlayer();
        }),
        new RunnableMenuOption("Remove player", function(option) {
            if(this.game.players.length > 1) this.game.removePlayer();
        }),
    ];

    constructor(player) {
        super(player);
        this.initOptions();
    }
}

class KeyboardControlsMenu extends OptionsMenu {
    /* A menu which allows a player to set their controls. */

    title = "Set keyboard controls";

    // waitingForKey: Key or null.
    // If non-null, should be one of the Key instances in this.player.keys,
    // and we are waiting for player to press a key so that we can remap
    // its keycode.
    waitingForKey = null;

    constructor(player) {
        super(player);

        this.options = KEYINFOS.map(keyinfo =>
            new MenuOption(keyinfo.title, keyinfo, keyinfo.description));

        this.initOptions();
    }
    getOptionTitle(option) {
        var subtitle = option.title;

        var keyinfo = option.value;
        var key = this.player.keys[keyinfo.name];
        var keyCode = this.game.getKeyCode(key);
        if(key === this.waitingForKey) {
            subtitle += ' [ ...please press a key... ]';
        } else if(keyCode !== -1) {
            subtitle += ' [' + keyCode + ']';
        } else {
            subtitle += ' [ unmapped ]';
        }

        return subtitle;
    }
    select(option) {
        var keyinfo = option.value;
        var key = this.player.keys[keyinfo.name];

        this.waitingForKey = key;

        if(this.game.hasOwnProperty('keyDown')) {
            // If game.keyDown is already monkey-patched, that should mean
            // another player was in the process of setting their keys, and
            // we somehow selected one of our keys (probably with a gamepad).
            // So we call the monkey-patch, passing it a magic "unmapped"
            // keyCode value, and causing the monkey-patch to remove itself.
            this.game.keyDown(-1);
        }

        // Delicious HACK: we use Javascript magic to monkey-patch the game's
        // global keydown handler. Wheeeeee
        var menu = this;
        var game = this.game;
        game.keyDown = function(keyCode) {
            game.remapKey(key, keyCode);

            // Delete this monkey-patch, so that subsequent references to
            // game.keyDown are resolved to the class method (Game.keyDown)
            delete game.keyDown;

            menu.waitingForKey = null;
            menu.update();
        }

        super.select(option);
    }
}

class GamepadControlsMenu extends OptionsMenu {
    /* A menu which allows a player to set their controls. */

    title = "Set gamepad controls";
    description = ['(TODO: allow changing behaviour of individual buttons)'];
    options = [
    ];

    constructor(player) {
        super(player);
        this.initOptions();
    }
}

class ShopMenu extends OptionsMenu {
    finish_text = 'Leave the shop';

    constructor(player) {
        super(player);

        var field = this.player.getField();
        this.shop = field.shop;
        this.title = this.shop.name;
        this.description = this.shop.description;

        this.options = this.shop.items.map(item =>
            new MenuOption(item.name, item, item.description));

        this.initOptions();
    }
    update() {
        super.update();

        var selected_option = this.getSelectedOption();

        if(selected_option) {
            var item = selected_option.value;
            var cantBuy = item.cantBuy(this.player);
            if(cantBuy) {
                this.subtitles.push('');
                this.subtitles.push(
                    "[Can't buy this: " + cantBuy + ']');
            }
        }
    }
    getOptionTitle(option) {
        var item = option.value;

        var subtitle = item.name + ' (' + item.price + ' G)';
        if(item.wasBoughtBy(this.player)) {
            subtitle = '[BOUGHT] ' + subtitle;
        } else if(item.price > this.player.gold) {
            subtitle = '[CAN\'T AFFORD] ' + subtitle;
        } else if(item.cantBuy(this.player)) {
            subtitle = '[CAN\'T BUY] ' + subtitle;
        }
        return subtitle;
    }
    select(option) {
        var item = option.value;
        if(item && !item.cantBuy(this.player)) {
            item.buy(this.player);
        }
        super.select(option);
    }
    finish() {
        // That is, "leave the shop"

        super.finish();

        if(!this.player.shipClass) {
            // HACK: if player hasn't chosen a ship yet, let them do so now.
            // This is just so that you can start the game at a shop node,
            // allowing you to buy upgrades first, *then* pick a ship (and
            // have the upgrades correctly applied to the ships created by
            // ChooseShipMenu).
            this.player.setMenu(ChooseShipMenu);
        } else {
            // When warping to an area with a shop, ShopMenu is opened and
            // players are *not* revived.
            // Now that we are closing ShopMenu, we revive the players.
            // Their ships will be created with any upgrades they bought.
            this.player.reviveShip();
        }
    }
}

class ChooseShipMenu extends Menu {
    ship_class_i = 0;

    // Array of string, set by this.updateShipClass()
    subtitles = null;

    constructor(player) {
        super(player);

        this.ship_class_i = player.shipClass === null?
            0: player.shipClasses.indexOf(player.shipClass);

        this.updateShipClass();
    }
    render(canvas) {
        this.game.renderTitle(canvas, 'Get Ready', this.subtitles);
    }
    keyDown(keyname) {
        if(keyname === 'l') {
            this.ship_class_i = modulo(this.ship_class_i - 1,
                this.player.shipClasses.length);
            this.updateShipClass();
        } else if(keyname === 'r') {
            this.ship_class_i = modulo(this.ship_class_i + 1,
                this.player.shipClasses.length);
            this.updateShipClass();
        } else if(keyname === 'enter') {
            this.player.unsetMenu();
        }
    }
    updateShipClass() {
        var old_ship = this.player.entity;

        var cls = this.player.shipClasses[this.ship_class_i];
        var ship = this.player.createShip(cls);

        // Point the ship upwards
        ship.rot = Math.PI / 2;

        var field = this.player.getField();

        if(old_ship) {
            ship.pos.copy(old_ship.pos);
            ship.vel.copy(old_ship.vel);
            ship.rot = old_ship.rot;

            old_ship.remove();

            // HACK: old_ship has only been marked for removal, we now
            // manually call the function which truly removes it.
            // We do this because otherwise, the old and new ships
            // coexist for one frame, which is enough time for them
            // to collide with each other...
            field.removeEntities(field.ships);
        } else {
            var i = this.player.getIndex();
            var addx = i * 14 * RADIUSMUL * 2;
            ship.pos.setMidpoint(field.size).addxy(addx);
        }

        // Reset camera's position to that of ship
        this.player.camera.initFromTarget();

        this.subtitles = [];
        this.subtitles.push('Choose your ship');
        switch(this.player.getIndex()) {
            case 0:
                this.subtitles.push('(Left/right arrow keys + Enter)');
                break;
            case 1:
                this.subtitles.push('(Z/C keys + H)');
                break;
            default: break;
        }
        this.subtitles.push('[' + cls.name + ']');
    }
}

class MapMenu extends Menu {
    /* A menu which shows this.player.progress */

    node = null;
    edge_i = 0;

    // edge: calculated by updateEdge() based on node, edge_i
    // (Never null!)
    edge = null;

    // text: instance of Text, calculated by updateEdge()
    text = null;

    constructor(player) {
        super(player);

        var progress = player.progress;
        var node = progress.node;
        var edge = progress.edge;
        var edge_i = edge? node.getEdgeIndex(edge): 0;
        this.setNode(node, edge_i);
    }
    updateEdge() {
        var n_edges = this.node.numEdges();
        var edge_i = modulo(this.edge_i, n_edges);
        this.edge = this.node.getEdge(edge_i);
        this.updateText();
    }
    updateText() {
        var title = this.node.title;
        var lines = [];

        var progress = this.player.progress;
        var node1 = this.edge.getNode1();
        if(progress.edge && this.edge === progress.edge) {
            lines.push('Travelling to: ' + node1.title);
            lines.push(
                'Progress: ' + progress.edgeDist
                + ' / ' + progress.edge.getLen());
        } else {
            lines.push('Towards: ' + node1.title);
            lines.push('Distance: ' + this.edge.getLen());
        }

        if(this.node.description.length) {
            lines.push('');
            lines = lines.concat(this.node.description);
        }

        this.addControls(lines);

        this.text = new Text(title, lines);
    }
    addControls(lines) {
        lines.push('');
        lines.push('Left/right: select branch');
    }
    setNode(node, edge_i) {
        this.node = node;
        this.edge_i = getDefault(edge_i, 0);
        this.updateEdge();
    }
    keyDown(keyname) {
        if(keyname === 'l') {
            this.edge_i--;
            this.updateEdge();
        } else if(keyname === 'r') {
            this.edge_i++;
            this.updateEdge();
        }
    }
    render(canvas) {
        var ctx = canvas.getContext('2d');

        this.text.render(canvas);

        var progress = this.player.progress;
        var map = progress.map;

        var pos0 = this.node === progress.node?
            progress.getPos(): this.node.pos;

        var x0 = canvas.width / 2 - pos0.x;
        var y0 = canvas.height / 2 - pos0.y;

        // Point used for calculations
        var p = new Point();

        for(var node of map.nodes) {
            var x = x0 + node.pos.x;
            var y = y0 + node.pos.y;
            var radius = node.radius;
            var strokeStyle = node.strokeStyle;
            var fillStyle = node.fillStyle;
            var lineWidth = 3;

            if(node === this.node) {
                strokeStyle = '#fff';
                lineWidth += 2;
            }

            ctx.strokeStyle = strokeStyle;
            ctx.fillStyle = fillStyle;
            ctx.lineWidth = lineWidth;
            renderCircle(ctx, x, y, 0, radius);

            for(var edge of node.edges) {
                var node2 = edge.node1;
                var edgeAngle = node.pos.angle(node2.pos);
                var x2 = x0 + node2.pos.x;
                var y2 = y0 + node2.pos.y;
                var strokeStyle = edge.strokeStyle;
                var lineWidth = 2;

                if(edge === this.edge.edge) {
                    strokeStyle = '#fff';
                    lineWidth += 2;
                }

                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = strokeStyle;
                ctx.fillStyle = 'rgba(255,255,255,.2)';

                // Draw the edge's line
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.closePath();
                ctx.stroke();

                // arrowPointSideLen: length in pixels of side of arrow's point
                var arrowPointSideLen = 12
                    * linear(node.radius, node2.radius, .75) / MAX_MAP_NODE_RADIUS
                    * edge.len;

                // arrowPointAngle: the angle of the arrow's point
                // (the smaller this is, the pointier the arrow is)
                var arrowPointAngle = Math.PI / 5;

                // arr_x, arr_y: the point of the arrow (partway between edge's
                // start and end nodes)
                var arr_m = .75;
                var arr_x = linear(x, x2, arr_m);
                var arr_y = linear(y, y2, arr_m);

                // Draw the edge's arrow
                ctx.beginPath();
                ctx.moveTo(arr_x, arr_y);
                p.set(arr_x, arr_y).addSpeed(arrowPointSideLen,
                    edgeAngle + arrowPointAngle / 2 + Math.PI);
                ctx.lineTo(p.x, p.y);
                p.set(arr_x, arr_y).addSpeed(arrowPointSideLen,
                    edgeAngle - arrowPointAngle / 2 + Math.PI);
                ctx.lineTo(p.x, p.y);
                ctx.lineTo(arr_x, arr_y);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            }
        }
    }
}

class TabMapMenu extends MapMenu {
    /* Menu player sees while holding tab (to view the entire map) */

    addControls(lines) {
        super.addControls(lines);
        lines.push('Up        : follow branch');
    }
    keyDown(keyname) {
        if(keyname === 'u') {
            this.setNode(this.edge.getNode1());
        } else {
            super.keyDown(keyname);
        }
    }
}

class WarpMapMenu extends MapMenu {
    /* Menu player uses to choose where to warp to next */

    addControls(lines) {
        super.addControls(lines);
        lines.push('Enter     : finish warping');
    }
    keyDown(keyname) {
        if(keyname === 'enter') {
            // We do this before calling player.warp(), because player.warp()
            // may call player.setMenu(ShopMenu)
            this.player.unsetMenu();

            this.player.warp(this.edge);
        } else {
            super.keyDown(keyname);
        }
    }
}

class Effect extends Entity {
    static name = 'Effect';
    fadeWithAge = true;
}

class WarpEffect extends Effect {
    radius = 2 * RADIUSMUL;
    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'rgba(0,255,255,.75)';
    circleFillStyle = 'transparent';

    velmul = .6;
    maxAge = 20;

    step() {
        this.radius += .5 * RADIUSMUL;
        super.step();
    }
}

class SmokeEffect extends Effect {
    radius = 7 * RADIUSMUL;
    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgba(200,200,200,.2)';
    velmul = 1;
    maxAge = 20;
}

class PickupEffect extends Effect {
    radius = 4 * RADIUSMUL;

    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgba(255,255,255,.3)';
    picture = Picture.newPolygon(4);

    velmul = .95;
    maxAge = 20;
}

class SnowflakeEffect extends Effect {
    radius = 4 * RADIUSMUL;

    circleStrokeStyle = 'rgb(255,255,255,.5)';

    picture = new Picture([
        new Shape([
            Point.unit(0 / 6),
            Point.unit(3 / 6),
        ], {fill: false}),
        new Shape([
            Point.unit(1 / 6),
            Point.unit(4 / 6),
        ], {fill: false}),
        new Shape([
            Point.unit(2 / 6),
            Point.unit(5 / 6),
        ], {fill: false}),
    ]);

    velmul = .85;
    maxAge = 20;
}

class FlameSmokeEffect extends SmokeEffect {
    radius = 4 * RADIUSMUL;
    circleFillStyle = 'rgba(75,75,50,.5)';
}

class ThrustEffect extends Effect {
    radius = 5 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(0,255,255,.7)';
    trailLineWidth = 3;
    maxAge = 20;
}

class SmokeThrustEffect extends SmokeEffect {
    radius = 3 * RADIUSMUL;
}

class SparkEffect extends Effect {
    radius = 3 * RADIUSMUL;
    shouldRenderTrail = true;
    trailEnd = .3;
    trailStrokeStyle = 'rgba(255,255,0,.7)';
    trailLineWidth = 3;
    velmul = .95;
    maxAge = 20;
}

class Ship extends Entity {
    static maxhp = 100;

    static name = 'Ship';

    // idealTargetDist: ideal distance from target based on our weapons etc
    // (for use by CPU players)
    idealTargetDist = 30 * RADIUSMUL;

    pickupMagnet = 0;

    getVelMul() {
        // Kind of ganky: all ships' velmul can be modified by a global
        // variable, so we can quickly tweak the "slidiness" of the controls
        return linear(super.getVelMul(), 1, SHIP_ADDVELMUL);
    }
    getShip() {
        return this;
    }
    canEmitGold() {
        // Can be overridden by subclasses
        return true;
    }
    canPickup(pickup) {
        // Can be overridden by subclasses
        return true;
    }
    afterAddShipBuffs() {
        // Called after our properties have been tweaked by
        // Player.addShipBuffs.
        // In particular, this would be a good time to update any of
        // our properties based on Shotprops.level.
        // To be overridden by subclasses.
    }
    dieFromDamage() {
        if(
            this.canEmitGold() &&
            Math.random() < this.field.template.gold_chance
        ) {
            this.emitPickup(GoldPickup);
        }
        super.dieFromDamage();
    }
    die() {
        this.emitEffects(SmokeEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class FighterShip extends Ship {
    static name = 'Fighter';

    radius = 7 * RADIUSMUL;
    thrustSpeed = 2;
    reverseSpeed = 1.25;
    velmul = .95;
    rotspeed = Math.PI / 25;
    rotmul = .45;

    static maxhp = 100;

    shotClass = {
        x: DoubleShot,
        y: DoubleMissileShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {stroke: false}),
        new Shape([
            new Point(-1  , -.95),
            new Point( 1.2,    0),
            new Point(-1  ,  .95),
        ], {fill: false, close: false}),
    ]);
}

class ScoutShip extends Ship {
    static name = 'Scout';
    radius = 6 * RADIUSMUL;

    static maxhp = 100;
    wingsOut = true;

    shotClassWingsOut = {
        x: QuadrupleShot,
        y: null,
    };

    shotClassWingsIn = {
        x: RapidDoubleShot,
        y: null,
    };

    pictureWingsOut = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point( -.2,   -1.8),
            new Point( -.1,   -.75),
            new Point( 1.2,    0),
            new Point( -.1,    .75),
            new Point( -.2,    1.8),
        ]),
    ]);

    pictureWingsIn = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point(- .7,   -.75),
            new Point( 1.2,    0),
            new Point(- .7,    .75),
        ]),
    ]);

    constructor(field) {
        super(field);
        this._updateStats();
    }
    _updateStats() {
        if(this.wingsOut) {
            this.thrustSpeed = 2.25;
            this.reverseSpeed = 1.5;
            this.velmul = .85;
            this.rotspeed = Math.PI / 25;
            this.rotmul = .6;
            this.picture = this.pictureWingsOut;
            this.shotClass = this.shotClassWingsOut;
        } else {
            this.thrustSpeed = 2.75;
            this.reverseSpeed = 1.75;
            this.velmul = .95;
            this.rotspeed = Math.PI / 30;
            this.rotmul = .4;
            this.picture = this.pictureWingsIn;
            this.shotClass = this.shotClassWingsIn;
        }
    }
    step() {

        var keyname = 'y';
        var shotprops = this.shotprops[keyname];
        if(shotprops.cooldown === 0) {
            var wingsOut = !this.keys[keyname].wasDown;
            if(wingsOut != this.wingsOut) {
                this.wingsOut = wingsOut;
                this._updateStats();
                shotprops.cooldown += 5;
            }
        }

        super.step();
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            // Don't switch between wings in/out too often
            if(key.isDown) {
                if(Math.random() < .05) key.up();
            } else {
                if(Math.random() < .05) key.down();
            }
        } else {
            super.stepCPUKey(key);
        }
    }
}

class RamShip extends Ship {
    static name = 'Ram';
    radius = 7 * RADIUSMUL;

    thrustSpeed = 1.5;
    reverseSpeed = .75;
    velmul = .97;
    rotspeed = Math.PI / 28;
    rotmul = .65;

    ramSpeed = 1.25;
    ramDamage = 35;
    minRamSpeed = 25;
    maxRamSpeed = 50;

    static maxhp = 100;

    shotClass = {
        x: ShortDoubleShot,
        y: null,
        extra1: ReverseFlameShot,
    };

    thrustEffects = 2;
    thrustEffectPosRot = Math.PI / 2;

    constructor(field) {
        super(field);

        this.shape_left = new Shape([
            new Point(-1.2, -.95),
            new Point( 1.2,    0),
            new Point(-1  ,    0),
        ]);
        this.shape_right = this.shape_left.clone().flip();
        this.shape_middle = Shape.newPolygon(4,
            {radiusmul: 0, rot: Math.PI / 4},
        ).mul(.2);
        this.picture = new Picture([
            this.shape_left,
            this.shape_right,
            this.shape_middle,
        ]);
    }
    isRamming() {
        return this.keys.y.wasDown && this.vel.dist() >= this.minRamSpeed;
    }
    fire(keyName) {
        if(keyName == 'x' && this.isRamming()) return;
        super.fire(keyName);
    }
    damage(hp, other) {

        // We take less damage while ramming!
        if(this.isRamming()) {
            var hpmul = 1 - linear(0, .75, this.getRamPercent());
            hp *= hpmul;
        }

        super.damage(hp, other);
    }
    step() {
        super.step();

        var isRamming = this.isRamming();

        var ramPercent = this.getRamPercent();
        var ram_gap = .6 * ramPercent;
        if(isRamming) ram_gap *= 2;
        this.shape_left.pos.y = -ram_gap / 2;
        this.shape_right.pos.y = ram_gap / 2;
        this.shape_middle.radiusmul = ramPercent * (isRamming? 2: 1);

        if(isRamming) {
            this.shotClass.extra1 = RamFlameShot;
            this.fire('extra1');

            this.vel.addSpeed(this.ramSpeed, this.rot);
        } else {
            this.shotClass.extra1 = ReverseFlameShot;
            if(this.keys.y.wasDown) this.fire('extra1');
        }
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .001) key.up();
        } else if(key.name === 'u') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .001) key.up();
        } else if(key.name === 'l' || key.name === 'r' || key.name === 'd') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .05) key.up();
        } else {
            super.stepCPUKey(key);
        }
    }
    getRamPercent() {
        // Return number between 0 and 1, representing how far we are
        // to max ram speed, where 0 indicates we have just started
        // ramming (our velocity is just high enough that isRamming()
        // is true).
        var speed = this.vel.dist();
        if(speed <= this.minRamSpeed) return 0;
        if(speed >= this.maxRamSpeed) return 1;
        return (speed - this.minRamSpeed)
            / (this.maxRamSpeed - this.minRamSpeed);
    }
    handleCollision(other) {
        var isAlly = other instanceof Ship? other.isAlly(this): false;
        if(this.isRamming() && !isAlly) {
            var damagemul = this.getRamPercent();
            var damage = this.ramDamage * damagemul;
            other.damage(damage, this);

            var hitVelMul = .5;
            other.vel.addMul(this.vel, hitVelMul);

            var velmul = .5;
            this.vel.mul(velmul);

            // r0: number between 0 and 1
            //   0 -> this.radius is infinitely bigger than other.radius
            //  .5 -> this.radius and other.radius are same size
            //   1 -> other.radius is infinitely bigger than this.radius
            var r0 = this.radius / (this.radius + other.radius);

            // addx/addy: vector sending this.pos to the point where this
            // touches other
            var dx = other.pos.x - this.pos.x;
            var dy = other.pos.y - this.pos.y;
            var addx = dx * r0;
            var addy = dy * r0;

            this.emitEffects(SparkEffect, 4, {
                speed_min: 2,
                speed_max: 4,
                velmul: .75,
                addx: addx,
                addy: addy,
            });
        }

        super.handleCollision(other);
    }
}

class AssaultShip extends Ship {
    static name = 'Assault';
    radius = 12 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = .75;
    velmul = .95;
    rotspeed = Math.PI / 26;
    rotmul = .65;

    static maxhp = 135;

    shotClass = {
        x: TripleShot,
        y: BlasterShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-.9,    0),
            new Point(-.4, -.95),
            new Point( .9,    0),
            new Point(-.4,  .95),
        ]),
    ]);
}

class TorchShip extends Ship {
    static name = 'Torch';
    radius = 6 * RADIUSMUL;
    thrustSpeed = 1.45;
    reverseSpeed = 1;
    velmul = .95;
    rotspeed = Math.PI / 30;
    rotmul = .7;

    static maxhp = 80;

    shotClass = {
        x: DoubleFlameShot,
        y: MineShot,
    };

    thrustEffectClass = SmokeThrustEffect;
    thrustEffectVelMul = .2;
    thrustEffectEvery = 3;

    circleFillStyle = 'rgba(255,200,150,.35)';
    picture = new Picture([
        new Shape([
            new Point(-1.3,    0),
            new Point( 0  ,   -1),
            new Point( 1  ,    0),
            new Point( 0  ,    1),
        ]),
    ]);
}

class HunterShip extends Ship {
    static name = 'Hunter';
    radius = 10 * RADIUSMUL;
    thrustSpeed = 1;
    reverseSpeed = .5;
    velmul = .95;
    rotspeed = Math.PI / 26;
    rotmul = .65;

    static maxhp = 100;

    addhp = DEFAULT_ADDHP * 2;

    shotClass = {
        x: DoubleMiniBlasterShot,
        y: null,
    };

    picture = new Picture([
        new Shape([
            new Point(-.9, -.9 ),
            new Point( .8, -.45),
            new Point(-.9,  .9 ),
            new Point( .8,  .45),
        ], {radiusmul: 1.2}),
    ]);

    thrustEffects = 2;
    thrustEffectPosRot = Math.PI / 2;

    cloaked = false;

    constructor(field) {
        super(field);
        this.updateThrustEffects();
    }
    render(canvas, camera) {
        if(this.cloaked) return;
        super.render(canvas, camera);
    }
    updateThrustEffects() {
        if(this.cloaked) {
            this.thrustEffectClass = SmokeThrustEffect;
            this.thrustEffectVelMul = .2;
        } else {
            this.thrustEffectClass = ThrustEffect;
            this.thrustEffectVelMul = 1;
        }
    }
    fire(keyname) {
        if(this.cloaked) return;
        super.fire(keyname);
    }
    thrust(speed, rot, effect_opts) {
        if(this.cloaked) speed *= 2;
        super.thrust(speed, rot, effect_opts);
    }
    canWarp() {
        if(this.cloaked) return false;
        return super.canWarp();
    }
    step() {

        var keyname = 'y';
        var shotprops = this.shotprops[keyname];
        if(shotprops.cooldown === 0 && !this.is_warping) {
            var cloaked = this.keys[keyname].wasDown;
            if(cloaked != this.cloaked) {
                if(cloaked) {
                    var cloakdamage = 2
                        * (1 - this.shotprops.y.level / MAX_SHOT_LEVEL);
                    this.damage(cloakdamage);
                }
                this.cloaked = cloaked;
                this.updateThrustEffects();
                this.emitEffects(SmokeEffect, 4, {
                    speed_min: 3,
                    speed_max: 6,
                    velmul: .65,
                });
                shotprops.cooldown += 5;
            }
        }

        super.step();

        if(this.cloaked) {
            this.damage(this.addhp + 1/20);
        }
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(this.hp < 15) {
                // Don't kill yourself by staying cloaked at low health
                key.up();
            } else if(key.isDown) {
                // Don't uncloak too soon
                if(Math.random() < .05) key.up();
            } else {
                // Don't randomly cloak very often
                if(Math.random() < .002) key.down();
            }
        } else {
            super.stepCPUKey(key);
        }
    }
    avoidTarget(target, keys) {
        super.avoidTarget(target, keys);

        // Cloak unless it would kill us to do so
        if(this.hp >= 15) keys.y.down();
        else keys.y.up();
    }
    _canCollide(other) {
        if(this.cloaked) return false;
        return super._canCollide(other);
    }
}

class BaseTurretShip extends Ship {
    flagship = null;

    remove() {
        if(this.flagship) this.flagship.removeTurret(this);
        super.remove();
    }
    canEmitGold() {
        return false;
    }
    getPlayer(includeCPUs) {
        if(this.flagship) return this.flagship.getPlayer(includeCPUs);
        return super.getPlayer(includeCPUs);
    }
}

class HasTurretsShip extends Ship {
    max_turret_cooldown = 100;
    max_turrets = 1;
    turret_class = null; // should extend BaseTurretShip

    constructor(field) {
        super(field);

        this.turrets = [];
        this.turret_cooldown = this.max_turret_cooldown;
    }
    remove() {
        // We iterate over a copy of this.turrets, because when we kill
        // each turret, it removes itself from this.turrets, which would
        // mess up an iteration over this.turrets.
        var turrets = this.turrets.slice();
        for(var turret of turrets) turret.die();
        super.remove();
    }
    addTurret() {
        var turret = this.field.addShip(this.turret_class);
        turret.setTeam(this.team);
        turret.pos.copy(this.pos)
            .addSpeed(this.radius + turret.radius, this.rot);
        turret.vel.copy(this.vel);
        turret.flagship = this;

        var player = this.getPlayer();
        if(player) {
            // Turret gets the same "buffs" from player's items as flagship
            player.addShipBuffs(turret);
        }

        this.turrets.push(turret);
        this.turret_cooldown = this.max_turret_cooldown;
        return turret;
    }
    removeTurret(turret) {
        removeArrayElem(this.turrets, turret);
        turret.flagship = null;
    }
    step() {
        super.step();
        if(this.turrets.length < this.max_turrets && !this.is_warping) {
            if(this.turret_cooldown) {
                this.turret_cooldown--;
            } else {
                this.addTurret();
            }
        }
    }
    beginWarp() {

        // Clone the array before iterating, since turret.die() calls
        // turret.remove() which removes the turret from this.turrets
        var turrets = this.turrets.slice();
        for(var turret of turrets) turret.die();

        super.beginWarp();
    }
    renderTurretLines(canvas, camera, addx, addy) {
        var ctx = canvas.getContext('2d');
        ctx.strokeStyle = 'rgba(0,200,200,.25)';
        ctx.lineWidth = 2;

        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;
        var x0 = this.pos.x + addx;
        var y0 = this.pos.y + addy;
        for(var turret of this.turrets) {
            var dx = moduloDiff(this.pos.x, turret.pos.x, fieldx);
            var dy = moduloDiff(this.pos.y, turret.pos.y, fieldy);
            var x1 = x0 + dx;
            var y1 = y0 + dy;

            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.closePath();
            ctx.stroke();
        }
    }
    renderPicture(canvas, camera, addx, addy) {
        this.renderTurretLines(canvas, camera, addx, addy);
        super.renderPicture(canvas, camera, addx, addy);
    }
}

class TurretShip extends BaseTurretShip {
    static name = 'Turret';
    radius = 6 * RADIUSMUL;
    thrustSpeed = .95;
    reverseSpeed = .55;
    velmul = .95;
    rotspeed = Math.PI / 40;
    rotmul = .7;

    static maxhp = 180;

    shotClass = {
        x: QuadrupleShot,
        y: QuadrupleMissileShot,
    };

    picture = new Picture([
        Shape.newPolygon(6),
        new Shape([
            new Point(0  , 0),
            new Point(1.2, 0),
        ], {fill: false, close: false}),
    ]);
}

class FlagTurretShip extends TurretShip {
    static maxhp = 60;
}

class FlagShip extends HasTurretsShip {
    static name = 'Flagship';
    radius = 10.5 * RADIUSMUL;
    thrustSpeed = 1.25;
    reverseSpeed = 1.25;
    velmul = .9;
    rotspeed = Math.PI / 34;
    rotmul = .5;

    shotClass = {
        x: SingleShot,
        y: MissileShot,
    };

    static maxhp = 175;

    max_turret_cooldown = 100;
    max_turrets = 2;
    turret_class = FlagTurretShip;

    picture = new Picture([
        new Shape([
            new Point(-.9, -.3),
            new Point(-.7, -.5),
            new Point( .9, -.5),
            new Point( .9,  .5),
            new Point(-.7,  .5),
            new Point(-.9,  .3),
        ]),
    ], {radiusmul: 1.2});

    step() {
        super.step();
        for(var turret of this.turrets) {
            for(var keyname of 'xy') {
                var key = this.keys[keyname];
                turret.keys[keyname].copy(key);
            }
            for(var keyname of 'lrud') {
                turret.keys[keyname].up();
            }

            var tdist = 60 * RADIUSMUL;
            this.spring(turret, tdist,
                {mul: .02, push: false, r0: 1});

            var targetAngle = this.rot;
            turret.rot_vel += rotDiff(turret.rot, targetAngle) * .2;
        }
    }
}

class MoleShip extends Ship {
    static name = 'Mole';
    radius = 6 * RADIUSMUL;
    thrustSpeed = 2.05;
    reverseSpeed = 1.15;
    velmul = .95;
    rotspeed = Math.PI / 30;
    rotmul = .6;

    static maxhp = 60;

    shotClass = {
        x: ShortDoubleShot,
        y: null,
    };

    picture = new Picture([
        new Shape([
            new Point(-.7, -.3),
            new Point(-.4, -.9),
            new Point( .9, -.5),
            new Point(-.1,   0),
            new Point( .9,  .5),
            new Point(-.4,  .9),
            new Point(-.7,  .3),
        ]),
    ]);

    rock = null;

    remove() {
        if(this.rock) this.exitRock();
        super.remove();
    }
    step() {
        var rock = this.rock;
        if(rock) {
            var fieldx = this.field.size.x;
            var fieldy = this.field.size.y;

            var dx = moduloDiff(this.pos.x, rock.pos.x, fieldx);
            var dy = moduloDiff(this.pos.y, rock.pos.y, fieldy);

            this.addpos.x += dx * .2;
            this.addpos.y += dy * .2;
            this.vel.x += dx * .1;
            this.vel.y += dy * .1;

            rock.rot_vel *= .95;
            rock.vel.mul(this.getVelMul());

            var addhp = (1 / 20) * (1 + .75 * this.shotprops.y.level);
            rock.heal(addhp);
        }
        super.step();
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(this.rock) {
                // Usually don't exit your rock
                if(Math.random() < .001) key.down();
                else key.up();
            } else {
                // Try to enter rocks
                if(Math.random() < .5) key.down();
                else key.up();
            }
        } else {
            super.stepCPUKey(key);
        }
    }
    fire(keyname) {
        if(keyname === 'y') {
            var shotprops = this.shotprops[keyname];
            if(this.rock) {

                // NOTE: we add to this.pos, not this.addpos, otherwise
                // this ship will collide with its rock and get a ton of
                // velocity added to it this frame
                this.pos.addSpeed(this.rock.radius * .5, this.rot);

                this.exitRock();
                shotprops.cooldown += 10;
            } else {
                var foundRock = null;
                for(var rock of this.field.rocks) {
                    if(!this.colliding(rock)) continue;
                    if(rock.mole) continue;
                    foundRock = rock;
                    break;
                }
                if(foundRock) {
                    this.enterRock(foundRock);
                    shotprops.cooldown += 30;
                }
            }
        } else {
            super.fire(keyname);
        }
    }
    afterShot(shot) {
        super.afterShot(shot);

        var rock = this.rock;
        if(rock) {
            shot.addpos.addSpeed(rock.radius - this.radius, this.rot);
        }
    }
    thrust(speed, rot, effect_opts) {
        var rock = this.rock;
        if(rock) {
            var mul = DEFAULT_ROCK_RADIUS / rock.radius;
            if(mul > 1) mul = 1;
            rock.vel.addSpeed(speed * mul, rot);
        }
        super.thrust(speed, rot, effect_opts);
    }
    turn(rot) {
        var rock = this.rock;
        if(rock) {
            var mul = DEFAULT_ROCK_RADIUS / rock.radius;
            if(mul > 1) mul = 1;
            rock.rot_vel += rot * mul * .3;
        }
        super.turn(rot);
    }
    enterRock(rock) {
        rock.mole = this;
        this.rock = rock;
        this.emitEffects(SparkEffect, 4, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
    }
    exitRock() {
        this.rock.mole = null;
        this.rock = null;
    }
    canWarp() {
        if(this.rock) return false;
        return super.canWarp();
    }
    _canCollide(other) {
        if(other === this.rock) return false;
        return super._canCollide();
    }
    _isAlly(other) {
        if(other === this.rock) return true;
        return super._isAlly(other);
    }
    canPickup(pickup) {
        if(this.rock) return false;
        return super.canPickup(pickup);
    }
}

class SuitShip extends Ship {
    static name = 'Suit';
    radius = 6 * RADIUSMUL;
    thrustSpeed = .5;
    reverseSpeed = .5;
    velmul = .995;
    rotspeed = Math.PI / 50;
    rotmul = .85;

    static maxhp = 85;

    thrustEffectClass = null;

    rock = null;
    rock_cooldown = 0;

    // rockPos: our target position on the surface of this.rock
    // (We store this point on ourself just so we don't have to allocate
    // a fresh Point every frame... I don't know if that would actually
    // affect Javascript's performance. O_o I'm sure it doesn't matter.
    // Ah well, some habits from C die hard.)
    rockPos = new Point();

    step() {
        if(this.rock && this.rock.removed) this.unsetRock();

        if(this.rock_cooldown > 0) this.rock_cooldown--;

        super.step();

        if(this.rock) this.followRock();
    }
    setRock(rock) {
        this.rock = rock;

        // Wait this many ticks before being able to jump back off rock
        this.rock_cooldown = 10;

        // We just landed on a rock, which means we were holding down 'y'
        // button. So add some cooldown before doing our 'y' action on the
        // rock.
        this.shotprops.y.cooldown += 10;

        if(this.pos.eq(rock.pos)) {
            this.rot = Random.randRotation();
        } else {
            this.rot = rock.pos.angle(this.pos, this.field.size);
        }

        this.emitEffects(SmokeEffect, 2, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.followRock();
    }
    unsetRock() {
        this.rock = null;

        // Wait this many ticks before being able to land on another rock
        this.rock_cooldown = 10;

        this.emitEffects(SmokeEffect, 2, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
    }
    followRock() {
        var rock = this.rock;

        var fieldx = this.field.size.x;
        var fieldy = this.field.size.y;

        this.rockPos.copy(rock.pos)
            .addSpeed(rock.radius + this.radius / 2, this.rot);
        var dx = moduloDiff(this.pos.x, this.rockPos.x, fieldx);
        var dy = moduloDiff(this.pos.y, this.rockPos.y, fieldy);

        this.addpos.x += dx * .5;
        this.addpos.y += dy * .5;
        this.vel.x += dx * .2;
        this.vel.y += dy * .2;
    }
    fire(keyname) {
        if(keyname === 'y') {
            // Only fire 'y' when we're on a rock.
            // Otherwise, 'y' is used to *land* on rocks (which is handled
            // elsewhere, see _handleKeys)
            if(this.rock) super.fire(keyname);
        } else {
            super.fire(keyname);
        }
    }
    _handleKeys() {
        if(this.rock) {
            // Override Ship._handleKeys entirely

            if(this.keys.u.wasDown && this.rock_cooldown === 0) {
                // Jump off this.rock
                this.vel.addSpeed(this.thrustSpeed * 5, this.rot);
                this.unsetRock();
                return;
            }

            // Turn slower when standing on bigger rocks
            // (because this.rot affects our position directly, and we want
            // to make sure we don't "move faster" when standing on bigger
            // rocks)
            var rotspeed = this.rotspeed * 1.5
                * (DEFAULT_ROCK_RADIUS / this.rock.radius);

            if(this.keys.l.wasDown) {
                this.turn(rotspeed);
            }
            if(this.keys.r.wasDown) {
                this.turn(-rotspeed);
            }
        } else {

            if(this.keys.y.wasDown && this.rock_cooldown === 0) {
                // Attempt to land on any rock we're in contact with

                var foundRock = null;
                for(var rock of this.field.rocks) {
                    if(!this.colliding(rock)) continue;
                    foundRock = rock;
                    break;
                }
                if(foundRock) {
                    this.setRock(foundRock);
                }
            }

            super._handleKeys();
        }
    }
    canWarp() {
        if(this.rock) return false;
        return super.canWarp();
    }
    _canCollide(other) {
        if(other === this.rock) return false;
        return super._canCollide();
    }
    _isAlly(other) {
        if(other === this.rock) return true;
        return super._isAlly(other);
    }
    stepCPUKey(key) {
        if(key.name === 'u' && this.rock) {
            // Usually don't exit your rock
            if(Math.random() < .001) key.down();
            else key.up();
        } else if(key.name === 'y' && !this.rock) {
            // Try to enter rocks
            if(Math.random() < .5) key.down();
            else key.up();
        } else {
            super.stepCPUKey(key);
        }
    }
}

class MinerShip extends SuitShip {
    static name = 'Miner';

    shotClass = {
        x: ToolShot,
        y: null,
    };

    dig_cooldown = 100;

    picture = new Picture([
        // body
        Shape.newPolygon(3, {rot: Math.PI}).addxy(-.3, 0).mul(.9),
        // head
        Shape.newPolygon(3, {rot: Math.PI}).addxy(1.2, 0).mul(.5),
        // left arm
        Shape.newPolygon(4).mul(.2).addxy( .1, -1),
        // right arm
        Shape.newPolygon(4).mul(.2).addxy( .1,  1),
        // left leg
        Shape.newPolygon(4, {rot: Math.PI / 4}).mulxy(.6, .3).addxy(-1, -.6),
        // right leg
        Shape.newPolygon(4, {rot: Math.PI / 4}).mulxy(.6, .3).addxy(-1,  .6),
    ]);

    afterAddShipBuffs() {
        super.afterAddShipBuffs();

        this.dig_cooldown -= 15 * this.shotprops.y.level;
    }
    fire(keyname) {
        if(
            keyname === 'y' && this.rock && this.canDig(this.rock) &&
            this.rock_cooldown === 0
        ) {
            this.dig(this.rock);
            var shotprops = this.shotprops[keyname];
            shotprops.cooldown += this.dig_cooldown;
        } else {
            super.fire(keyname);
        }
    }
    canPickup(pickup) {

        // MinerShip can't pick up gold while its digger is cooling down.
        // (So that it doesn't immediately pick up gold it generates
        // by digging)
        if(
            pickup instanceof GoldPickup &&
            this.shotprops.y.cooldown > 0
        ) return false;

        return super.canPickup(pickup);
    }
}

class EngineerShip extends SuitShip {
    static name = 'Engineer';

    shotClass = {
        x: ToolShot,
        y: RopeShot,
    };

    picture = new Picture([
        // body
        Shape.newPolygon(4, {rot: Math.PI / 4}).addxy(-.3, 0).mul(.9),
        // head
        Shape.newPolygon(4, {rot: Math.PI / 4}).addxy(1.2, 0).mul(.5),

        new Shape([
            // left arm
            new Point( .1, - .8),
            new Point( .1, -1.2),
        ]),
        new Shape([
            // right arm
            new Point( .1,   .8),
            new Point( .1,  1.2),
        ]),
        new Shape([
            // left leg
            new Point(- .9, -.5),
            new Point(-1.2, -.8),
        ]),
        new Shape([
            // right leg
            new Point(- .9,  .5),
            new Point(-1.2,  .8),
        ]),
    ]);

    ropeEnd = null;

    afterShot(shot) {
        super.afterShot(shot);
        if(shot instanceof RopeShot) {
            if(this.ropeEnd) {
                this.ropeEnd.addOtherEnd(shot);
                this.ropeEnd = null;
            } else {
                this.ropeEnd = shot;
            }
        }
    }
    step() {
        super.step();
        if(this.ropeEnd && this.ropeEnd.removed) this.ropeEnd = null;
    }
}

class TroopShip extends SuitShip {
    static name = 'Troop';
    radius = 7 * RADIUSMUL;

    static maxhp = 95;

    shotClass = {
        x: TripleToolShot,
        y: DoubleMissileShot,
    };

    picture = new Picture([
        // body
        Shape.newPolygon(5).addxy(-.3, 0).mul(.9),
        // head
        Shape.newPolygon(4, {rot: Math.PI / 4}).addxy(1.2, 0).mul(.5),

        // left arm
        Shape.newPolygon(3).mul(.3).addxy(.1, -1),

        // right arm
        Shape.newPolygon(3).mul(.3).addxy(.1,  1),

        new Shape([
            // left leg
            new Point(- .9, -.5),
            new Point(-1.2, -.8),
        ]),
        new Shape([
            // right leg
            new Point(- .9,  .5),
            new Point(-1.2,  .8),
        ]),
    ]);
}

class CrabShip extends Ship {
    static name = 'Crab';
    radius = 14 * RADIUSMUL;
    thrustSpeed = 3.25;
    reverseSpeed = 2.5;
    velmul = .85;
    rotspeed = Math.PI / 30;
    rotmul = .65;

    addhp = DEFAULT_ADDHP * 4;

    idealTargetDist = 5 * RADIUSMUL;

    static maxhp = 200;

    shotClass = {
        x: ChompShot,
        y: null,
    };

    constructor(field) {
        super(field);

        this.chomp_thrust = this.thrustSpeed * 10;
        this.chomp_cooldown = 32;

        // Set up this.picture with Shapes assigned to properties of
        // this so that we can easily animate them
        this.left_arm = new Shape([
            new Point(  0, -.4),
            new Point( .2, -.9),
            new Point(  1, -.4),
        ]);
        this.right_arm = this.left_arm.clone().flip();
        this.picture = new Picture([
            new Shape([
                // Body
                new Point(  0, -.7),
                new Point(-.8,   0),
                new Point(  0,  .7),
            ]),
            this.left_arm,
            this.right_arm,
        ]);
    }
    step() {
        super.step();
        this.animate();
    }
    animate() {
        var i = this.shotprops.x.cooldown / this.chomp_cooldown;

        // NOTE: arm_addx, arm_addy seem to have less effect than I expected.
        // Bug in Picture.render?..
        var arm_addx = 1 * i;
        var arm_addy = .5 * i;

        var arm_rot = -Math.PI / 2 * i;

        this.left_arm.pos.set(arm_addx, arm_addy);
        this.left_arm.rot = arm_rot;

        this.right_arm.pos.set(arm_addx, -arm_addy);
        this.right_arm.rot = -arm_rot;
    }
    turn(rot) {

        // This is kind of cool, but doesn't quite feel right.
        //var speed = rot * this.thrustSpeed * 4;
        //this.vel.addSpeed(speed, this.rot + Math.PI / 2);

        super.turn(rot);
    }
    fire(keyname) {
        if(keyname === 'y') {
            var shotprops = this.shotprops[keyname];

            var speed = this.chomp_thrust * (1 + .4 * shotprops.level);
            this.thrust(speed, this.rot, {cls: null});
            this.addThrustEffects(2 + shotprops.level, this.rot + Math.PI, {
                cls: FlameSmokeEffect,
                n_effects: 3,
                velmul: 0,
                posrot: Math.PI / 2,
            });

            shotprops.cooldown += this.chomp_cooldown;
        } else {
            super.fire(keyname);
        }
    }
}

function _initSwarmShip(leader) {
    // Poor man's multiple inheritance...
    // SwarmShip inherits from HasTurretsShip, SwarmTurretShip inherits
    // from BaseTurretShip, but both classes need to share some common
    // initialization, so here we are.

    // Are we the leader of our swarm?..
    leader = getDefault(leader, false);

    this.thrustSpeed = 2.2;
    this.reverseSpeed = 1.9;
    this.velmul = .9;

    this.rotspeed = Math.PI / 45;
    this.rotmul = .75;

    if(leader) {
        // Leader is slower going forwards, but faster going backwards.
        // That helps him stay behind his swarm...
        this.thrustSpeed *= .8;
        this.reverseSpeed *= 1.3;
    }

    this.shotClass = {
        x: leader? BoldSlowSingleShot: SlowSingleShot,
        y: null,
    };

    this.picture = new Picture([
        new Shape([
            new Point(-1.0,    0),
            new Point(- .1,   -.5),
            new Point( 1.2,    0),
            new Point(- .1,    .5),
        ]),
    ]);
}

class SwarmTurretShip extends BaseTurretShip {
    static name = 'Swarm';
    radius = 5 * RADIUSMUL;

    thrustSpeed = .7;
    reverseSpeed = .4;
    velmul = .975;
    rotspeed = Math.PI / 45;
    rotmul = .85;

    static maxhp = 35;

    initSwarmShip = _initSwarmShip;

    constructor(field) {
        super(field);
        this.initSwarmShip();
    }
}

class SwarmShip extends HasTurretsShip {
    static name = 'Swarm';
    radius = 6 * RADIUSMUL;

    static maxhp = 60;

    circleLineWidth = 3;

    max_turret_cooldown = 25;
    max_turrets = 3;
    turret_class = SwarmTurretShip;

    initSwarmShip = _initSwarmShip;

    constructor(field) {
        super(field);
        this.initSwarmShip(true);
    }
    afterAddShipBuffs() {
        super.afterAddShipBuffs();

        // Upgrades to our 'y' shot translate into more turrets.
        this.max_turrets += this.shotprops.y.level;
    }
    step() {
        var tightFormation = this.keys.y.isDown;

        var tdist = (tightFormation? 25: 65) * RADIUSMUL;
        var springmul = (tightFormation? .03: .02);
        for(var turret of this.turrets) {
            this.spring(turret, tdist,
                {mul: springmul, push: false, r0: .85});
        }

        super.step();

        for(var turret of this.turrets) {
            var targetAngle = this.rot;
            var rot_vel_mul = tightFormation? .2: .1;
            turret.rot_vel += rotDiff(turret.rot, targetAngle)
                * rot_vel_mul;

            for(var keyname of 'y') {
                turret.keys[keyname].up();
            }

            if(tightFormation) {
                for(var keyname of 'xud') {
                    var key = this.keys[keyname];
                    turret.keys[keyname].copy(key);
                }
                for(var keyname of 'lr') {
                    turret.keys[keyname].up();
                }
            } else {
                for(var keyname of 'x') {
                    var key = this.keys[keyname];
                    turret.keys[keyname].copy(key);
                }
                for(var keyname of 'lrud') {
                    if(Math.random() < .1) turret.keys[keyname].down();
                    if(Math.random() < .1) turret.keys[keyname].up();
                }
            }
        }
    }
    stepCPUKey(key) {
        if(key.name === 'y') {
            if(Math.random() < .05) key.down();
            if(Math.random() < .01) key.up();
        } else {
            super.stepCPUKey(key);
        }
    }
}

class BoreShip extends Ship {
    static name = 'Bore';

    radius = 7 * RADIUSMUL;
    thrustSpeed = 1.2;
    reverseSpeed = .9;
    velmul = .98;
    rotspeed = Math.PI / 25;
    rotmul = .45;

    static maxhp = 100;

    shotClass = {
        x: SingleShot,
        y: BoreShot,
    };

    picture = new Picture([
        new Shape([
            new Point(-1  , -.75),
            new Point( 1  , -.75),
            new Point( 1  ,  .75),
            new Point(-1  ,  .75),
        ], {stroke: false}),
        new Shape([
            new Point(-1  , -.75),
            new Point( 1  , -.75),
            new Point( 1  ,  .75),
            new Point(-1  ,  .75),
        ], {fill: false, close: false}),
    ]);
}

class CannonShip extends Ship {
    static name = 'Cannon';

    radius = 9 * RADIUSMUL;
    thrustSpeed = .8;
    reverseSpeed = .4;
    velmul = .99;
    rotspeed = Math.PI / 65;
    rotmul = .85;

    static maxhp = 100;

    shotClass = {
        x: DoubleCannonShot,
        y: SuperCannonShot,
    };

    picture = new Picture([
        new Shape(Point.mirror([
            new Point(-1  , -1 ),
            new Point(-.8 , -1 ),
            new Point(-.8 , -.5),
            new Point( 1 , -.5),
            new Point( 1 , -.2),
            new Point( 0 , -.2),
        ])),
    ]);
}

class Shot extends Entity {
    static name = 'Shot';

    static initialShots = 1;
    static serialShots = 1;
    // "rot variance": difference in radians between the rot of first
    // and last Shot instance produced by firing this Shot type
    initialRotVariance = 0;
    serialRotVariance = 0;
    randomRotVariance = 0;
    initialPosRotVariance = 0;
    serialPosRotVariance = 0;
    randomPosRotVariance = 0;

    // A "standard" shot goes forwards and does damage.
    // This is used by cpu-controlling code to decide whether to use
    // this shot when attempting to shoot at an enemy target.
    static isStandardShot = true;

    isReverseShot = false;

    initialSpeed = 20;
    initialVelMul = 1;
    randomSpeedVariance = 0;

    // Making player's gamepad rumble when they shoot
    static vibrateDuration = 0;
    static vibrateWeakMagnitude = 0;
    static vibrateStrongMagnitude = 0;

    // How hard we move things we hit
    hitVelMul = .05;

    // How much we transfer our rotational velocity to things we hit
    hitRotMul = .1;

    // How much damage we do
    hitDamage = 10;

    // If < 1, the amount of damage we do goes down over time
    hitDamageAgeMul = 1;

    hitEffectClass = SparkEffect;

    level = 0;

    static cooldown = 4;

    constructor(field) {
        super(field);

        // The Ship who shot us out
        this.ship = null;
    }
    getShip() {
        return this.ship;
    }
    emitShots(cls, n_shots, opts) {
        var rot_variance = getDefault(opts.rot_variance, 0);
        var rand_rot_variance = getDefault(opts.rand_rot_variance, 0);
        var speed_min = getDefault(opts.speed_min, 0);
        var speed_max = getDefault(opts.speed_max, 0);

        var velmul = .8;
        for(var i = 0; i < n_shots; i++) {
            var shot = this._shoot(cls);
            shot.rot = this.rot
                + getRotVariance(i, n_shots) * rot_variance
                + Random.randNumber(-.5, .5) * rand_rot_variance;
            var speed = Random.randNumber(speed_min, speed_max);
            shot.vel.copy(this.vel).mul(velmul)
                .addSpeed(speed, shot.rot);

            // Emitted shots "inherit" emitting shot's power level
            shot.applyPowerup(this.level);
        }
    }
    applyPowerup(level) {
        // This is called by the Entity which fired this Shot (or the Shot
        // which emitted this Shot), to apply any powerups it may have had.
        level = getDefault(level, 0);

        this.radius += Math.ceil(this.radius * .075) * level;
        this.hitDamage += Math.ceil(this.hitDamage / 4) * level;
        this.initialSpeed += Math.ceil(this.initialSpeed / 4) * level;

        // Store level on this shot (used e.g. if this shot creates
        // more shots)
        this.level = level;
    }
    afterShotBy(entity) {
        // Bit of a hack, called by Entity.shoot, Entity.emitShots, etc.
        // Just lets subclasses of Shot customize themselves a bit based
        // on the entity which shot them.
    }
    step() {
        super.step();
        this.hitDamage *= this.hitDamageAgeMul;
    }
    hit(other) {
        other.vel.addMul(this.vel, this.hitVelMul);
        other.rot_vel += this.rot_vel * this.hitRotMul;
        other.damage(this.hitDamage, this);
        this.emitEffects(this.hitEffectClass, 2, {
            speed_min: 2,
            speed_max: 4,
            velmul: .75,
        });
        this.die();
    }
}

class SingleShot extends Shot {
    radius = 3 * RADIUSMUL;
    velmul = .95;
    initialSpeed = 23;
    hitDamage = 10;
    hitDamageAgeMul = .95;
    shouldRenderTrail = true;
    static cooldown = 4;
    maxAge = 40;
    fadeWithAge = true;
}

class ShortSingleShot extends SingleShot {
    initialSpeed = 17;
    static cooldown = 3;
}

class SlowSingleShot extends SingleShot {
    initialSpeed = 17;
    static cooldown = 5;
}

class BoldSlowSingleShot extends SlowSingleShot {
    trailStrokeStyle = '#fa0';
    trailLineWidth = 3;
}

class RapidSingleShot extends SingleShot {
    radius = 4 * RADIUSMUL;
    initialSpeed = 26;
    hitDamage = 6;
    hitDamageAgeMul = .98;
    static cooldown = 2;
    hitVelMul = .09;
    trailStrokeStyle = '#aaa';
    trailEnd = .3;
}

class RapidDoubleShot extends RapidSingleShot {
    static serialShots = 2;
    serialPosRotVariance = Math.PI / 2;
}

class DoubleShot extends SingleShot {
    static serialShots = 2;
    serialRotVariance = Math.PI / 18;
}

class ShortDoubleShot extends ShortSingleShot {
    static serialShots = 2;
    serialRotVariance = Math.PI / 26;
    serialPosRotVariance = Math.PI / 3;
}

class TripleShot extends SingleShot {
    static initialShots = 3;
    static serialShots = 1;
    initialRotVariance = Math.PI / 13;
    serialRotVariance = 0;
    static cooldown = 7;
}

class QuadrupleShot extends SingleShot {
    static serialShots = 4;
    serialRotVariance = Math.PI / 20;
    serialPosRotVariance = Math.PI;
    static cooldown = 2;
}

class MiniBlasterShot extends Shot {
    radius = 4 * RADIUSMUL;
    initialSpeed = 18;
    initialVelMul = 1;
    velmul = 1;

    hitVelMul = .05;
    hitDamage = 5;

    maxAge = 12;
    static cooldown = 8;

    static vibrateDuration = 200;
    static vibrateStrongMagnitude = .2;

    picture = Picture.newPolygon(6);

    die() {
        this.emitEffects(SmokeEffect, 1, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.emitShots(SingleShot, 2, {
            rot_variance: Math.PI / 4,
            speed_min: 10,
            speed_max: 10,
        });
        super.die();
    }
}

class DoubleMiniBlasterShot extends MiniBlasterShot {
    static serialShots = 2;
    serialRotVariance = Math.PI / 26;
    serialPosRotVariance = Math.PI / 3;
}

class BlasterShot extends Shot {
    radius = 10 * RADIUSMUL;
    initialSpeed = 14;
    initialVelMul = .7;
    velmul = 1;

    hitVelMul = .5;
    hitDamage = 15;

    maxAge = 20;
    static cooldown = 32;

    static vibrateDuration = 350;
    static vibrateWeakMagnitude = .2;
    static vibrateStrongMagnitude = .6;

    picture = Picture.newPolygon(6);

    afterShotBy(entity) {
        super.afterShotBy(entity);

        // Firing this weapon has a "push back" effect on whatever fired it
        entity.vel.addSpeed(-this.initialVelMul * 8, this.rot);
    }
    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        this.emitShots(SingleShot, 5, {
            rot_variance: Math.PI / 4,
            speed_min: 10,
            speed_max: 10,
        });
        super.die();
    }
}

class MissileShot extends Shot {
    radius = 6 * RADIUSMUL;
    initialSpeed = 10;
    initialVelMul = .6;
    velmul = .9;

    thrustSpeed = 3;

    hitVelMul = .45;
    hitDamage = 10;

    maxAge = 30;
    fadeWithAge = false;
    static cooldown = 24;

    static vibrateDuration = 300;
    static vibrateWeakMagnitude = .2;
    static vibrateStrongMagnitude = .4;

    shouldRenderTrail = true;
    trailCamVel = 0;

    picture = new Picture([
        new Shape([
            new Point(-1.2, -.3),
            new Point( 1.2, -.3),
            new Point( 1.2,  .3),
            new Point(-1.2,  .3),
        ]),
    ]);

    step() {
        if(this.age < this.maxAge / 2) {
            this.vel.addSpeed(this.thrustSpeed, this.rot);
        } else {
            this.shouldRenderTrail = false;
        }
        super.step();
    }
    afterShotBy(entity) {
        super.afterShotBy(entity);
        this.rot_vel = rotDiff(this.rot, entity.rot) * 2;
    }
    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class DoubleMissileShot extends MissileShot {
    static initialShots = 2;
    initialRotVariance = Math.PI / 9;
    initialPosRotVariance = Math.PI / 3;
}

class QuadrupleMissileShot extends MissileShot {
    static serialShots = 4;
    serialRotVariance = Math.PI / 4;
    serialPosRotVariance = Math.PI;
    static cooldown = 8;
}

class CannonShot extends Shot {
    radius = 4 * RADIUSMUL;
    initialSpeed = 0;
    initialVelMul = 1;
    velmul = 1;

    hitVelMul = .05;
    hitDamage = 5;

    maxAge = 12;
    static cooldown = 8;

    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgba(255,255,255,.75)';

    numChildShots = 12;
    childShotSpacing = 9 * RADIUSMUL;

    cannonColors = {
        r: [255, 255],
        g: [255, 180],
        b: [255, 100],
        a: [.5, .5],
    };

    afterShotBy(entity) {
        super.afterShotBy(entity);

        for(var i = 0; i < this.numChildShots; i++) {

            // shot_i: the shot we're about to create is the "i"th shot,
            // where i = 0 corresponds to the initial shot (that is, the shot
            // for which the afterShotBy method is currently being called).
            var shot_i = i + 1;

            var shot = entity._shoot(this.constructor);
            shot.pos.addSpeed(
                shot_i * this.childShotSpacing, this.rot);
            shot.vel.copy(this.vel);
            shot.age = this.numChildShots - shot_i - 1;
            shot.applyPowerup(this.level);
        }

        // The current shot is considered the 0th shot, that is, shot_i = 0
        var shot_i = 0;
        this.age = this.numChildShots - shot_i - 1;
    }
    step() {
        super.step();

        this.radius = Math.max(1 * RADIUSMUL, this.radius - .5 * RADIUSMUL);

        var m = this.age / this.maxAge;
        var r = this.cannonColors.r;
        var g = this.cannonColors.g;
        var b = this.cannonColors.b;
        var a = this.cannonColors.a;
        this.circleStrokeStyle = 'transparent';
        this.circleFillStyle = Color.rgba(
            linear(r[0], r[1], m),
            linear(g[0], g[1], m),
            linear(b[0], b[1], m),
            linear(a[0], a[1], m));
    }
}

class DoubleCannonShot extends CannonShot {
    static serialShots = 2;
    serialPosRotVariance = Math.PI / 4;
}

class SuperCannonShot extends CannonShot {
    radius = 8 * RADIUSMUL;
    initialSpeed = 10;

    maxAge = 22;
    static cooldown = 45;

    static vibrateDuration = 200;
    static vibrateStrongMagnitude = .2;

    numChildShots = 12;
    childShotSpacing = 12 * RADIUSMUL;

    cannonColors = {
        r: [200, 50],
        g: [150, 0],
        b: [255, 255],
        a: [.75, .25],
    };
}

class FlameShot extends Shot {
    randomRotVariance = Math.PI / 40;
    randomPosRotVariance = Math.PI / 8;
    randomSpeedVariance = 1.5;

    initialSpeed = 10;
    initialVelMul = .8;

    hitVelMul = 0;
    hitDamage = 3;
    hitDamageAgeMul = .975;
    hitEffectClass = FlameSmokeEffect;

    static cooldown = 1;

    radius = 3 * RADIUSMUL;
    velmul = .95;
    maxAge = 25;
    fadeWithAge = true;

    picture = new Picture([
        Shape.newPolygon(3, null, {stroke: false}),
        Shape.newPolygon(3, {rot: Math.PI * 2 / 6}, {stroke: false}),
    ]);
    circleFillStyle = 'rgba(255,180,0,.25)';

    constructor(field) {
        super(field);
        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    step() {
        super.step();
        this.radius += .2 * RADIUSMUL;
    }
}

class DoubleFlameShot extends FlameShot {
    randomRotVariance = Math.PI / 20;
    randomPosRotVariance = Math.PI / 4;

    static initialShots = 2;
    initialRotVariance = Math.PI / 9;
}

class ReverseFlameShot extends FlameShot {
    isReverseShot = true;

    static isStandardShot = false;

    hitDamage = 2;
    static cooldown = 2;
}

class RamFlameShot extends ReverseFlameShot {
    /* Ram's flames when it's ramming (when isRamming() is true) */
    radius = 5 * RADIUSMUL;
    circleFillStyle = 'rgba(255,200,0,.35)';
}

class MineShot extends Shot {
    radius = 6 * RADIUSMUL;
    initialSpeed = 0;
    velmul = .9;

    static isStandardShot = false;

    hitDamage = 8;

    maxAge = 300;
    static cooldown = 32;

    picture = Picture.newPolygon(6);
    circleFillStyle = 'rgba(255,180,0,.4)';
    circleLineWidth = 3;

    die() {
        this.emitShots(FlameShot, 5, {
            rot_variance: Math.PI * 2,
            rand_rot_variance: Math.PI / 3,
            speed_min: 3,
            speed_max: 6,
        });

        super.die();
    }
}

class ChompShot extends Shot {
    radius = 10 * RADIUSMUL;
    initialSpeed = 24;
    initialVelMul = 1;
    velmul = .9;

    hitVelMul = .325;
    hitDamage = 10;

    maxAge = 5;
    static cooldown = 6;

    static vibrateDuration = 200;
    static vibrateWeakMagnitude = .35;

    circleStrokeStyle = 'rgba(255,150,0,.4)';
    inheritTeamColor = false;

    picture = new Picture([
        new Shape([
            new Point(-.4, -.85),
            new Point( .9,    0),
            new Point(-.4,  .85),
        ], {fill: false, close: false}),
    ]);

    hit(other) {
        var velmul = .35;
        var rot_velmul = .3;
        other.vel.mul(velmul);
        other.rot_vel *= rot_velmul;

        super.hit(other);
    }
}

class ToolShot extends Shot {
    radius = 4 * RADIUSMUL;
    initialSpeed = 12;
    initialVelMul = .8;
    velmul = .95;

    hitVelMul = .25;
    hitDamage = 10;

    maxAge = 25;
    static cooldown = 12;

    fadeWithAge = true;

    picture = new Picture([
        new Shape([
            Point.unit(0 / 4),
            Point.unit(2 / 4),
        ], {fill: false}),
        new Shape([
            Point.unit(1 / 4),
            Point.unit(3 / 4),
        ], {fill: false}),
    ]);
}

class TripleToolShot extends ToolShot {
    static initialShots = 3;
    initialRotVariance = Math.PI / 13;
    hitDamage = 5;
    static cooldown = 7;
}

class RopeShot extends Shot {
    radius = 4 * RADIUSMUL;
    initialSpeed = 32;
    initialVelMul = .8;
    velmul = .99;

    static isStandardShot = false;

    hitVelMul = .45;
    hitDamage = 0;

    maxAge = 35;
    connectedMaxAge = 0;
    stuckMaxAge = 200;
    static cooldown = 23;

    fadeWithAge = true;

    picture = new Picture([
        new Shape([
            new Point(-1,  0),
            new Point( 1,  0),
        ], {fill: false}),
        new Shape([
            new Point( 0, -1),
            new Point( 0,  1),
        ], {fill: false}),
    ]);

    circleLineWidth = 3;
    circleStrokeStyle = 'rgba(100,255,255,.7)';
    inheritTeamColor = false;

    otherEnd = null;
    isFirstEnd = false;

    // ropeLen: set when two ends are connected (so, when otherEnd is set).
    // Only used by the end which isFirstEnd.
    ropeLen = 0;

    stickTarget = null;

    die() {
        // Do this first so that this.dead is true, preventing this.otherEnd
        // from trying to call this.die() again (and causing an infinite loop)
        super.die();

        // The two ends die together
        if(this.otherEnd && !this.otherEnd.dead) {
            this.otherEnd.die();
        }
    }
    hit(other) {

        // Don't try to stick to something if we're already sticking
        // to something
        if(this.stickTarget) return;

        // Don't try to stick to something this rope is already sticking to
        if(this.otherEnd && this.otherEnd.stickTarget === other) return;

        other.vel.addMul(this.vel, this.hitVelMul);
        other.damage(this.hitDamage, this);
        this.emitEffects(this.hitEffectClass, 2, {
            speed_min: 2,
            speed_max: 4,
            velmul: .75,
        });

        this.addStickTarget(other);
    }
    step() {
        if(this.stickTarget && this.stickTarget.removed) this.die();

        if(this.otherEnd && this.isFirstEnd) {
            var thisTarget = this.stickTarget? this.stickTarget: this;
            var otherTarget = this.otherEnd.stickTarget?
                this.otherEnd.stickTarget: this.otherEnd;
            thisTarget.spring(otherTarget, this.ropeLen, {mul: .05});
        }

        if(this.stickTarget) {
            this.pos.copy(this.stickTarget.pos);
            this.vel.copy(this.stickTarget.vel);
        }

        super.step();
    }
    addStickTarget(stickTarget) {
        this.stickTarget = stickTarget;
        this.addMaxAge(this.stuckMaxAge);
        if(this.otherEnd) {
            var firstEnd = this.isFirstEnd? this: this.otherEnd;
            firstEnd.ropeLen += stickTarget.radius;
        }
    }
    addMaxAge(n) {
        if(this.otherEnd && this.otherEnd.isFirstEnd) {
            // The "first end" is in control of aging for both ends.
            this.otherEnd.maxAge += n;
        } else {
            this.maxAge += n;
        }
    }
    addOtherEnd(other) {
        this.isFirstEnd = true;
        this.ropeLen = this.pos.dist(other.pos, this.field.size);

        this.otherEnd = other;
        other.otherEnd = this;

        // We take on other's maxAge, e.g. in case it has already been
        // stuck to something, which adds this.stuckMaxAge, and we don't
        // want to lose that when we set other.maxAge to -1 (see below).
        this.maxAge += other.maxAge;

        this.maxAge += this.connectedMaxAge;

        // this and other are now connected, and we'd like them both
        // to die at the exact same time.
        // So we set other.maxAge to -1, which means it will not die
        // from old age.
        // So "the first end" is "in charge" of both ends' ages, as it were.
        other.maxAge = -1;
    }
    renderRope(canvas, camera, addx, addy) {

        // Only one end needs to render the rope
        if(this.otherEnd && this.otherEnd.isFirstEnd) return;

        // maxFade: don't set fade lower than 1 - maxFade, that
        // would be too close to 0, so we wouldn't be able to see
        // the Entity
        var maxFade = .85;
        var fade = 1 - (this.age / this.maxAge) * maxFade;

        var strokeStyle = 'rgba(220,200,100,.75)';
        var lineWidth = 2;
        var otherEnd = this.ship;
        if(this.otherEnd) {
            lineWidth = 3;
            otherEnd = this.otherEnd;
        }

        this.renderLineTo(canvas, camera, addx, addy, otherEnd,
            strokeStyle, lineWidth, fade);
    }
    renderPicture(canvas, camera, addx, addy) {
        this.renderRope(canvas, camera, addx, addy);
        super.renderPicture(canvas, camera, addx, addy);
    }
}

class BoreShot extends Shot {
    radius = 6 * RADIUSMUL;
    initialSpeed = 16;
    initialVelMul = .9;
    velmul = .965;

    hitVelMul = .5;
    hitDamage = 15;

    maxAge = 20;
    static cooldown = 50;

    static vibrateDuration = 350;
    static vibrateWeakMagnitude = .2;
    static vibrateStrongMagnitude = .6;

    picture = new Picture([
        new Shape([
            new Point( 1 ,  0),
            new Point( .5, -1),
            new Point(-1 , -1),
            new Point(-1 ,  1),
            new Point( .5,  1),
        ]).mulxy(1, .5),
    ]);

    dig_gold_chance = .25;

    hit(other) {
        if(other instanceof Rock) {
            this.dig(other);
            this.die();
        } else {
            super.hit(other);
        }
    }
    die() {
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });
        super.die();
    }
}

class Rock extends Entity {
    static name = 'Rock';

    circleStrokeStyle = '#987';
    velmul = 1;
    rotmul = 1;

    mole = null;

    constructor(field, radius) {
        super(field);

        radius = getDefault(radius, DEFAULT_ROCK_RADIUS);
        this.radius = radius;

        var default_hp = 30;
        this.hp = this.maxhp = parseInt(
            default_hp * radius / DEFAULT_ROCK_RADIUS);

        var n_points = Random.randIntInclusive(5, 10);
        this.picture = Picture.newPolygon(n_points,
            {rotVariance: .5, radiusVariance: .1});

        this.pos.setRandomWithin(field.size);

        var speed = Random.randNumber(3.5);
        this.vel.setSpeed(speed, Random.randRotation());

        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    getShip() {
        return this.mole;
    }
    damage(hp, other) {
        if(this.mole) hp /= 2;
        super.damage(hp, other);
    }
    remove() {
        if(this.mole) this.mole.exitRock();
        super.remove();
    }
    dieFromDamage() {
        if(this.radius >= MIN_ROCK_RADIUS) {
            var velmul = .75;
            var n_rocks = 2;
            var addposrot = Random.randRotation();
            for(var i = 0; i < n_rocks; i++) {
                var rock = this.field.addRock(
                    this.constructor, this.radius * .65);
                var posrot = (i / n_rocks) * Math.PI * 2 + addposrot;
                var posradius = this.radius;
                var radiusvelmul = .1;
                rock.pos.copy(this.pos)
                    .addSpeed(posradius, posrot);
                rock.vel.addMul(this.vel, velmul)
                    .addSpeed(posradius * radiusvelmul, posrot);
            }
        }
        this.emitEffects(SmokeEffect, 3, {
            speed_min: 3,
            speed_max: 6,
            velmul: .65,
        });

        if(Math.random() < this.field.template.energy_chance) {
            this.emitPickup(EnergyPickup);
        }
        if(Math.random() < this.field.template.fuel_chance) {
            this.emitPickup(FuelPickup);
        }

        super.dieFromDamage();
    }
}

class Planet extends Entity {

    shouldRenderCircle = true;
    shouldRenderCircleLine = false;
    circleStrokeStyle = 'transparent';
    circleFillStyle = 'rgb(0,0,255)';

    velmul = 1;
    rotmul = 1;

    constructor(field) {
        super(field);

        this.radius = Random.randNumber(50,200);

        this.circleFillStyle = this.createFillGradient();

        this.pos.setRandomWithin(field.size);

        var speed = Random.randNumber(4,6);
        this.vel.setSpeed(speed, Random.randRotation());

        this.rot_vel = Random.randNumber(-.5, .5) * Math.PI / 40;
    }
    createFillGradient() {

        // HACK?! We create a <canvas> for the sole purpose of generating
        // a CanvasGradient.
        // And then we use this same CanvasGradient with different canvases?..
        // it seems to work okay. I can't find any docs on canvas or
        // CanvasGradient which say it's limited to use with the canvas used
        // to create it.
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');

        var innerPosSpeed = Random.randNumber(this.radius);
        var innerPos = new Point()
            .addSpeed(innerPosSpeed, Random.randRotation());

        var gradient = ctx.createRadialGradient(
            // x0, y0, r0
            innerPos.x, innerPos.y, 0,
            // x1, y1, r1
            0, 0, this.radius);

        var c0 = Random.randColor(50, 150);
        var c1 = Random.randColor(50, 100);
        var c2 = Random.randColor(100);

        gradient.addColorStop(.5, c0);
        gradient.addColorStop(.75, c1);
        gradient.addColorStop(1, c2);
        return gradient;
    }
}

class ShopItem {
    name = 'Item';
    description = 'An item you can buy in a shop.';
    price = 10;

    // boughtBy: Object mapping player indices with game.players (see
    // HumanPlayer.getIndex) to boolean.
    // (Whether this item was bought by each player.)
    boughtBy = {};

    cantBuy(player) {
        // To be overridden by subclasses
        // Returns false if player *CAN* buy this item, otherwise returns
        // a string (to be displayed to player) describing why they *CAN'T*.
        // Don't you dare question my design decisions.

        if(this.wasBoughtBy(player)) {
            return 'Already bought!';
        }

        if(player.gold < this.price) {
            return 'Not enough gold!';
        }

        return null;
    }
    wasBoughtBy(player) {
        return Boolean(this.boughtBy[player.getIndex()]);
    }
    buy(player) {
        // To be overridden by subclasses
        // We assume this.cantBuy(player) has already been called successfully
        // (without throwing ShopItemBuyError)

        player.gold -= this.price;
        this.boughtBy[player.getIndex()] = true;
    }
}

class TrinketShopItem extends ShopItem {
    constructor(name, price, description) {
        super();
        this.name = name;
        this.price = getDefault(price, 0);
        this.description = getDefault(description, 'A useless trinket.');
    }
    buy(player) {
        super.buy(player);

        var trinket = new Trinket(this.name, this.description);
        player.trinkets.push(trinket);
    }
}

class PickupMagnetShopItem extends ShopItem {
    name = 'Pickup Magnet';
    description = 'Increases your ship\'s magnetic pull on nearby energy/fuel/gold.';
    price = 40;

    cantBuy(player) {
        var value = super.cantBuy(player);
        if(value) return value;

        if(player.pickupMagnet >= MAX_PICKUP_MAGNET) {
            return 'Pickup magnet already fully upgraded';
        }
        return null;
    }
    buy(player) {
        super.buy(player);
        player.pickupMagnet++;
    }
}

class MaxEnergyShopItem extends ShopItem {
    description = 'Permanently increases the maximum energy of your ship.';

    constructor(energy) {
        super();
        this.energy = energy;
        this.name = '+' + String(energy) + ' Max Energy';
        this.price = 20 + energy * 2;
    }
    buy(player) {
        super.buy(player);
        player.addmaxhp += this.energy;
    }
}

class MaxFuelShopItem extends ShopItem {
    description = 'Permanently increases your maximum fuel.';

    constructor(fuel) {
        super();
        this.fuel = fuel;
        this.name = '+' + String(fuel) + ' Max Fuel';
        this.price = 20 + fuel * 2;
    }
    buy(player) {
        super.buy(player);
        player.maxfuel += this.fuel;
        player.fuel += this.fuel;
    }
}

class SpeedShopItem extends ShopItem {
    name = 'Increase Thrust & Turn Speed';
    price = 40;
    description = 'Permanently increases your ship\'s forward/reverse thrust and turning speed.';

    buy(player) {
        super.buy(player);
        player.increaseThrustSpeed++;
        player.increaseReverseSpeed++;
        player.increaseRotSpeed++;
    }
}

class BasePowerupShopItem extends ShopItem {
    name = 'Weapon/Ability Powerup';
    price = 50;
    description = 'Permanently powers up your ship\'s weapon/ability.';

    keyname = null; // String, e.g. 'x', 'y'

    cantBuy(player) {
        var value = super.cantBuy(player);
        if(value) return value;

        if(player[this.keyname + 'ShotLevel'] >= MAX_SHOT_LEVEL) {
            return 'Already fully powered up';
        }
        return null;
    }
    buy(player) {
        super.buy(player);
        player[this.keyname + 'ShotLevel']++;
    }
}

class PrimaryPowerupShopItem extends BasePowerupShopItem {
    name = 'Primary Weapon/Ability Powerup';
    description = 'Permanently powers up your ship\'s primary weapon/ability.';
    keyname = 'x';
}

class SecondaryPowerupShopItem extends BasePowerupShopItem {
    name = 'Secondary Weapon/Ability Powerup';
    description = 'Permanently powers up your ship\'s secondary weapon/ability.';
    keyname = 'y';
}

class ShipShopItem extends ShopItem {
    description = 'Use ships you\'ve bought in the "Choose Ship" menu.';

    constructor(cls, price) {
        super();
        this.cls = cls;
        this.name = 'Ship: ' + cls.name;
        this.price = price;
    }
    cantBuy(player) {
        var value = super.cantBuy(player);
        if(value) return value;

        if(player.shipClasses.indexOf(this.cls) >= 0) {
            return 'Already have ship: ' + this.cls.name;
        }
        return null;
    }
    buy(player) {
        super.buy(player);
        player.shipClasses.push(this.cls);
    }
}

class Shop {
    constructor(name, description, items) {
        this.name = name;
        this.description = description;

        // items: Array of ShopItem
        this.items = items;
    }
}


var SHIP_CLASSES = new OrderedDict()
    .set('fighter', FighterShip)
    .set('scout', ScoutShip)
    .set('assault', AssaultShip)
    .set('torch', TorchShip)
    .set('turret', TurretShip)
    .set('flag', FlagShip)
    .set('mole', MoleShip)
    .set('crab', CrabShip)
    .set('ram', RamShip)
    .set('hunter', HunterShip)
    .set('swarm', SwarmShip)
    .set('miner', MinerShip)
    .set('engineer', EngineerShip)
    .set('troop', TroopShip)
    .set('bore', BoreShip)
    .set('cannon', CannonShip)
;


var canvas_container = document.getElementById('canvas-container');
var controls = document.getElementById('controls');

var defaultMap = new function() {
    var map = new Map();

    function mkships(teamsMap) {
        var ships = new WeightedArray();
        for(var teamName in teamsMap) {
            var team = TEAMS.get(teamName);
            var shipsMap = teamsMap[teamName];
            for(var shipName in shipsMap) {
                var shipClass = SHIP_CLASSES.get(shipName);
                var weight = shipsMap[shipName];
                var shipTemplate = new ShipTemplate(shipClass, team);
                ships.addEntry(shipTemplate, weight);
            }
        }
        return ships;
    }

    function mktemplate(props) {
        props = props || {};
        props = Object.assign({}, props);

        if(props.width) props.width.mul(DEFAULT_FIELD_WIDTH);
        if(props.height) props.height.mul(DEFAULT_FIELD_HEIGHT);

        if(props.stars_per) props.stars_per.mul(DEFAULT_STARS_PER);
        if(props.rocks_per) props.rocks_per.mul(DEFAULT_ROCKS_PER);
        if(props.planets_per) props.planets_per.mul(DEFAULT_PLANETS_PER);
        if(props.ships_per) props.ships_per.mul(DEFAULT_SHIPS_PER);

        if(props.rock_radius) props.rock_radius.mul(DEFAULT_ROCK_RADIUS * RADIUSMUL);
        if(props.star_speed) props.star_speed.mul(DEFAULT_STAR_SPEED);

        return new FieldTemplate(props);
    }

    function mknodes(nodeMap) {
        var nodes = {};
        for(var nodeName in nodeMap) {
            var nodeProps = nodeMap[nodeName];
            var node = map.addNode(nodeProps.template,
                nodeProps.title, nodeProps.description);
            nodes[nodeName] = node;
        }
        for(var nodeName in nodeMap) {
            var node = nodes[nodeName];
            var nodeProps = nodeMap[nodeName];
            var edgeMap = nodeProps.edges;
            if(!edgeMap) continue;
            for(var node1Name in edgeMap) {
                var node1 = nodes[node1Name];
                var len = edgeMap[node1Name];
                node.addEdge(node1, len);
            }
        }
        return nodes;
    }

    function defnode(title, description, template, edges) {
        // "defnode" not "mknode" because we don't actually return
        // a MapNode.
        return {
            title: title,
            description: description,
            template: template,
            edges: edges,
        };
    }

    var nodes = mknodes({

        // INTRODUCTION
        // A series of fields, comprising the title screen and tutorial.
        intro0: defnode('Introduction', [],
            mktemplate({
                rocks_per: new MinMax(0),
                rocksText: 'SHIPteroids',
                energy_chance: 0,
                fuel_chance: 0,
                text: new Text('Welcome to space', [
                    'Try out your new ship.',
                    'Once you\'re ready, press Backspace to warp to the next area.',
                    'Try not to hit things while warping.',
                ]),
            }), {intro1: 1}),
        intro1: defnode('Introduction', [],
            mktemplate({
                rocks_per: new MinMax(1),
                energy_chance: .5,
                fuel_chance: .5,
                text: new Text('Energy and fuel', [
                    'When your ship is damaged, it consumes energy.',
                    'When you warp, you consume fuel.',
                    'At the bottom of the screen, your energy',
                    'and fuel are shown as "E" and "F".',
                    'Shoot asteroids open to find more.',
                ]),
            }), {intro2: 1}),
        intro2: defnode('Introduction', [],
            mktemplate({
                rocks_per: new MinMax(2),
                ships_per: new MinMax(2),
                ships: mkships({
                    green: {fighter: 1},
                }),
                text: new Text('Friendly ships', [
                    '...are green, like you.',
                    'Don\'t worry, you can\'t damage each other.',
                ]),
            }), {intro3: 1}),
        intro3: defnode('Introduction',
            [
                'Welcome to the map!',
                'When warping, you move along the arrows on the map.',
                'When the path branches, you must choose which way to go.',
            ],
            mktemplate({
                rocks_per: new MinMax(.4),
                gold_chance: 1,
                ships_per: new MinMax(.5),
                ships: mkships({
                    blue: {fighter: 1},
                }),
                text: new Text('Hostile ship!', [
                    'At the bottom of the screen, your gold',
                    'is shown as "G".',
                    'Destroy ships to find more.',
                    'You can always warp away instead of fighting.',
                ]),
            }), {intro4a: 1, intro4b: 1}),
        intro4a: defnode('Introduction', [],
            mktemplate({
                width: new MinMax(4),
                height: new MinMax(.3),
                rocks_per: new MinMax(3),
                planets_per: new MinMax(0),
                text: new Text('The map', [
                    'Notice how space wraps around? Weird huh.',
                    'That\'s true in every area, it\'s just more obvious',
                    'in this one because it\'s so wide.',
                ]),
            }), {intro5: 1}),
        intro4b: defnode('Introduction', [],
            mktemplate({
                width: new MinMax(.3),
                height: new MinMax(4),
                rocks_per: new MinMax(3),
                planets_per: new MinMax(0),
                text: new Text('The map', [
                    'Notice how space wraps around? Weird huh.',
                    'That\'s true in every area, it\'s just more obvious',
                    'in this one because it\'s so tall.',
                ]),
            }), {intro5: 1}),
        intro5: defnode('Introduction', [],
            mktemplate({
                rocks_per: new MinMax(3),
                energy_chance: 0,
                fuel_chance: .75,
                text: new Text('Long warps', [
                    'Hold Tab to look at the map now, and you will see that',
                    'the "distance" to the next area is 2.',
                    'That means it will take 2 warps to get to the next area.',
                    'So stock up on fuel here! These asteroids are full of it...',
                ]),
            }), {intro6: 2}),
        intro6: defnode('Shop', [],
            mktemplate({
                rocks_per: new MinMax(0),
                shop: new Shop('Introductory Shop',
                    [
                        'There are shops in space!',
                        'And the only currency they accept is, uh, gold pieces.',
                        'Use the arrow keys to change selected item, and Enter to buy.',
                    ],
                    [
                        new TrinketShopItem('Useless Trinket', 5,
                            "It may not be very useful, but it's *yours*."),
                        Object.assign(new MaxEnergyShopItem(10), {
                            description:
                                "This would be really useful, " +
                                "if you could afford it."
                        }),
                    ]),
            }), {basic0: 1}),

        // BASIC TRAINING
        // A circular set of fields, introducing you to the most common
        // types of ship.
        basic0: defnode('Basic Training', [],
            mktemplate({
                ships_per: new MinMax(.75),
                ships: mkships({
                    green: {fighter: 1},
                    blue: {fighter: 1},
                }),
            }), {basic1: 1}),
        basic1: defnode('Basic Training', [],
            mktemplate({
                ships_per: new MinMax(.75),
                ships: mkships({
                    green: {scout: 1},
                    blue: {assault: 1},
                }),
            }), {basic2: 2}),
        basic2: defnode('Basic Training', [],
            mktemplate({ships: mkships({
                green: {fighter: .5, assault: 1, flag: .5},
                yellow: {fighter: 2, scout: 1, mole: .5},
            })}), {basic3: 2, basic_shop: 3}),
        basic_shop: defnode('Basic Shop', [],
            mktemplate({
                shop: new Shop('Basic Shop',
                    ['Basic stuff like upgrades and fancy new ships.'],
                    [
                        new MaxEnergyShopItem(10),
                        new MaxEnergyShopItem(10),
                        new MaxFuelShopItem(10),
                        new MaxFuelShopItem(10),
                        new PickupMagnetShopItem(),
                        new ShipShopItem(TurretShip, 40),
                        new ShipShopItem(HunterShip, 40),
                        new ShipShopItem(TroopShip, 40),
                        new ShipShopItem(SwarmShip, 40),
                        new ShipShopItem(FlagShip, 100),
                    ]),
            }), {basic2: 2}),
        basic3: defnode('Basic Training', [],
            mktemplate({ships: mkships({
                green: {assault: 1, scout: 1},
                yellow: {fighter: 1, mole: 1},
                red: {torch: 1},
            })}), {basic0: 2, fire0: 4, corridor0: 2}),

        // FIRE
        // A place full of torches and rams. Presumably red team's home base.
        fire0: defnode('Fire', [],
            mktemplate({
                height: new MinMax(3),
                rocks_per: new MinMax(.5),
                rock_radius: new MinMax(.15, .75),
                ships_per: new MinMax(2),
                ships: mkships({red: {ram: 1, torch: .25}}),
            }), {fire1: 2}),
        fire1: defnode('Fire', [],
            mktemplate({
                height: new MinMax(3),
                rocks_per: new MinMax(10,30),
                rock_radius: new MinMax(.15, .75),
                ships_per: new MinMax(2),
                ships: mkships({red: {torch: 1}}),
            }), {basic2: 1, fire_shop: 1}),
        fire_shop: defnode('Fire Shop', [],
            mktemplate({
                height: new MinMax(3),
                rocks_per: new MinMax(10,30),
                rock_radius: new MinMax(.15, .75),
                shop: new Shop('Fire Shop',
                    ['There is a shop among the flames.'],
                    [
                        new TrinketShopItem('Fire Trinket', 10,
                            'Proves you made it to the Fire area.'),
                        new MaxEnergyShopItem(40),
                        new MaxFuelShopItem(20),
                        new MaxFuelShopItem(20),
                        new PrimaryPowerupShopItem(),
                        new SecondaryPowerupShopItem(),
                        new ShipShopItem(TorchShip, 40),
                        new ShipShopItem(RamShip, 40),
                        new ShipShopItem(CrabShip, 40),
                    ]),
            }), {fire1: 1}),

        // CORRIDOR
        // A series of wide fields, with not many rocks, stars, or planets.
        // Mostly blue team (assault+hunter), with some red (crab+hunter).
        // Maybe the first time you meet hunters?..
        corridor0: defnode('Corridor', [],
            mktemplate({
                width: new MinMax(1, 2),
                height: new MinMax(.5, 1),
                rocks_per: new MinMax(.7),
                rock_radius: new MinMax(1, 2),
                stars_per: new MinMax(.2),
                planets_per: new MinMax(.2),
                ships: mkships({
                    green: {fighter: 1},
                    blue: {assault: 1, hunter: .5},
                    red: {crab: 1},
                }),
            }), {corridor1: 4}),
        corridor1: defnode('Corridor', [],
            mktemplate({
                width: new MinMax(2, 3),
                height: new MinMax(1),
                rocks_per: new MinMax(.7),
                rock_radius: new MinMax(1, 3),
                ships_per: new MinMax(.8),
                stars_per: new MinMax(.2),
                planets_per: new MinMax(.2),
                ships: mkships({
                    blue: {assault: 1, hunter: .5},
                    red: {crab: 1, hunter: .5},
                }),
            }), {corridor2: 4, corridor_shop: 1}),
        corridor_shop: defnode('Corridor', [],
            mktemplate({
                shop: new Shop('Secret Shop', [],
                    [
                        new MaxEnergyShopItem(20),
                        new MaxFuelShopItem(30),
                        new PrimaryPowerupShopItem(),
                        new PrimaryPowerupShopItem(),
                        new SecondaryPowerupShopItem(),
                        new SecondaryPowerupShopItem(),
                        new SpeedShopItem(),
                        new PickupMagnetShopItem(),
                    ]),
            }), {corridor1: 1}),
        corridor2: defnode('Corridor', [],
            mktemplate({
                width: new MinMax(2, 3),
                height: new MinMax(1, 2),
                rocks_per: new MinMax(.5),
                rock_radius: new MinMax(1, 3),
                ships_per: new MinMax(.8),
                stars_per: new MinMax(.2),
                planets_per: new MinMax(.2),
                ships: mkships({
                    blue: {assault: 1, hunter: .5, flag: .5},
                    red: {crab: 1, hunter: .5, ram: 1},
                }),
            }), {rock0: 3, mines0: 3}),

        // ROCK
        // A big field, full of rocks, bit of every team, lots of moles & suits.
        rock0: defnode('Rock', [],
            mktemplate({
                width: new MinMax(2),
                rocks_per: new MinMax(10),
                rock_radius: new MinMax(.7, 3.2),
                ships_per: new MinMax(2),
                ships: mkships({
                    green: {mole: 1, troop: 1},
                    blue: {mole: 1, troop: 1},
                    yellow: {mole: 1, engineer: 1},
                    red: {crab: 1},
                }),
            }), {rock1: 2}),
        rock1: defnode('Rock', [],
            mktemplate({
                width: new MinMax(2),
                rocks_per: new MinMax(20),
                rock_radius: new MinMax(.5, 1.5),
                ships_per: new MinMax(2),
                ships: mkships({
                    green: {fighter: 1, mole: .5, engineer: .5, troop: .5},
                    blue: {assault: 1, mole: 1, troop: 1},
                    yellow: {scout: 1, mole: 1, engineer: 1},
                    red: {mole: .5, troop: 2},
                }),
            }), {basic1: 2, rock_shop: 1}),
        rock_shop: defnode('Rock Shop', [],
            mktemplate({
                width: new MinMax(2),
                rocks_per: new MinMax(20),
                rock_radius: new MinMax(.5, 1.5),
                shop: new Shop('Rock Shop',
                    [],
                    [
                        new TrinketShopItem('Rock Trinket', 10,
                            'Proves you made it to the Rock area.'),
                        new MaxEnergyShopItem(20),
                        new MaxEnergyShopItem(20),
                        new MaxFuelShopItem(30),
                        new ShipShopItem(MoleShip, 40),
                        new ShipShopItem(EngineerShip, 40),
                        new ShipShopItem(BoreShip, 100),
                        new ShipShopItem(MinerShip, 100),
                    ]),
            }), {rock1: 1}),

        // MINES
        // Full of asteroids, miners, and bores.
        // And... swarms, to add some danger to it all.
        mines0: defnode('Mines', [],
            mktemplate({
                width: new MinMax(2),
                height: new MinMax(2),
                rocks_per: new MinMax(3),
                rock_radius: new MinMax(1, 2),
                ships_per: new MinMax(2),
                ships: mkships({
                    green: {mole: 1},
                    yellow: {mole: 1},
                    red: {swarm: 1},
                }),
            }), {mines1: 2}),
        mines1: defnode('Mines', [],
            mktemplate({
                width: new MinMax(3),
                height: new MinMax(3),
                rocks_per: new MinMax(2),
                rock_radius: new MinMax(1, 2),
                ships_per: new MinMax(1.2),
                ships: mkships({
                    green: {mole: 1, miner: 1},
                    yellow: {mole: 1, miner: 1},
                    blue: {swarm: 2},
                }),
            }), {mines2: 2}),
        mines2: defnode('Mines', [],
            mktemplate({
                width: new MinMax(2),
                height: new MinMax(2),
                rocks_per: new MinMax(5),
                rock_radius: new MinMax(.5, 1.5),
                ships: mkships({
                    yellow: {bore: 2},
                    blue: {swarm: 1},
                }),
            }), {corridor2: 2}),
    });

    var startNodeName = getParam('start_node');
    map.startNode = startNodeName? nodes[startNodeName]: null;

    return {
        map: map,
        nodes: nodes,
    };
};

var game = new Game(defaultMap.map);
for(var i = 0; i < N_PLAYERS; i++) game.addPlayer();

canvas_container.childNodes[0].data = ''; // Remove the 'Loading...' text
canvas_container.focus();

game.play();


</script>
</body>
</html>